<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Hedging resilience strategy | Polly </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Hedging resilience strategy | Polly ">
      
      <link rel="icon" href="../icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/App-vNext/Polly/blob/main/docs/strategies/hedging.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../icon.png" alt="Polly">
            Polly
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="hedging-resilience-strategy">Hedging resilience strategy</h1>

<h2 id="about">About</h2>
<ul>
<li><strong>Options</strong>: <a href="xref:Polly.Hedging.HedgingStrategyOptions%601"><code>HedgingStrategyOptions&lt;T&gt;</code></a></li>
<li><strong>Extensions</strong>: <code>AddHedging</code></li>
<li><strong>Strategy Type</strong>: Reactive</li>
</ul>
<hr>
<p>The hedging strategy enables the re-execution of a user-defined callback if the previous execution takes too long. This approach gives you the option to either run the original callback again or specify a new callback for subsequent hedged attempts. Implementing a hedging strategy can boost the overall responsiveness of the system. However, it's essential to note that this improvement comes at the cost of increased resource utilization. If low latency is not a critical requirement, you may find the <a href="retry.html">retry strategy</a> is more appropriate.</p>
<p>This strategy also supports multiple <a href="#concurrency-modes">concurrency modes</a> for added flexibility.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Please do not start any background work when executing actions using the hedging strategy. This strategy can spawn multiple parallel tasks, and as a result multiple background tasks can be started.</p>
</div>
<h2 id="usage">Usage</h2>
<!-- snippet: hedging -->
<pre><code class="lang-cs">// Add hedging with default options.
// See https://www.pollydocs.org/strategies/hedging#defaults for defaults.
new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddHedging(new HedgingStrategyOptions&lt;HttpResponseMessage&gt;());

// Add a customized hedging strategy that retries up to 3 times if the execution
// takes longer than 1 second or if it fails due to an exception or returns an HTTP 500 Internal Server Error.
new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddHedging(new HedgingStrategyOptions&lt;HttpResponseMessage&gt;
    {
        ShouldHandle = new PredicateBuilder&lt;HttpResponseMessage&gt;()
            .Handle&lt;SomeExceptionType&gt;()
            .HandleResult(response =&gt; response.StatusCode == HttpStatusCode.InternalServerError),
        MaxHedgedAttempts = 3,
        Delay = TimeSpan.FromSeconds(1),
        ActionGenerator = args =&gt;
        {
            Console.WriteLine(&quot;Preparing to execute hedged action.&quot;);

            // Return a delegate function to invoke the original action with the action context.
            // Optionally, you can also create a completely new action to be executed.
            return () =&gt; args.Callback(args.ActionContext);
        }
    });

// Subscribe to hedging events.
new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddHedging(new HedgingStrategyOptions&lt;HttpResponseMessage&gt;
    {
        OnHedging = args =&gt;
        {
            Console.WriteLine($&quot;OnHedging: Attempt number {args.AttemptNumber}&quot;);
            return default;
        }
    });
</code></pre>
<!-- endSnippet -->
<h2 id="defaults">Defaults</h2>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ShouldHandle</code></td>
<td>Predicate that handles all exceptions except <code>OperationCanceledException</code>.</td>
<td>Predicate that determines what results and exceptions are handled by the retry strategy.</td>
</tr>
<tr>
<td><code>MaxHedgedAttempts</code></td>
<td>1</td>
<td>The maximum number of hedged actions to use, in addition to the original action.</td>
</tr>
<tr>
<td><code>Delay</code></td>
<td>2 seconds</td>
<td>The maximum waiting time before spawning a new hedged action.</td>
</tr>
<tr>
<td><code>ActionGenerator</code></td>
<td>Returns the original callback that was passed to the hedging strategy.</td>
<td>Generator that creates hedged actions.</td>
</tr>
<tr>
<td><code>DelayGenerator</code></td>
<td><code>null</code></td>
<td>Used for generating custom delays for hedging. If <code>null</code> then <code>Delay</code> is used.</td>
</tr>
<tr>
<td><code>OnHedging</code></td>
<td><code>null</code></td>
<td>Event that is raised when a hedging is performed.</td>
</tr>
</tbody>
</table>
<p>You can use the following special values for <code>Delay</code> or in <code>DelayGenerator</code>:</p>
<ul>
<li><code>0 seconds</code> - the hedging strategy immediately creates a total of <code>MaxHedgedAttempts</code> and completes when the fastest acceptable result is available.</li>
<li><code>-1 millisecond</code> - this value indicates that the strategy does not create a new hedged task before the previous one completes. This enables scenarios where having multiple concurrent hedged tasks can cause side effects.</li>
</ul>
<h2 id="concurrency-modes">Concurrency modes</h2>
<p>In the sections below, explore the different concurrency modes available in the hedging strategy. The behavior is primarily controlled by the <code>Delay</code> property value.</p>
<h3 id="latency-mode">Latency mode</h3>
<p>When the <code>Delay</code> property is set to a value greater than zero, the hedging strategy operates in latency mode. In this mode, additional executions are triggered when the initial ones take too long to complete. By default, the <code>Delay</code> is set to 2 seconds.</p>
<ul>
<li>The primary execution is initiated.</li>
<li>If the initial execution either fails or takes longer than the <code>Delay</code> to complete, a new execution is initiated.</li>
<li>If the first two executions fail or exceed the <code>Delay</code> (calculated from the last initiated execution), another execution is triggered.</li>
<li>The final result is the result of fastest successful execution.</li>
<li>If all executions fail, the final result will be the first failure encountered.</li>
</ul>
<h3 id="fallback-mode">Fallback mode</h3>
<p>In fallback mode, the <code>Delay</code> value should be less than <code>TimeSpan.Zero</code>. This mode allows only a single execution to proceed at a given time.</p>
<ul>
<li>An execution is initiated, and the strategy waits for its completion.</li>
<li>If the initial execution fails, new one is initiated.</li>
<li>The final result will be the first successful execution.</li>
<li>If all executions fail, the final result will be the first failure encountered.</li>
</ul>
<h3 id="parallel-mode">Parallel mode</h3>
<p>The hedging strategy operates in parallel mode when the <code>Delay</code> property is set to <code>TimeSpan.Zero</code>. In this mode, all executions are initiated simultaneously, and the strategy waits for the fastest completion.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Use this mode only when absolutely necessary, as it consumes the most resources, particularly when the hedging strategy uses remote resources such as remote HTTP services.</p>
</div>
<ul>
<li>All executions are initiated simultaneously, adhering to the <code>MaxHedgedAttempts</code> limit.</li>
<li>The final result will be the fastest successful execution.</li>
<li>If all executions fail, the final result will be the first failure encountered.</li>
</ul>
<h3 id="dynamic-mode">Dynamic mode</h3>
<p>In dynamic mode, you have the flexibility to control how the hedging strategy behaves during each execution. This control is achieved through the <code>DelayGenerator</code> property.</p>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>Delay</code> property is disregarded when <code>DelayGenerator</code> is set.</p>
</div>
<p>Example scenario:</p>
<ul>
<li>First, initiate the first two executions in parallel mode.</li>
<li>Subsequently, switch to fallback mode for additional executions.</li>
</ul>
<p>To configure hedging according to the above scenario, use the following code:</p>
<!-- snippet: hedging-dynamic-mode -->
<pre><code class="lang-cs">new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddHedging(new()
    {
        MaxHedgedAttempts = 3,
        DelayGenerator = args =&gt;
        {
            var delay = args.AttemptNumber switch
            {
                0 =&gt; TimeSpan.FromSeconds(1),
                1 =&gt; TimeSpan.FromSeconds(2),
                _ =&gt; System.Threading.Timeout.InfiniteTimeSpan
            };

            return new ValueTask&lt;TimeSpan&gt;(delay);
        }
    });
</code></pre>
<!-- endSnippet -->
<p>With this configuration, the hedging strategy:</p>
<ul>
<li>Initiates a maximum of <code>4</code> executions. This includes initial action and an additional 3 attempts.</li>
<li>Allows the first two executions to proceed in parallel, while the third and fourth executions follow the fallback mode.</li>
</ul>
<h2 id="action-generator">Action generator</h2>
<p>The hedging options include an <code>ActionGenerator</code> property, allowing you to customize the actions executed during hedging. By default, the <code>ActionGenerator</code> returns the original callback passed to the strategy. The original callback also includes any logic introduced by subsequent resilience strategies. For more advanced scenarios, the <code>ActionGenerator</code> can be used to return entirely new hedged actions, as demonstrated in the example below:</p>
<!-- snippet: hedging-action-generator -->
<pre><code class="lang-cs">new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddHedging(new()
    {
        ActionGenerator = args =&gt;
        {
            // You can access data from the original (primary) context here
            var customData = args.PrimaryContext.Properties.GetValue(customDataKey, &quot;default-custom-data&quot;);

            Console.WriteLine($&quot;Hedging, Attempt: {args.AttemptNumber}, Custom Data: {customData}&quot;);

            // Here, we can access the original callback and return it or return a completely new action
            var callback = args.Callback;

            // A function that returns a ValueTask&lt;Outcome&lt;HttpResponseMessage&gt;&gt; is required.
            return async () =&gt;
            {
                try
                {
                    // A dedicated ActionContext is provided for each hedged action.
                    // It comes with a separate CancellationToken created specifically for this hedged attempt,
                    // which can be cancelled later if needed.
                    //
                    // Note that the &quot;MyRemoteCallAsync&quot; call won't have any additional resilience applied.
                    // You are responsible for wrapping it with any additional resilience pipeline.
                    var response = await MyRemoteCallAsync(args.ActionContext.CancellationToken);

                    return Outcome.FromResult(response);
                }
                catch (Exception e)
                {
                    // Note: All exceptions should be caught and converted to Outcome.
                    return Outcome.FromException&lt;HttpResponseMessage&gt;(e);
                }
            };
        }
    });
</code></pre>
<!-- endSnippet -->
<h3 id="parameterized-callbacks-and-action-generator">Parameterized callbacks and action generator</h3>
<p>When you have control over the callbacks that the resilience pipeline receives, you can parameterize them. This flexibility allows for reusing the callbacks within an action generator.</p>
<p>A common use case is with <a href="https://learn.microsoft.com/aspnet/web-api/overview/advanced/http-message-handlers"><code>DelegatingHandler</code></a>. Here, you can parameterize the <code>HttpRequestMessage</code>:</p>
<!-- snippet: hedging-handler -->
<pre><code class="lang-cs">internal class HedgingHandler : DelegatingHandler
{
    private readonly ResiliencePipeline&lt;HttpResponseMessage&gt; _pipeline;

    public HedgingHandler(ResiliencePipeline&lt;HttpResponseMessage&gt; pipeline)
    {
        _pipeline = pipeline;
    }

    protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        var context = ResilienceContextPool.Shared.Get(cancellationToken);

        // Store the incoming request in the context
        context.Properties.Set(ResilienceKeys.RequestMessage, request);

        try
        {
            return await _pipeline.ExecuteAsync(async cxt =&gt;
            {
                // Allow the pipeline to use request message that was stored in the context.
                // This allows replacing the request message with a new one in the resilience pipeline.
                request = cxt.Properties.GetValue(ResilienceKeys.RequestMessage, request);

                return await base.SendAsync(request, cxt.CancellationToken);
            },
            context);
        }
        finally
        {
            ResilienceContextPool.Shared.Return(context);
        }
    }
}
</code></pre>
<!-- endSnippet -->
<p>Where <code>ResilienceKeys</code> is defined as:</p>
<!-- snippet: hedging-resilience-keys -->
<pre><code class="lang-cs">internal static class ResilienceKeys
{
    public static readonly ResiliencePropertyKey&lt;HttpRequestMessage&gt; RequestMessage = new(&quot;MyFeature.RequestMessage&quot;);
}
</code></pre>
<!-- endSnippet -->
<p>In your <code>ActionGenerator</code>, you can easily provide your own <code>HttpRequestMessage</code> to <code>ActionContext</code>, and the original callback will use it:</p>
<!-- snippet: hedging-parametrized-action-generator -->
<pre><code class="lang-cs">new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddHedging(new()
    {
        ActionGenerator = args =&gt;
        {
            if (!args.PrimaryContext.Properties.TryGetValue(ResilienceKeys.RequestMessage, out var request))
            {
                throw new InvalidOperationException(&quot;The request message must be provided.&quot;);
            }

            // Prepare a new request message for the callback, potentially involving:
            //
            // - Cloning the request message
            // - Providing alternate endpoint URLs
            request = PrepareRequest(request);

            // Override the request message in the action context
            args.ActionContext.Properties.Set(ResilienceKeys.RequestMessage, request);

            // Then, execute the original callback
            return () =&gt; args.Callback(args.ActionContext);
        }
    });
</code></pre>
<!-- endSnippet -->

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/App-vNext/Polly/blob/main/docs/strategies/hedging.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
