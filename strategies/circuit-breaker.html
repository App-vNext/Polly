<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Circuit breaker resilience strategy | Polly </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Circuit breaker resilience strategy | Polly ">
      
      
      <link rel="icon" href="../icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/App-vNext/Polly/blob/main/docs/strategies/circuit-breaker.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../icon.png" alt="Polly">
            Polly
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="circuit-breaker-resilience-strategy">Circuit breaker resilience strategy</h1>

<h2 id="about">About</h2>
<ul>
<li><strong>Option(s)</strong>:
<ul>
<li><a class="xref" href="../api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions.html"><code>CircuitBreakerStrategyOptions</code></a></li>
<li><a class="xref" href="../api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions-1.html"><code>CircuitBreakerStrategyOptions&lt;T&gt;</code></a></li>
</ul>
</li>
<li><strong>Extension(s)</strong>:
<ul>
<li><code>AddCircuitBreaker</code></li>
</ul>
</li>
<li><strong>Strategy Type</strong>: Reactive</li>
<li><strong>Exception(s)</strong>:
<ul>
<li><a class="xref" href="../api/Polly.CircuitBreaker.BrokenCircuitException.html"><code>BrokenCircuitException</code></a>: Thrown when a circuit is broken and the action was not executed.</li>
<li><a class="xref" href="../api/Polly.CircuitBreaker.IsolatedCircuitException.html"><code>IsolatedCircuitException</code></a>: Thrown when a circuit is isolated (held open) by manual override.</li>
</ul>
</li>
</ul>
<hr>
<p>The circuit breaker <strong>reactive</strong> resilience strategy shortcuts the execution if the underlying resource is detected as unhealthy. The detection process is done via sampling. If the sampled executions' failure-success ratio exceeds a predefined threshold then a circuit breaker will prevent any new executions by throwing a <code>BrokenCircuitException</code>. After a preset duration the circuit breaker performs a probe, because the assumption is that this period was enough for the resource to self-heal. Depending on the outcome of the probe, the circuit will either allow new executions or continue to block them. If an execution is blocked by the circuit breaker, the thrown exception may indicate the amount of time executions will continue to be blocked through its <code>RetryAfter</code> property.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Be aware that the Circuit Breaker strategy <a href="https://github.com/App-vNext/Polly/wiki/Circuit-Breaker#exception-handling">rethrows all exceptions</a>, including those that are handled. A Circuit Breaker's role is to monitor faults and break the circuit when a certain threshold is reached; it does not manage retries. Combine the Circuit Breaker with a Retry strategy if needed.</p>
</div>
<h2 id="usage">Usage</h2>
<!-- snippet: circuit-breaker -->
<pre><code class="lang-cs">// Circuit breaker with default options.
// See https://www.pollydocs.org/strategies/circuit-breaker#defaults for defaults.
var optionsDefaults = new CircuitBreakerStrategyOptions();

// Circuit breaker with customized options:
// The circuit will break if more than 50% of actions result in handled exceptions,
// within any 10-second sampling duration, and at least 8 actions are processed.
var optionsComplex = new CircuitBreakerStrategyOptions
{
    FailureRatio = 0.5,
    SamplingDuration = TimeSpan.FromSeconds(10),
    MinimumThroughput = 8,
    BreakDuration = TimeSpan.FromSeconds(30),
    ShouldHandle = new PredicateBuilder().Handle&lt;SomeExceptionType&gt;()
};

// Circuit breaker using BreakDurationGenerator:
// The break duration is dynamically determined based on the properties of BreakDurationGeneratorArguments.
var optionsBreakDurationGenerator = new CircuitBreakerStrategyOptions
{
    FailureRatio = 0.5,
    SamplingDuration = TimeSpan.FromSeconds(10),
    MinimumThroughput = 8,
    BreakDurationGenerator = static args =&gt; new ValueTask&lt;TimeSpan&gt;(TimeSpan.FromMinutes(args.FailureCount)),
};

// Handle specific failed results for HttpResponseMessage:
var optionsShouldHandle = new CircuitBreakerStrategyOptions&lt;HttpResponseMessage&gt;
{
    ShouldHandle = new PredicateBuilder&lt;HttpResponseMessage&gt;()
        .Handle&lt;SomeExceptionType&gt;()
        .HandleResult(response =&gt; response.StatusCode == HttpStatusCode.InternalServerError)
};

// Monitor the circuit state, useful for health reporting:
var stateProvider = new CircuitBreakerStateProvider();
var optionsStateProvider = new CircuitBreakerStrategyOptions&lt;HttpResponseMessage&gt;
{
    StateProvider = stateProvider
};

var circuitState = stateProvider.CircuitState;

/*
CircuitState.Closed - Normal operation; actions are executed.
CircuitState.Open - Circuit is open; actions are blocked.
CircuitState.HalfOpen - Recovery state after break duration expires; actions are permitted.
CircuitState.Isolated - Circuit is manually held open; actions are blocked.
*/

// Manually control the Circuit Breaker state:
var manualControl = new CircuitBreakerManualControl();
var optionsManualControl = new CircuitBreakerStrategyOptions
{
    ManualControl = manualControl
};

// Manually isolate a circuit, e.g., to isolate a downstream service.
await manualControl.IsolateAsync();

// Manually close the circuit to allow actions to be executed again.
await manualControl.CloseAsync();

// Add a circuit breaker strategy with a CircuitBreakerStrategyOptions{&lt;TResult&gt;} instance to the pipeline
new ResiliencePipelineBuilder().AddCircuitBreaker(optionsDefaults);
new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;().AddCircuitBreaker(optionsStateProvider);
</code></pre>
<!-- endSnippet -->
<h3 id="failure-handling">Failure handling</h3>
<p>The circuit breaker returns the result / exception during the sampling period. Once the strategy opens the circuit, every subsequent call will be shortcut with a <code>BrokenCircuitException</code>.</p>
<!-- snippet: circuit-breaker-failure-handling -->
<pre><code class="lang-cs">var pipeline = new ResiliencePipelineBuilder()
    .AddCircuitBreaker(new CircuitBreakerStrategyOptions
    {
        FailureRatio = 0.1,
        SamplingDuration = TimeSpan.FromSeconds(1),
        MinimumThroughput = 3,
        BreakDuration = TimeSpan.FromSeconds(30),
        ShouldHandle = new PredicateBuilder().Handle&lt;SomeExceptionType&gt;()
    })
    .Build();

for (int i = 0; i &lt; 10; i++)
{
    try
    {
        pipeline.Execute(() =&gt; throw new SomeExceptionType());
    }
    catch (SomeExceptionType)
    {
        Console.WriteLine(&quot;Operation failed please try again.&quot;);
    }
    catch (BrokenCircuitException)
    {
        Console.WriteLine(&quot;Operation failed too many times please try again later.&quot;);
    }
}
</code></pre>
<!-- endSnippet -->
<p>The output would look like this:</p>
<pre><code class="lang-none">Operation failed please try again.
Operation failed please try again.
Operation failed please try again.
Operation failed too many times please try again later.
Operation failed too many times please try again later.
Operation failed too many times please try again later.
Operation failed too many times please try again later.
Operation failed too many times please try again later.
Operation failed too many times please try again later.
Operation failed too many times please try again later.
</code></pre>
<p>The <code>BrokenCircuitException</code> and the <code>IsolatedCircuitException</code> provide access to the following properties:</p>
<ul>
<li><code>RetryAfter</code>;</li>
<li><code>TelemetrySource</code>.</li>
</ul>
<p>If a <code>TimeSpan</code> value is provided to the optional <code>RetryAfter</code> property then this indicates that circuit is open for at least this time period and you should retry your operation no sooner than the value given.</p>
<p>The <code>TelemetrySource</code> property is a <a class="xref" href="../api/Polly.Telemetry.ResilienceTelemetrySource.html"><code>ResilienceTelemetrySource</code></a> which allows you retrieve information such as the executed pipeline and strategy. These can be useful if you have multiple circuit breaker strategies in your pipeline and you need to know which strategy caused the <code>BrokenCircuitException</code> to be thrown.</p>
<h2 id="defaults">Defaults</h2>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ShouldHandle</code></td>
<td>Any exceptions other than <code>OperationCanceledException</code>.</td>
<td>Defines a predicate to determine what results and/or exceptions are handled by the circuit breaker strategy.</td>
</tr>
<tr>
<td><code>FailureRatio</code></td>
<td>0.1</td>
<td>The failure-success ratio that will cause the circuit to break/open. <code>0.1</code> means 10% failed of all sampled executions.</td>
</tr>
<tr>
<td><code>MinimumThroughput</code></td>
<td>100</td>
<td>The minimum number of executions that must occur within the specified sampling duration.</td>
</tr>
<tr>
<td><code>SamplingDuration</code></td>
<td>30 seconds</td>
<td>The time period over which the failure-success ratio is calculated.</td>
</tr>
<tr>
<td><code>BreakDuration</code></td>
<td>5 seconds</td>
<td>Defines a <strong>fixed</strong> time period for which the circuit will remain broken/open before attempting to reset.</td>
</tr>
<tr>
<td><code>BreakDurationGenerator</code></td>
<td><code>null</code></td>
<td>This delegate allows you to <strong>dynamically</strong> calculate the break duration by utilizing information that is only available at runtime (like failure count).</td>
</tr>
<tr>
<td><code>ManualControl</code></td>
<td><code>null</code></td>
<td>If provided then the circuit's state can be manually controlled via a <code>CircuitBreakerManualControl</code> object.</td>
</tr>
<tr>
<td><code>StateProvider</code></td>
<td><code>null</code></td>
<td>If provided then the circuit's current state can be retrieved via a <code>CircuitBreakerStateProvider</code> object.</td>
</tr>
<tr>
<td><code>OnClosed</code></td>
<td><code>null</code></td>
<td>If provided then it will be invoked after the circuit transitions to either the <code>Closed</code> or <code>Isolated</code> states.</td>
</tr>
<tr>
<td><code>OnOpened</code></td>
<td><code>null</code></td>
<td>If provided then it will be invoked after the circuit transitions to the <code>Opened</code> state.</td>
</tr>
<tr>
<td><code>OnHalfOpened</code></td>
<td><code>null</code></td>
<td>If provided then it will be invoked after the circuit transitions to the <code>HalfOpened</code> state.</td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>If both <code>BreakDuration</code> and <code>BreakDurationGenerator</code> are specified then <code>BreakDuration</code> will be ignored.</p>
</div>
<hr>
<div class="IMPORTANT">
<h5>Important</h5>
<p>If the <code>MinimumThroughput</code> is not reached during the <code>SamplingDuration</code> then the <code>FailureRatio</code> is ignored.
In other words, the circuit will not break even if all of the executions failed when their quantity is below the minimum throughput.</p>
</div>
<h2 id="telemetry">Telemetry</h2>
<p>The circuit breaker strategy reports the following telemetry events:</p>
<table>
<thead>
<tr>
<th>Event Name</th>
<th>Event Severity</th>
<th>When?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OnCircuitClosed</code></td>
<td><code>Information</code></td>
<td>Just before the strategy calls the <code>OnClosed</code> delegate</td>
</tr>
<tr>
<td><code>OnCircuitOpened</code></td>
<td><code>Error</code></td>
<td>Just before the strategy calls the <code>OnOpened</code> delegate</td>
</tr>
<tr>
<td><code>OnCircuitHalfOpened</code></td>
<td><code>Warning</code></td>
<td>Just before the strategy calls the <code>OnHalfOpened</code> delegate</td>
</tr>
</tbody>
</table>
<p>Here are some sample events:</p>
<pre><code class="lang-none">Resilience event occurred. EventName: 'OnCircuitOpened', Source: 'MyPipeline/MyPipelineInstance/MyCircuitBreakerStrategy', Operation Key: 'MyCircuitedOperation', Result: 'Exception of type 'CustomException' was thrown.'
    CustomException: Exception of type 'CustomException' was thrown.
        at Program.&lt;&gt;c.&lt;&lt;Main&gt;b__0_1&gt;d.MoveNext()
        ...
        at Polly.ResiliencePipeline.&lt;&gt;c__8`1.&lt;&lt;ExecuteAsync&gt;b__8_0&gt;d.MoveNext() in /_/src/Polly.Core/ResiliencePipeline.AsyncT.cs:line 95

Resilience event occurred. EventName: 'OnCircuitHalfOpened', Source: 'MyPipeline/MyPipelineInstance/MyCircuitBreakerStrategy', Operation Key: 'MyCircuitedOperation', Result: ''

Resilience event occurred. EventName: 'OnCircuitClosed', Source: 'MyPipeline/MyPipelineInstance/MyCircuitBreakerStrategy', Operation Key: 'MyCircuitedOperation', Result: '42'
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Please note that the <code>OnCircuitXYZ</code> telemetry events will be reported <strong>only if</strong> the circuit breaker strategy transitions from one state into another.</p>
<p>Remember in case of <code>ManualControl</code> the <code>OnCircuitHalfOpened</code> telemetry event will not be emitted.</p>
<p>Also the <code>Result</code> will be <strong>always empty</strong> for the <code>OnCircuitHalfOpened</code> telemetry event.</p>
</div>
<p>For further information please check out the <a href="../advanced/telemetry.html">telemetry page</a>.</p>
<h2 id="diagrams">Diagrams</h2>
<h3 id="state-diagram">State diagram</h3>
<pre><code class="lang-mermaid">stateDiagram-v2
direction LR
    [*] --&gt; Closed
    Closed --&gt; Open: Exceeds threshold
    Open --&gt; HalfOpen: Elapses break duration
    HalfOpen --&gt; Closed: Passes the probe
    HalfOpen --&gt; Open: Fails the probe
</code></pre>
<p>Whenever someone says <em>the circuit breaks</em> that means the Circuit Breaker transitions from the <code>Closed</code> state to the <code>Open</code> state.</p>
<h3 id="simple">Simple</h3>
<p>Let's suppose we have a circuit breaker strategy wit the following configuration:</p>
<ul>
<li><code>SamplingDuration</code>: <code>2 seconds</code>;</li>
<li><code>MinimumThroughput</code>: <code>2</code>;</li>
<li><code>FailureRatio</code> : <code>0.5</code>.</li>
</ul>
<h4 id="simple-happy-path-sequence-diagram">Simple: happy path sequence diagram</h4>
<p>The circuit will not break because the actual failure ratio (0.33) will be below the threshold (0.5) after the 3rd call.</p>
<pre><code class="lang-mermaid">sequenceDiagram
    autonumber
    actor C as Caller
    participant P as Pipeline
    participant CB as CircuitBreaker
    participant D as DecoratedUserCallback

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    Note over CB: Closed state
    Note over CB, D: Sampling start
    activate CB
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Returns result
    CB-&gt;&gt;P: Returns result
    P-&gt;&gt;C: Returns result

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Returns result
    CB-&gt;&gt;P: Returns result
    P-&gt;&gt;C: Returns result

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Fails
    deactivate CB
    Note over CB, D: Sampling end
    CB-&gt;&gt;P: Propagates failure
    P-&gt;&gt;C: Propagates failure
</code></pre>
<h4 id="simple-unhappy-path-sequence-diagram">Simple: unhappy path sequence diagram</h4>
<p>The circuit will break because the actual failure ratio meets the threshold (0.5) after the 2nd call.</p>
<pre><code class="lang-mermaid">sequenceDiagram
    autonumber
    actor C as Caller
    participant P as Pipeline
    participant CB as CircuitBreaker
    participant D as DecoratedUserCallback

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    Note over CB: Closed state
    Note over CB, D: Sampling start
    activate CB
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Returns result
    CB-&gt;&gt;P: Returns result
    P-&gt;&gt;C: Returns result

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Fails
    Note over CB: Moves to Open state
    CB-&gt;&gt;P: Propagates failure
    P-&gt;&gt;C: Propagates failure

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB--&gt;&gt;CB: Rejects request
    CB-&gt;&gt;P: Throws &lt;br/&gt;BrokenCircuitException
    P-&gt;&gt;C: Propagates exception
    deactivate CB
    Note over CB, D: Sampling end
</code></pre>
<h3 id="complex">Complex</h3>
<p>Let's suppose we have a circuit breaker strategy with the following configuration:</p>
<ul>
<li><code>SamplingDuration</code>: <code>2 seconds</code>;</li>
<li><code>MinimumThroughput</code>: <code>2</code>;</li>
<li><code>FailureRatio</code>: <code>0.5</code>;</li>
<li><code>BreakDuration</code>:<code>1 second</code>.</li>
</ul>
<h4 id="complex-happy-path-sequence-diagram">Complex: happy path sequence diagram</h4>
<p>The circuit will break and later it will transition into the <code>HalfOpen</code> state. The probe will then succeed, so the circuit breaker will go back to the normal (<code>Closed</code>) state.</p>
<pre><code class="lang-mermaid">sequenceDiagram
    autonumber
    actor C as Caller
    participant P as Pipeline
    participant CB as CircuitBreaker
    participant D as DecoratedUserCallback

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    Note over CB: Closed state
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Fails
    CB-&gt;&gt;P: Propagates failure
    P-&gt;&gt;C: Propagates failure

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Fails
    Note over CB: Moves to Open state
    Note over CB: Break duration start
    CB-&gt;&gt;P: Propagates failure
    P-&gt;&gt;C: Propagates failure

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB--&gt;&gt;CB: Rejects request
    CB-&gt;&gt;P: Throws &lt;br/&gt;BrokenCircuitException
    P-&gt;&gt;C: Propagates exception

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    Note over CB: Break duration end
    Note over CB: Moves to HalfOpen state
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Returns result
    Note over CB: Moves to Closed state
    CB-&gt;&gt;P: Returns result
    P-&gt;&gt;C: Returns result
</code></pre>
<h4 id="complex-unhappy-path-sequence-diagram">Complex: unhappy path sequence diagram</h4>
<p>The circuit will break and later it will transition into the <code>HalfOpen</code> state. The probe will then fail, so the circuit breaker will become broken again (the <code>Open</code> state).</p>
<pre><code class="lang-mermaid">sequenceDiagram
    autonumber
    actor C as Caller
    participant P as Pipeline
    participant CB as CircuitBreaker
    participant D as DecoratedUserCallback

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    Note over CB: Closed state
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Fails
    CB-&gt;&gt;P: Propagates failure
    P-&gt;&gt;C: Propagates failure

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Fails
    Note over CB: Moves to Open state
    Note over CB: Break duration start
    CB-&gt;&gt;P: Propagates failure
    P-&gt;&gt;C: Propagates failure

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB--&gt;&gt;CB: Rejects request
    CB-&gt;&gt;P: Throws &lt;br/&gt;BrokenCircuitException
    P-&gt;&gt;C: Propagates exception

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    Note over CB: Break duration end
    Note over CB: Moves to HalfOpen state
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Fails
    Note over CB: Moves to Open state
    CB-&gt;&gt;P: Propagates failure
    P-&gt;&gt;C: Propagates failure
</code></pre>
<h4 id="complex-dynamic-break-duration-sequence-diagram">Complex: dynamic break duration sequence diagram</h4>
<p>This sequence diagram illustrates the behavior of a circuit breaker using a <code>BreakDurationGenerator</code>. The generator dynamically calculates the break duration based on specific criteria, such as the number of failures:</p>
<pre><code class="lang-mermaid">sequenceDiagram
    autonumber
    actor C as Caller
    participant P as Pipeline
    participant CB as CircuitBreaker
    participant BDG as BreakDurationGenerator
    participant D as DecoratedUserCallback

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    Note over CB: Closed state
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Fails
    Note over CB: Moves to Open state
    CB-&gt;&gt;+BDG: Calls Generator
    BDG-&gt;&gt;-CB: Returns calculated &lt;br/&gt; duration
    Note over CB: Break duration start
    CB-&gt;&gt;P: Propagates failure
    P-&gt;&gt;C: Propagates failure

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    CB--&gt;&gt;CB: Rejects request
    CB-&gt;&gt;P: Throws &lt;br/&gt;BrokenCircuitException
    P-&gt;&gt;C: Propagates exception

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;CB: Calls ExecuteCore
    Note over CB: Break duration end
    Note over CB: Moves to HalfOpen state
    CB-&gt;&gt;+D: Invokes
    D-&gt;&gt;-CB: Returns result
    Note over CB: Moves to Closed state
    CB-&gt;&gt;P: Returns result
    P-&gt;&gt;C: Returns result
</code></pre>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://techblog.netflix.com/2011/12/making-netflix-api-more-resilient.html">Making the Netflix API More Resilient</a></li>
<li><a href="https://martinfowler.com/bliki/CircuitBreaker.html">Circuit Breaker by Martin Fowler</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dn589784.aspx">Circuit Breaker Pattern by Microsoft</a></li>
<li><a href="https://web.archive.org/web/20160106203951/http://thatextramile.be/blog/2008/05/the-circuit-breaker">Original Circuit Breaking Article</a></li>
</ul>
<h2 id="anti-patterns">Anti-patterns</h2>
<p>Over the years, many developers have used Polly in various ways. Some of these
recurring patterns may not be ideal. The sections below highlight anti-patterns to avoid.</p>
<h3 id="using-different-sleep-duration-between-retry-attempts-based-on-circuit-breaker-state">Using different sleep duration between retry attempts based on Circuit Breaker state</h3>
<p>Imagine that we have an inner Circuit Breaker and an outer Retry strategies.</p>
<p>We would like to define the retry in a way that the sleep duration calculation is taking into account the Circuit Breaker's state.</p>
<p>❌ DON'T</p>
<p>Use a closure to branch based on circuit breaker state:</p>
<!-- snippet: circuit-breaker-anti-pattern-circuit-aware-retry -->
<pre><code class="lang-cs">var stateProvider = new CircuitBreakerStateProvider();
var circuitBreaker = new ResiliencePipelineBuilder()
    .AddCircuitBreaker(new()
    {
        ShouldHandle = new PredicateBuilder().Handle&lt;HttpRequestException&gt;(),
        BreakDuration = TimeSpan.FromSeconds(5),
        StateProvider = stateProvider
    })
    .Build();

var retry = new ResiliencePipelineBuilder()
    .AddRetry(new()
    {
        ShouldHandle = new PredicateBuilder()
            .Handle&lt;HttpRequestException&gt;()
            .Handle&lt;BrokenCircuitException&gt;(),
        DelayGenerator = args =&gt;
        {
            TimeSpan? delay = TimeSpan.FromSeconds(1);
            if (stateProvider.CircuitState == CircuitState.Open)
            {
                delay = TimeSpan.FromSeconds(5);
            }

            return ValueTask.FromResult(delay);
        }
    })
    .Build();
</code></pre>
<!-- endSnippet -->
<p><strong>Reasoning</strong>:</p>
<ul>
<li>By default, each strategy is independent and has no any reference to other strategies.</li>
<li>We use the (<code>stateProvider</code>) to access the Circuit Breaker's state. However, this approach is not optimal as the retry strategy's <code>DelayGenerator</code> varies based on state.</li>
<li>This solution is delicate because the break duration and the sleep duration aren't linked.</li>
<li>If a future code maintainer modifies the <code>circuitBreaker</code>'s <code>BreakDuration</code>, they might overlook adjusting the sleep duration.</li>
</ul>
<p>✅ DO</p>
<p>Use <code>Context</code> to pass information between strategies:</p>
<!-- snippet: circuit-breaker-pattern-circuit-aware-retry -->
<pre><code class="lang-cs">var circuitBreaker = new ResiliencePipelineBuilder()
    .AddCircuitBreaker(new()
    {
        ShouldHandle = new PredicateBuilder().Handle&lt;HttpRequestException&gt;(),
        BreakDuration = TimeSpan.FromSeconds(5),
        OnOpened = static args =&gt;
        {
            args.Context.Properties.Set(SleepDurationKey, args.BreakDuration);
            return ValueTask.CompletedTask;
        },
        OnClosed = args =&gt;
        {
            args.Context.Properties.Set(SleepDurationKey, null);
            return ValueTask.CompletedTask;
        }
    })
    .Build();

var retry = new ResiliencePipelineBuilder()
    .AddRetry(new()
    {
        ShouldHandle = new PredicateBuilder()
            .Handle&lt;HttpRequestException&gt;()
            .Handle&lt;BrokenCircuitException&gt;(),
        DelayGenerator = static args =&gt;
        {
            _ = args.Context.Properties.TryGetValue(SleepDurationKey, out var delay);
            delay ??= TimeSpan.FromSeconds(1);
            return ValueTask.FromResult(delay);
        }
    })
    .Build();
</code></pre>
<!-- endSnippet -->
<p><strong>Reasoning</strong>:</p>
<ul>
<li>Both strategies are less coupled in this approach since they rely on the context and the <code>sleepDurationKey</code> components.</li>
<li>The Circuit Breaker shares the <code>BreakDuration</code> through the context when it breaks. When it transitions back to Closed, the sharing is revoked.</li>
<li>The Retry strategy fetches the sleep duration dynamically without knowing any specific knowledge about the Circuit Breaker.</li>
<li>If adjustments are needed for the <code>BreakDuration</code>, they can be made in one place.</li>
</ul>
<h3 id="wrapping-each-endpoint-with-a-circuit-breaker">Wrapping each endpoint with a circuit breaker</h3>
<p>Imagine that you have to call N number of services via <code>HttpClient</code>s.
You want to decorate all downstream calls with the service-aware Circuit Breaker.</p>
<p>❌ DON'T</p>
<p>Use a collection of Circuit Breakers and explicitly call <code>ExecuteAsync()</code>:</p>
<!-- snippet: circuit-breaker-anti-pattern-cb-per-endpoint -->
<pre><code class="lang-cs">// Defined in a common place
var uriToCbMappings = new Dictionary&lt;Uri, ResiliencePipeline&gt;
{
    [new Uri(&quot;https://downstream1.com&quot;)] = GetCircuitBreaker(),
    // ...
    [new Uri(&quot;https://downstreamN.com&quot;)] = GetCircuitBreaker()
};

// Used in the downstream 1 client
var downstream1Uri = new Uri(&quot;https://downstream1.com&quot;);
await uriToCbMappings[downstream1Uri].ExecuteAsync(CallXYZOnDownstream1, CancellationToken.None);
</code></pre>
<!-- endSnippet -->
<p><strong>Reasoning</strong>:</p>
<ul>
<li>Whenever you use an <code>HttpClient</code>, you must have a reference to the <code>uriToCbMappings</code> dictionary.</li>
<li>It's your responsibility to decorate each network call with the corresponding circuit breaker.</li>
</ul>
<p>✅ DO</p>
<p>Use named <code>HttpClient</code>s and then call <code>AddResilienceHandler</code> extension that is included in the <a href="https://www.nuget.org/packages/Microsoft.Extensions.Http.Resilience"><code>Microsoft.Extensions.Http.Resilience</code></a> package.</p>
<!-- snippet: circuit-breaker-pattern-cb-per-endpoint -->
<pre><code class="lang-cs">services
  .AddHttpClient(&quot;my-client&quot;)
  .AddResilienceHandler(&quot;circuit-breaker&quot;, builder =&gt;
  {
      builder.AddCircuitBreaker(new());
  })
  .SelectPipelineByAuthority(); // This call ensures that circuit breaker is cached by each URL authority
</code></pre>
<!-- endSnippet -->
<p>And then use it:</p>
<!-- snippet: circuit-breaker-pattern-cb-per-endpoint-usage -->
<pre><code class="lang-cs">HttpClient client = httpClientFactory.CreateClient(&quot;my-client&quot;);

await client.GetAsync(new Uri(&quot;https://downstream1.com/some-path&quot;));
</code></pre>
<!-- endSnippet -->
<p><strong>Reasoning</strong>:</p>
<ul>
<li>The <code>HttpClient</code> integrates with Circuit Breaker during startup by using the <code>AddResilienceHandler</code> extension.</li>
<li>There's no need to call <code>ExecuteAsync()</code> directly. The <code>DelegatingHandler</code> handles it automatically.</li>
<li>By using the <code>SelectPipelineByAuthority</code> extension method, the resilience handler caches and assigns resilience pipeline to each authority (scheme + host + port) that is extracted from HTTP request message.</li>
</ul>
<h3 id="reducing-thrown-exceptions">Reducing thrown exceptions</h3>
<p>In case of Circuit Breaker when it is either in the <code>Open</code> or <code>Isolated</code> state new requests are rejected immediately.</p>
<p>That means the strategy will throw either a <code>BrokenCircuitException</code> or an <code>IsolatedCircuitException</code> respectively.</p>
<p>❌ DON'T</p>
<p>Use guard expression to call <code>Execute{Async}</code> only if the circuit is not broken:</p>
<!-- snippet: circuit-breaker-anti-pattern-reduce-thrown-exceptions -->
<pre><code class="lang-cs">var stateProvider = new CircuitBreakerStateProvider();
var circuitBreaker = new ResiliencePipelineBuilder()
    .AddCircuitBreaker(new()
    {
        ShouldHandle = new PredicateBuilder().Handle&lt;HttpRequestException&gt;(),
        BreakDuration = TimeSpan.FromSeconds(0.5),
        StateProvider = stateProvider
    })
    .Build();

if (stateProvider.CircuitState
    is not CircuitState.Open
    and not CircuitState.Isolated)
{
    var response = await circuitBreaker.ExecuteAsync(static async ct =&gt;
    {
        return await IssueRequest();
    }, CancellationToken.None);

    // Your code goes here to process response
}
</code></pre>
<!-- endSnippet -->
<p><strong>Reasoning</strong>:</p>
<ul>
<li>The problem with this approach is that the circuit breaker will never transition into the <code>HalfOpen</code> state.</li>
<li>The circuit breaker does not act as an active object. In other words the state transition does not happen automatically in the background.</li>
<li>The circuit transition into the <code>HalfOpen</code> state when the <code>Execute{Async}</code> method is called and the <code>BreakDuration</code> elapsed.</li>
</ul>
<p>✅ DO</p>
<p>Use <code>ExecuteOutcomeAsync</code> to avoid throwing exception:</p>
<!-- snippet: circuit-breaker-pattern-reduce-thrown-exceptions -->
<pre><code class="lang-cs">var context = ResilienceContextPool.Shared.Get();

var circuitBreaker = new ResiliencePipelineBuilder()
    .AddCircuitBreaker(new()
    {
        ShouldHandle = new PredicateBuilder().Handle&lt;HttpRequestException&gt;(),
        BreakDuration = TimeSpan.FromSeconds(0.5),
    })
    .Build();

Outcome&lt;HttpResponseMessage&gt; outcome =
    await circuitBreaker.ExecuteOutcomeAsync&lt;HttpResponseMessage, string&gt;(
        static async (ctx, state) =&gt;
        {
            try
            {
                var response = await IssueRequest();
                return Outcome.FromResult(response);
            }
            catch (Exception e)
            {
                return Outcome.FromException&lt;HttpResponseMessage&gt;(e);
            }
        },
        context,
        &quot;state&quot;);

ResilienceContextPool.Shared.Return(context);

if (outcome.Exception is BrokenCircuitException)
{
    // The execution was stopped by the circuit breaker
}
else
{
    HttpResponseMessage response = outcome.Result!;
    // Your code goes here to process the response
}
</code></pre>
<!-- endSnippet -->
<p><strong>Reasoning</strong>:</p>
<ul>
<li>The <code>ExecuteOutcomeAsync</code> is a low-allocation API which does not throw exceptions; rather it captures them inside an <code>Outcome</code> data structure.</li>
<li>Since you are calling one of the <code>Execute</code> methods, that's why the circuit breaker can transition into the <code>HalfOpen</code> state.</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/App-vNext/Polly/blob/main/docs/strategies/circuit-breaker.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
