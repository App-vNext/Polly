<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Reactive resilience strategy | Polly </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Reactive resilience strategy | Polly ">
      
      <link rel="icon" href="../icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/App-vNext/Polly/blob/main/docs/extensibility/reactive-strategy.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../icon.png" alt="Polly">
            Polly
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="reactive-resilience-strategy">Reactive resilience strategy</h1>

<p>This document describes how to set up a <strong>Result reporting resilience strategy</strong>. This strategy lets you listen for specific results and report them to other components. It serves as a good example of a reactive strategy because it deals with specific results.</p>
<h2 id="implementation">Implementation</h2>
<p>Reactive resilience strategies inherit from the <a class="xref" href="../api/Polly.ResilienceStrategy-1.html"><code>ResilienceStrategy&lt;T&gt;</code></a> base class. The implementation for this specific strategy:</p>
<!-- snippet: ext-reactive-strategy -->
<pre><code class="lang-cs">// Strategies should be internal and not exposed in the library's public API.
// Use extension methods and options to configure the strategy.
internal sealed class ResultReportingResilienceStrategy&lt;T&gt; : ResilienceStrategy&lt;T&gt;
{
    private readonly Func&lt;ResultReportingPredicateArguments&lt;T&gt;, ValueTask&lt;bool&gt;&gt; _shouldHandle;
    private readonly Func&lt;OnReportResultArguments&lt;T&gt;, ValueTask&gt; _onReportResult;
    private readonly ResilienceStrategyTelemetry _telemetry;

    public ResultReportingResilienceStrategy(
        Func&lt;ResultReportingPredicateArguments&lt;T&gt;, ValueTask&lt;bool&gt;&gt; shouldHandle,
        Func&lt;OnReportResultArguments&lt;T&gt;, ValueTask&gt; onReportResult,
        ResilienceStrategyTelemetry telemetry)
    {
        _shouldHandle = shouldHandle;
        _onReportResult = onReportResult;
        _telemetry = telemetry;
    }

    protected override async ValueTask&lt;Outcome&lt;T&gt;&gt; ExecuteCore&lt;TState&gt;(
        Func&lt;ResilienceContext, TState, ValueTask&lt;Outcome&lt;T&gt;&gt;&gt; callback,
        ResilienceContext context,
        TState state)
    {
        // Execute the given callback and adhere to the ContinueOnCapturedContext property value.
        Outcome&lt;T&gt; outcome = await callback(context, state).ConfigureAwait(context.ContinueOnCapturedContext);

        // Check if the outcome should be reported using the &quot;ShouldHandle&quot; predicate.
        if (await _shouldHandle(new ResultReportingPredicateArguments&lt;T&gt;(context, outcome)).ConfigureAwait(context.ContinueOnCapturedContext))
        {
            // Bundle information about the event into arguments.
            var args = new OnReportResultArguments&lt;T&gt;(context, outcome);

            // Report this as a resilience event with information severity level to the telemetry infrastructure.
            _telemetry.Report(
                new ResilienceEvent(ResilienceEventSeverity.Information, &quot;ResultReported&quot;),
                context,
                outcome,
                args);

            // Call the &quot;OnReportResult&quot; callback.
            await _onReportResult(args).ConfigureAwait(context.ContinueOnCapturedContext);
        }

        return outcome;
    }
}
</code></pre>
<!-- endSnippet -->
<p>Reactive strategies use the <code>ShouldHandle</code> predicate to decide whether to handle the outcome of a user callback. The convention is to name the predicate's arguments using the <code>{StrategyName}PredicateArguments</code> pattern and return a <code>ValueTask&lt;bool&gt;</code>. Here, we use <code>ResultReportingPredicateArguments&lt;TResult&gt;</code>:</p>
<!-- snippet: ext-reactive-predicate-args -->
<pre><code class="lang-cs">public readonly struct ResultReportingPredicateArguments&lt;TResult&gt;
{
    public ResultReportingPredicateArguments(ResilienceContext context, Outcome&lt;TResult&gt; outcome)
    {
        Context = context;
        Outcome = outcome;
    }

    // Always include the &quot;Context&quot; property in the arguments.
    public ResilienceContext Context { get; }

    // Always have the &quot;Outcome&quot; property in reactive arguments.
    public Outcome&lt;TResult&gt; Outcome { get; }
}
</code></pre>
<!-- endSnippet -->
<p>Reactive arguments should <strong>always</strong> contain the <code>Context</code> and <code>Outcome</code> properties.</p>
<p>Additionally, to report the outcome, the strategy uses <code>OnReportResultArguments&lt;TResult&gt;</code>:</p>
<!-- snippet: ext-reactive-event-args -->
<pre><code class="lang-cs">public readonly struct OnReportResultArguments&lt;TResult&gt;
{
    public OnReportResultArguments(ResilienceContext context, Outcome&lt;TResult&gt; outcome)
    {
        Context = context;
        Outcome = outcome;
    }

    // Always include the &quot;Context&quot; property in the arguments.
    public ResilienceContext Context { get; }

    // Always have the &quot;Outcome&quot; property in reactive arguments.
    public Outcome&lt;TResult&gt; Outcome { get; }
}
</code></pre>
<!-- endSnippet -->
<p>Using arguments in callbacks supports a more maintainable and extensible API.</p>
<h2 id="options">Options</h2>
<p>In the previous section, we implemented the <code>ResultReportingResilienceStrategy&lt;T&gt;</code>. Now, we need to integrate it with Polly and its public API.</p>
<p>Define the public <code>ResultReportingStrategyOptions&lt;TResult&gt;</code> class to configure our strategy:</p>
<!-- snippet: ext-reactive-options -->
<pre><code class="lang-cs">public class ResultReportingStrategyOptions&lt;TResult&gt; : ResilienceStrategyOptions
{
    public ResultReportingStrategyOptions()
    {
        // Assign a default name to the options for more detailed telemetry insights.
        Name = &quot;ResultReporting&quot;;
    }

    // Options for reactive strategies should always include a &quot;ShouldHandle&quot; delegate.
    // Set a sensible default when possible. Here, we handle all exceptions.
    public Func&lt;ResultReportingPredicateArguments&lt;TResult&gt;, ValueTask&lt;bool&gt;&gt; ShouldHandle { get; set; } = args =&gt;
    {
        return new ValueTask&lt;bool&gt;(args.Outcome.Exception is not null);
    };

    // This illustrates an event delegate. Note that the arguments struct carries the same name as the delegate but with an &quot;Arguments&quot; suffix.
    // The event follows the async convention and must be set by the user.
    //
    // The [Required] attribute enforces the consumer to specify this property, used when some properties do not have sensible defaults and are required.
    [Required]
    public Func&lt;OnReportResultArguments&lt;TResult&gt;, ValueTask&gt;? OnReportResult { get; set; }
}
</code></pre>
<!-- endSnippet -->
<p>If you want to support non-generic options for the <code>ResiliencePipelineBuilder</code>, you can expose them as well:</p>
<!-- snippet: ext-reactive-non-generic-options -->
<pre><code class="lang-cs">// Simply derive from the generic options, using 'object' as the result type.
// This allows the strategy to manage all results.
public class ResultReportingStrategyOptions : ResultReportingStrategyOptions&lt;object&gt;
{
}
</code></pre>
<!-- endSnippet -->
<p>Using options as a public contract helps us ensure flexibility with consumers. By adopting this method, you can introduce new members with ease without introducing breaking changes and maintain consistent validation.</p>
<h2 id="extensions">Extensions</h2>
<p>Up until now, we've discussed:</p>
<ul>
<li>The public <code>ResultReportingStrategyOptions&lt;TResult&gt;</code> and the related arguments.</li>
<li>The proactive strategy implementation called <code>ResultReportingResilienceStrategy&lt;TResult&gt;</code>.</li>
</ul>
<p>The next step is to combine these elements by introducing new extensions for <code>ResiliencePipelineBuilder&lt;T&gt;</code> and, optionally, <code>ResiliencePipelineBuilder</code>.</p>
<!-- snippet: ext-reactive-extensions -->
<pre><code class="lang-cs">public static class ResultReportingResilienceStrategyBuilderExtensions
{
    // Add extensions for the generic builder.
    // Extensions should return the builder to support a fluent API.
    public static ResiliencePipelineBuilder&lt;TResult&gt; AddResultReporting&lt;TResult&gt;(
        this ResiliencePipelineBuilder&lt;TResult&gt; builder,
        ResultReportingStrategyOptions&lt;TResult&gt; options)
    {
        // Add the strategy through the AddStrategy method. This method accepts a factory delegate
        // and automatically validates the options.
        return builder.AddStrategy(
            context =&gt;
            {
                // The &quot;context&quot; provides various properties for the strategy's use.
                // In this case, we simply use the &quot;Telemetry&quot; property and pass it to the strategy.
                // The ShouldHandle and OnReportResult values are sourced from the options.
                var strategy = new ResultReportingResilienceStrategy&lt;TResult&gt;(
                    options.ShouldHandle,
                    options.OnReportResult!,
                    context.Telemetry);

                return strategy;
            },
            options);
    }

    // Optionally, if suitable for the strategy, add support for non-generic builders.
    // Observe the use of the non-generic ResultReportingStrategyOptions.
    public static ResiliencePipelineBuilder AddResultReporting(
        this ResiliencePipelineBuilder builder,
        ResultReportingStrategyOptions options)
    {
        return builder.AddStrategy(
            context =&gt;
            {
                var strategy = new ResultReportingResilienceStrategy&lt;object&gt;(
                    options.ShouldHandle,
                    options.OnReportResult!,
                    context.Telemetry);

                return strategy;
            },
            options);
    }
}
</code></pre>
<!-- endSnippet -->
<h2 id="usage">Usage</h2>
<!-- snippet: ext-reactive-strategy-usage -->
<pre><code class="lang-cs">// Add reactive strategy to the builder
new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddResultReporting(new ResultReportingStrategyOptions&lt;HttpResponseMessage&gt;
    {
        // Define what outcomes to handle
        ShouldHandle = args =&gt; args.Outcome switch
        {
            { Exception: { } } =&gt; PredicateResult.True(),
            { Result.StatusCode: HttpStatusCode.InternalServerError } =&gt; PredicateResult.True(),
            _ =&gt; PredicateResult.False()
        },
        OnReportResult = args =&gt;
        {
            Console.WriteLine($&quot;Result: {args.Outcome}&quot;);
            return default;
        }
    });

// You can also use the non-generic ResiliencePipelineBuilder to handle any kind of result.
new ResiliencePipelineBuilder()
    .AddResultReporting(new ResultReportingStrategyOptions
    {
        // Define what outcomes to handle
        ShouldHandle = args =&gt; args.Outcome switch
        {
            { Exception: { } } =&gt; PredicateResult.True(),
            { Result: HttpResponseMessage message } when message.StatusCode == HttpStatusCode.InternalServerError =&gt; PredicateResult.True(),
            _ =&gt; PredicateResult.False()
        },
        OnReportResult = args =&gt;
        {
            Console.WriteLine($&quot;Result: {args.Outcome}&quot;);
            return default;
        }
    });
</code></pre>
<!-- endSnippet -->
<h2 id="resources">Resources</h2>
<p>For further information about reactive resilience strategies, consider exploring these resources:</p>
<ul>
<li><a href="https://github.com/App-vNext/Polly/tree/main/samples/Extensibility/Reactive">Result reporting strategy sample</a>: A practical example from this guide.</li>
<li><a href="https://github.com/App-vNext/Polly/tree/main/src/Polly.Core/Retry">Retry resilience strategy</a>: Discover the built-in retry resilience strategy implementation.</li>
<li><a href="https://github.com/App-vNext/Polly/tree/main/src/Polly.Core/Fallback">Fallback resilience strategy</a>: Discover the built-in fallback resilience strategy implementation.</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/App-vNext/Polly/blob/main/docs/extensibility/reactive-strategy.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
