{
  "version": 3,
  "sources": ["../../node_modules/mermaid/dist/chunks/mermaid.core/chunk-3JNJP5BE.mjs"],
  "sourcesContent": ["import {\n  __name\n} from \"./chunk-6DBFFHIP.mjs\";\n\n// src/utils/lineWithOffset.ts\nvar markerOffsets = {\n  aggregation: 18,\n  extension: 18,\n  composition: 18,\n  dependency: 6,\n  lollipop: 13.5,\n  arrow_point: 4\n};\nfunction calculateDeltaAndAngle(point1, point2) {\n  if (point1 === void 0 || point2 === void 0) {\n    return { angle: 0, deltaX: 0, deltaY: 0 };\n  }\n  point1 = pointTransformer(point1);\n  point2 = pointTransformer(point2);\n  const [x1, y1] = [point1.x, point1.y];\n  const [x2, y2] = [point2.x, point2.y];\n  const deltaX = x2 - x1;\n  const deltaY = y2 - y1;\n  return { angle: Math.atan(deltaY / deltaX), deltaX, deltaY };\n}\n__name(calculateDeltaAndAngle, \"calculateDeltaAndAngle\");\nvar pointTransformer = /* @__PURE__ */ __name((data) => {\n  if (Array.isArray(data)) {\n    return { x: data[0], y: data[1] };\n  }\n  return data;\n}, \"pointTransformer\");\nvar getLineFunctionsWithOffset = /* @__PURE__ */ __name((edge) => {\n  return {\n    x: /* @__PURE__ */ __name(function(d, i, data) {\n      let offset = 0;\n      const DIRECTION = pointTransformer(data[0]).x < pointTransformer(data[data.length - 1]).x ? \"left\" : \"right\";\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const { angle, deltaX } = calculateDeltaAndAngle(data[0], data[1]);\n        offset = markerOffsets[edge.arrowTypeStart] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const { angle, deltaX } = calculateDeltaAndAngle(\n          data[data.length - 1],\n          data[data.length - 2]\n        );\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);\n      }\n      const differenceToEnd = Math.abs(\n        pointTransformer(d).x - pointTransformer(data[data.length - 1]).x\n      );\n      const differenceInYEnd = Math.abs(\n        pointTransformer(d).y - pointTransformer(data[data.length - 1]).y\n      );\n      const differenceToStart = Math.abs(pointTransformer(d).x - pointTransformer(data[0]).x);\n      const differenceInYStart = Math.abs(pointTransformer(d).y - pointTransformer(data[0]).y);\n      const startMarkerHeight = markerOffsets[edge.arrowTypeStart];\n      const endMarkerHeight = markerOffsets[edge.arrowTypeEnd];\n      const extraRoom = 1;\n      if (differenceToEnd < endMarkerHeight && differenceToEnd > 0 && differenceInYEnd < endMarkerHeight) {\n        let adjustment = endMarkerHeight + extraRoom - differenceToEnd;\n        adjustment *= DIRECTION === \"right\" ? -1 : 1;\n        offset -= adjustment;\n      }\n      if (differenceToStart < startMarkerHeight && differenceToStart > 0 && differenceInYStart < startMarkerHeight) {\n        let adjustment = startMarkerHeight + extraRoom - differenceToStart;\n        adjustment *= DIRECTION === \"right\" ? -1 : 1;\n        offset += adjustment;\n      }\n      return pointTransformer(d).x + offset;\n    }, \"x\"),\n    y: /* @__PURE__ */ __name(function(d, i, data) {\n      let offset = 0;\n      const DIRECTION = pointTransformer(data[0]).y < pointTransformer(data[data.length - 1]).y ? \"down\" : \"up\";\n      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {\n        const { angle, deltaY } = calculateDeltaAndAngle(data[0], data[1]);\n        offset = markerOffsets[edge.arrowTypeStart] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\n      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {\n        const { angle, deltaY } = calculateDeltaAndAngle(\n          data[data.length - 1],\n          data[data.length - 2]\n        );\n        offset = markerOffsets[edge.arrowTypeEnd] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);\n      }\n      const differenceToEnd = Math.abs(\n        pointTransformer(d).y - pointTransformer(data[data.length - 1]).y\n      );\n      const differenceInXEnd = Math.abs(\n        pointTransformer(d).x - pointTransformer(data[data.length - 1]).x\n      );\n      const differenceToStart = Math.abs(pointTransformer(d).y - pointTransformer(data[0]).y);\n      const differenceInXStart = Math.abs(pointTransformer(d).x - pointTransformer(data[0]).x);\n      const startMarkerHeight = markerOffsets[edge.arrowTypeStart];\n      const endMarkerHeight = markerOffsets[edge.arrowTypeEnd];\n      const extraRoom = 1;\n      if (differenceToEnd < endMarkerHeight && differenceToEnd > 0 && differenceInXEnd < endMarkerHeight) {\n        let adjustment = endMarkerHeight + extraRoom - differenceToEnd;\n        adjustment *= DIRECTION === \"up\" ? -1 : 1;\n        offset -= adjustment;\n      }\n      if (differenceToStart < startMarkerHeight && differenceToStart > 0 && differenceInXStart < startMarkerHeight) {\n        let adjustment = startMarkerHeight + extraRoom - differenceToStart;\n        adjustment *= DIRECTION === \"up\" ? -1 : 1;\n        offset += adjustment;\n      }\n      return pointTransformer(d).y + offset;\n    }, \"y\")\n  };\n}, \"getLineFunctionsWithOffset\");\nif (void 0) {\n  const { it, expect, describe } = void 0;\n  describe(\"calculateDeltaAndAngle\", () => {\n    it(\"should calculate the angle and deltas between two points\", () => {\n      expect(calculateDeltaAndAngle([0, 0], [0, 1])).toStrictEqual({\n        angle: 1.5707963267948966,\n        deltaX: 0,\n        deltaY: 1\n      });\n      expect(calculateDeltaAndAngle([1, 0], [0, -1])).toStrictEqual({\n        angle: 0.7853981633974483,\n        deltaX: -1,\n        deltaY: -1\n      });\n      expect(calculateDeltaAndAngle({ x: 1, y: 0 }, [0, -1])).toStrictEqual({\n        angle: 0.7853981633974483,\n        deltaX: -1,\n        deltaY: -1\n      });\n      expect(calculateDeltaAndAngle({ x: 1, y: 0 }, { x: 1, y: 0 })).toStrictEqual({\n        angle: NaN,\n        deltaX: 0,\n        deltaY: 0\n      });\n    });\n    it(\"should calculate the angle and deltas if one point in undefined\", () => {\n      expect(calculateDeltaAndAngle(void 0, [0, 1])).toStrictEqual({\n        angle: 0,\n        deltaX: 0,\n        deltaY: 0\n      });\n      expect(calculateDeltaAndAngle([0, 1], void 0)).toStrictEqual({\n        angle: 0,\n        deltaX: 0,\n        deltaY: 0\n      });\n    });\n  });\n}\n\nexport {\n  getLineFunctionsWithOffset\n};\n"],
  "mappings": "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",
  "names": ["markerOffsets", "calculateDeltaAndAngle", "point1", "point2", "pointTransformer", "x1", "y1", "x2", "y2", "deltaX", "deltaY", "__name", "data", "getLineFunctionsWithOffset", "edge", "d", "i", "offset", "DIRECTION", "angle", "differenceToEnd", "differenceInYEnd", "differenceToStart", "differenceInYStart", "startMarkerHeight", "endMarkerHeight", "extraRoom", "adjustment", "differenceInXEnd", "differenceInXStart"]
}
