import{a as $,b as P,d as F,e as N,f as M,g as U,h as j,i as R,j as S,m as A,n as H,o as V,p as W}from"./chunk-A72RGWO6.min.js";import{b as G}from"./chunk-ICFROH4Y.min.js";import{a as k}from"./chunk-ULAEXCMJ.min.js";import{A as L,b as _,j as O,o as p}from"./chunk-GT3P3F7J.min.js";import{Ga as s,Ja as C,h as T,kb as B}from"./chunk-L5V3YLAC.min.js";function m(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:tt(e),edges:et(e)};return p(e.graph())||(t.value=_(e.graph())),t}function tt(e){return O(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),i={v:t};return p(n)||(i.value=n),p(r)||(i.parent=r),i})}function et(e){return O(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return p(t.name)||(r.name=t.name),p(n)||(r.value=n),r})}var l={},g={},q={},it=()=>{g={},q={},l={}},J=(e,t)=>(s.trace("In isDecendant",t," ",e," = ",g[t].includes(e)),!!g[t].includes(e)),st=(e,t)=>(s.info("Decendants of ",t," is ",g[t]),s.info("Edge is ",e),e.v===t||e.w===t?!1:g[t]?g[t].includes(e.v)||J(e.v,t)||J(e.w,t)||g[t].includes(e.w):(s.debug("Tilt, ",t,",not in decendants"),!1)),z=(e,t,n,r)=>{s.warn("Copying children of ",e,"root",r,"data",t.node(e),r);let i=t.children(e)||[];e!==r&&i.push(e),s.warn("Copying (nodes) clusterId",e,"nodes",i),i.forEach(a=>{if(t.children(a).length>0)z(a,t,n,r);else{let d=t.node(a);s.info("cp ",a," to ",r," with parent ",e),n.setNode(a,d),r!==t.parent(a)&&(s.warn("Setting parent",a,t.parent(a)),n.setParent(a,t.parent(a))),e!==r&&a!==e?(s.debug("Setting parent",a,e),n.setParent(a,e)):(s.info("In copy ",e,"root",r,"data",t.node(e),r),s.debug("Not Setting parent for node=",a,"cluster!==rootId",e!==r,"node!==clusterId",a!==e));let h=t.edges(a);s.debug("Copying Edges",h),h.forEach(f=>{s.info("Edge",f);let u=t.edge(f.v,f.w,f.name);s.info("Edge data",u,r);try{st(f,r)?(s.info("Copying as ",f.v,f.w,u,f.name),n.setEdge(f.v,f.w,u,f.name),s.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):s.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",r," clusterId:",e)}catch(w){s.error(w)}})}s.debug("Removing node",a),t.removeNode(a)})},K=(e,t)=>{let n=t.children(e),r=[...n];for(let i of n)q[i]=e,r=[...r,...K(i,t)];return r},X=(e,t)=>{s.trace("Searching",e);let n=t.children(e);if(s.trace("Searching children of id ",e,n),n.length<1)return s.trace("This is a valid node",e),e;for(let r of n){let i=X(r,t);if(i)return s.trace("Found replacement for",e," => ",i),i}},D=e=>!l[e]||!l[e].externalConnections?e:l[e]?l[e].id:e,rt=(e,t)=>{if(!e||t>10){s.debug("Opting out, no graph ");return}else s.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(s.warn("Cluster identified",n," Replacement id in edges: ",X(n,e)),g[n]=K(n,e),l[n]={id:X(n,e),clusterData:e.node(n)})}),e.nodes().forEach(function(n){let r=e.children(n),i=e.edges();r.length>0?(s.debug("Cluster identified",n,g),i.forEach(a=>{if(a.v!==n&&a.w!==n){let d=J(a.v,n),h=J(a.w,n);d^h&&(s.warn("Edge: ",a," leaves cluster ",n),s.warn("Decendants of XXX ",n,": ",g[n]),l[n].externalConnections=!0)}})):s.debug("Not a cluster ",n,g)});for(let n of Object.keys(l)){let r=l[n].id,i=e.parent(r);i!==n&&l[i]&&!l[i].externalConnections&&(l[n].id=i)}e.edges().forEach(function(n){let r=e.edge(n);s.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),s.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let i=n.v,a=n.w;if(s.warn("Fix XXX",l,"ids:",n.v,n.w,"Translating: ",l[n.v]," --- ",l[n.w]),l[n.v]&&l[n.w]&&l[n.v]===l[n.w]){s.warn("Fixing and trixing link to self - removing XXX",n.v,n.w,n.name),s.warn("Fixing and trixing - removing XXX",n.v,n.w,n.name),i=D(n.v),a=D(n.w),e.removeEdge(n.v,n.w,n.name);let d=n.w+"---"+n.v;e.setNode(d,{domId:d,id:d,labelStyle:"",labelText:r.label,padding:0,shape:"labelRect",style:""});let h=structuredClone(r),f=structuredClone(r);h.label="",h.arrowTypeEnd="none",f.label="",h.fromCluster=n.v,f.toCluster=n.v,e.setEdge(i,d,h,n.name+"-cyclic-special"),e.setEdge(d,a,f,n.name+"-cyclic-special")}else if(l[n.v]||l[n.w]){if(s.warn("Fixing and trixing - removing XXX",n.v,n.w,n.name),i=D(n.v),a=D(n.w),e.removeEdge(n.v,n.w,n.name),i!==n.v){let d=e.parent(i);l[d].externalConnections=!0,r.fromCluster=n.v}if(a!==n.w){let d=e.parent(a);l[d].externalConnections=!0,r.toCluster=n.w}s.warn("Fix Replacing with XXX",i,a,n.name),e.setEdge(i,a,r,n.name)}}),s.warn("Adjusted Graph",m(e)),Q(e,0),s.trace(l)},Q=(e,t)=>{if(s.warn("extractor - ",t,m(e),e.children("D")),t>10){s.error("Bailing out");return}let n=e.nodes(),r=!1;for(let i of n){let a=e.children(i);r=r||a.length>0}if(!r){s.debug("Done, no node has children",e.nodes());return}s.debug("Nodes = ",n,t);for(let i of n)if(s.debug("Extracting node",i,l,l[i]&&!l[i].externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",t),!l[i])s.debug("Not a cluster",i,t);else if(!l[i].externalConnections&&e.children(i)&&e.children(i).length>0){s.warn("Cluster without external connections, without a parent and with children",i,t);let d=e.graph().rankdir==="TB"?"LR":"TB";l[i]&&l[i].clusterData&&l[i].clusterData.dir&&(d=l[i].clusterData.dir,s.warn("Fixing dir",l[i].clusterData.dir,d));let h=new L({multigraph:!0,compound:!0}).setGraph({rankdir:d,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.warn("Old graph before copy",m(e)),z(i,e,h,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:l[i].clusterData,labelText:l[i].labelText,graph:h}),s.warn("New graph after copy node: (",i,")",m(h)),s.debug("Old graph after copy",m(e))}else s.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!l[i].externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),t),s.debug(l);n=e.nodes(),s.warn("New list of nodes",n);for(let i of n){let a=e.node(i);s.warn(" Now next level",i,a),a.clusterNode&&Q(a.graph,t+1)}},Y=(e,t)=>{if(t.length===0)return[];let n=Object.assign(t);return t.forEach(r=>{let i=e.children(r),a=Y(e,i);n=[...n,...a]}),n},at=e=>Y(e,e.children()),ct=(e,t)=>{s.info("Creating subgraph rect for ",t.id,t);let n=B(),r=e.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),i=r.insert("rect",":first-child"),a=C(n.flowchart.htmlLabels),d=r.insert("g").attr("class","cluster-label"),h=t.labelType==="markdown"?G(d,t.labelText,{style:t.labelStyle,useHtmlLabels:a}):d.node().appendChild(P(t.labelText,t.labelStyle,void 0,!0)),f=h.getBBox();if(C(n.flowchart.htmlLabels)){let c=h.children[0],o=T(h);f=c.getBoundingClientRect(),o.attr("width",f.width),o.attr("height",f.height)}let u=0*t.padding,w=u/2,b=t.width<=f.width+u?f.width+u:t.width;t.width<=f.width+u?t.diff=(f.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,s.trace("Data ",t,JSON.stringify(t)),i.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-b/2).attr("y",t.y-t.height/2-w).attr("width",b).attr("height",t.height+u);let{subGraphTitleTopMargin:y}=S(n);a?d.attr("transform",`translate(${t.x-f.width/2}, ${t.y-t.height/2+y})`):d.attr("transform",`translate(${t.x}, ${t.y-t.height/2+y})`);let v=i.node().getBBox();return t.width=v.width,t.height=v.height,t.intersect=function(c){return N(t,c)},r},ot=(e,t)=>{let n=e.insert("g").attr("class","note-cluster").attr("id",t.id),r=n.insert("rect",":first-child"),i=0*t.padding,a=i/2;r.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2-a).attr("width",t.width+i).attr("height",t.height+i).attr("fill","none");let d=r.node().getBBox();return t.width=d.width,t.height=d.height,t.intersect=function(h){return N(t,h)},n},lt=(e,t)=>{let n=B(),r=e.insert("g").attr("class",t.classes).attr("id",t.id),i=r.insert("rect",":first-child"),a=r.insert("g").attr("class","cluster-label"),d=r.append("rect"),h=a.node().appendChild(P(t.labelText,t.labelStyle,void 0,!0)),f=h.getBBox();if(C(n.flowchart.htmlLabels)){let c=h.children[0],o=T(h);f=c.getBoundingClientRect(),o.attr("width",f.width),o.attr("height",f.height)}f=h.getBBox();let u=0*t.padding,w=u/2,b=t.width<=f.width+t.padding?f.width+t.padding:t.width;t.width<=f.width+t.padding?t.diff=(f.width+t.padding*0-t.width)/2:t.diff=-t.padding/2,i.attr("class","outer").attr("x",t.x-b/2-w).attr("y",t.y-t.height/2-w).attr("width",b+u).attr("height",t.height+u),d.attr("class","inner").attr("x",t.x-b/2-w).attr("y",t.y-t.height/2-w+f.height-1).attr("width",b+u).attr("height",t.height+u-f.height-3);let{subGraphTitleTopMargin:y}=S(n);a.attr("transform",`translate(${t.x-f.width/2}, ${t.y-t.height/2-t.padding/3+(C(n.flowchart.htmlLabels)?5:3)+y})`);let v=i.node().getBBox();return t.height=v.height,t.intersect=function(c){return N(t,c)},r},ft=(e,t)=>{let n=e.insert("g").attr("class",t.classes).attr("id",t.id),r=n.insert("rect",":first-child"),i=0*t.padding,a=i/2;r.attr("class","divider").attr("x",t.x-t.width/2-a).attr("y",t.y-t.height/2).attr("width",t.width+i).attr("height",t.height+i);let d=r.node().getBBox();return t.width=d.width,t.height=d.height,t.diff=-t.padding/2,t.intersect=function(h){return N(t,h)},n},dt={rect:ct,roundedWithTitle:lt,noteGroup:ot,divider:ft},Z={},ht=(e,t)=>{s.trace("Inserting cluster");let n=t.shape||"rect";Z[t.id]=dt[n](e,t)},ut=()=>{Z={}},I=async(e,t,n,r,i,a)=>{s.info("Graph in recursive render: XXX",m(t),i);let d=t.graph().rankdir;s.trace("Dir in recursive render - dir:",d);let h=e.insert("g").attr("class","root");t.nodes()?s.info("Recursive render XXX",t.nodes()):s.info("No nodes found for",t),t.edges().length>0&&s.trace("Recursive edges",t.edge(t.edges()[0]));let f=h.insert("g").attr("class","clusters"),u=h.insert("g").attr("class","edgePaths"),w=h.insert("g").attr("class","edgeLabels"),b=h.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(c){let o=t.node(c);if(i!==void 0){let x=JSON.parse(JSON.stringify(i.clusterData));s.info("Setting data for cluster XXX (",c,") ",x,i),t.setNode(i.id,x),t.parent(c)||(s.trace("Setting parent",c,i.id),t.setParent(c,i.id,x))}if(s.info("(Insert) Node XXX"+c+": "+JSON.stringify(t.node(c))),o&&o.clusterNode){s.info("Cluster identified",c,o.width,t.node(c));let x=await I(b,o.graph,n,r,t.node(c),a),E=x.elem;F(o,E),o.diff=x.diff||0,s.info("Node bounds (abc123)",c,o,o.width,o.x,o.y),U(E,o),s.warn("Recursive render complete ",E,o)}else t.children(c).length>0?(s.info("Cluster - the non recursive path XXX",c,o.id,o,t),s.info(X(o.id,t)),l[o.id]={id:X(o.id,t),node:o}):(s.info("Node - the non recursive path",c,o.id,o),await M(b,t.node(c),d))})),t.edges().forEach(function(c){let o=t.edge(c.v,c.w,c.name);s.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c)),s.info("Edge "+c.v+" -> "+c.w+": ",c," ",JSON.stringify(t.edge(c))),s.info("Fix",l,"ids:",c.v,c.w,"Translateing: ",l[c.v],l[c.w]),H(w,o)}),t.edges().forEach(function(c){s.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(c))}),s.info("#############################################"),s.info("###                Layout                 ###"),s.info("#############################################"),s.info(t),k(t),s.info("Graph after layout:",m(t));let y=0,{subGraphTitleTotalMargin:v}=S(a);return at(t).forEach(function(c){let o=t.node(c);s.info("Position "+c+": "+JSON.stringify(t.node(c))),s.info("Position "+c+": ("+o.x,","+o.y,") width: ",o.width," height: ",o.height),o&&o.clusterNode?(o.y+=v,R(o)):t.children(c).length>0?(o.height+=v,ht(f,o),l[o.id].node=o):(o.y+=v/2,R(o))}),t.edges().forEach(function(c){let o=t.edge(c);s.info("Edge "+c.v+" -> "+c.w+": "+JSON.stringify(o),o),o.points.forEach(E=>E.y+=v/2);let x=W(u,c,o,l,n,t,r);V(o,x)}),t.nodes().forEach(function(c){let o=t.node(c);s.info(c,o.type,o.diff),o.type==="group"&&(y=o.diff)}),{elem:h,diff:y}},Nt=async(e,t,n,r,i)=>{$(e,n,r,i),j(),A(),ut(),it(),s.warn("Graph at first:",JSON.stringify(m(t))),rt(t),s.warn("Graph after:",JSON.stringify(m(t)));let a=B();await I(e,t,r,i,void 0,a)};export{Nt as a};
//# sourceMappingURL=chunk-OTWBH354.min.js.map
