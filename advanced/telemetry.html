<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Telemetry </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Telemetry ">
      
      <link rel="icon" href="../icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/App-vNext/Polly/blob/main/docs/advanced/telemetry.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module">
    import options from './../public/main.js'
    import { init } from './../public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../icon.png" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="telemetry">Telemetry</h1>

<p>Starting with version 8, Polly provides telemetry for all built-in resilience strategies.</p>
<h2 id="usage">Usage</h2>
<p>To enable telemetry in Polly, add the <code>Polly.Extensions</code> package to your project:</p>
<pre><code class="lang-sh">dotnet add package Polly.Extensions
</code></pre>
<p>Afterwards, you can use the <code>ConfigureTelemetry(...)</code> extension method on the <code>ResiliencePipelineBuilder</code>:</p>
<!-- snippet: configure-telemetry -->
<pre><code class="lang-cs">var telemetryOptions = new TelemetryOptions
{
    // Configure logging
    LoggerFactory = LoggerFactory.Create(builder =&gt; builder.AddConsole())
};

// Configure enrichers
telemetryOptions.MeteringEnrichers.Add(new MyMeteringEnricher());

// Configure telemetry listeners
telemetryOptions.TelemetryListeners.Add(new MyTelemetryListener());

var builder = new ResiliencePipelineBuilder()
    .AddTimeout(TimeSpan.FromSeconds(1))
    .ConfigureTelemetry(telemetryOptions) // This method enables telemetry in the builder
    .Build();
</code></pre>
<!-- endSnippet -->
<p>The <code>MyTelemetryListener</code> and <code>MyMeteringEnricher</code> is implemented as:</p>
<!-- snippet: telemetry-listeners -->
<pre><code class="lang-cs">internal class MyTelemetryListener : TelemetryListener
{
    public override void Write&lt;TResult, TArgs&gt;(in TelemetryEventArguments&lt;TResult, TArgs&gt; args)
    {
        Console.WriteLine($&quot;Telemetry event occurred: {args.Event.EventName}&quot;);
    }
}

internal class MyMeteringEnricher : MeteringEnricher
{
    public override void Enrich&lt;TResult, TArgs&gt;(in EnrichmentContext&lt;TResult, TArgs&gt; context)
    {
        context.Tags.Add(new(&quot;my-custom-tag&quot;, &quot;custom-value&quot;));
    }
}
</code></pre>
<!-- endSnippet -->
<p>Alternatively, you can use the <code>AddResiliencePipeline(...)</code> extension method which automatically enables telemetry for defined pipeline:</p>
<!-- snippet: add-resilience-pipeline-with-telemetry -->
<pre><code class="lang-cs">var serviceCollection = new ServiceCollection()
    .AddLogging(builder =&gt; builder.AddConsole())
    .AddResiliencePipeline(&quot;my-strategy&quot;, builder =&gt; builder.AddTimeout(TimeSpan.FromSeconds(1)))
    .Configure&lt;TelemetryOptions&gt;(options =&gt;
    {
        // Configure enrichers
        options.MeteringEnrichers.Add(new MyMeteringEnricher());

        // Configure telemetry listeners
        options.TelemetryListeners.Add(new MyTelemetryListener());
    });
</code></pre>
<!-- endSnippet -->
<h2 id="metrics">Metrics</h2>
<p>The metrics are emitted under the <code>Polly</code> meter name. The subsequent sections provide insights into the metrics produced by Polly. Please note that any custom enriched tags are not depicted in the following tables.</p>
<p>Every telemetry event has the following tags:</p>
<ul>
<li><code>pipeline.name</code>: Optional, comes from <code>ResiliencePipelineBuilder.Name</code>.</li>
<li><code>pipeline.instance</code>: Optional, comes from <code>ResiliencePipelineBuilder.InstanceName</code>.</li>
<li><code>strategy.name</code>: Optional, comes from <code>RetryStrategyOptions.Name</code>.</li>
</ul>
<p>The sample below demonstrates how to assign these tags:</p>
<!-- snippet: telemetry-coordinates -->
<pre><code class="lang-cs">var builder = new ResiliencePipelineBuilder();
builder.Name = &quot;my-name&quot;;
builder.Name = &quot;my-instance-name&quot;;

builder.AddRetry(new RetryStrategyOptions
{
    // The default value is &quot;Retry&quot;
    Name = &quot;my-retry-name&quot;
});
</code></pre>
<!-- endSnippet -->
<p>These values are subsequently reflected in the following metering instruments exposed by Polly:</p>
<h3 id="instrument-resiliencepollystrategyevents">Instrument: <code>resilience.polly.strategy.events</code></h3>
<ul>
<li>Type: <em>Counter</em></li>
<li>Description: Emitted upon the occurrence of a resilience event.</li>
</ul>
<p>Tags:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>event.name</code></td>
<td>The name of the emitted event.</td>
</tr>
<tr>
<td><code>event.severity</code></td>
<td>The severity of the event (<code>Debug</code>, <code>Information</code>, <code>Warning</code>, <code>Error</code>, <code>Critical</code>).</td>
</tr>
<tr>
<td><code>pipeline.name</code></td>
<td>The name of the pipeline corresponding to the resilience pipeline.</td>
</tr>
<tr>
<td><code>pipeline.instance</code></td>
<td>The instance name of the pipeline corresponding to the resilience pipeline.</td>
</tr>
<tr>
<td><code>strategy.name</code></td>
<td>The name of the strategy generating this event.</td>
</tr>
<tr>
<td><code>operation.key</code></td>
<td>The operation key associated with the call site.</td>
</tr>
<tr>
<td><code>exception.type</code></td>
<td>The full name of the exception assigned to the execution result (<code>System.InvalidOperationException</code>).</td>
</tr>
</tbody>
</table>
<h3 id="instrument-resiliencepollystrategyattemptduration">Instrument: <code>resilience.polly.strategy.attempt.duration</code></h3>
<ul>
<li>Type: <em>Histogram</em></li>
<li>Unit: <em>milliseconds</em></li>
<li>Description: Tracks the duration of execution attempts, produced by <code>Retry</code> and <code>Hedging</code> resilience strategies.</li>
</ul>
<p>Tags:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>event.name</code></td>
<td>The name of the emitted event.</td>
</tr>
<tr>
<td><code>event.severity</code></td>
<td>The severity of the event (<code>Debug</code>, <code>Information</code>, <code>Warning</code>, <code>Error</code>, <code>Critical</code>).</td>
</tr>
<tr>
<td><code>pipeline.name</code></td>
<td>The name of the pipeline corresponding to the resilience pipeline.</td>
</tr>
<tr>
<td><code>pipeline.instance</code></td>
<td>The instance name of the pipeline corresponding to the resilience pipeline.</td>
</tr>
<tr>
<td><code>strategy.name</code></td>
<td>The name of the strategy generating this event.</td>
</tr>
<tr>
<td><code>operation.key</code></td>
<td>The operation key associated with the call site.</td>
</tr>
<tr>
<td><code>exception.type</code></td>
<td>The full name of the exception assigned to the execution result (<code>System.InvalidOperationException</code>).</td>
</tr>
<tr>
<td><code>attempt.number</code></td>
<td>The execution attempt number, starting at 0 (0, 1, 2, etc.).</td>
</tr>
<tr>
<td><code>attempt.handled</code></td>
<td>Indicates if the execution outcome was handled. A handled outcome indicates execution failure and the need for retry (<code>true</code>, <code>false</code>).</td>
</tr>
</tbody>
</table>
<h3 id="instrument-resiliencepollypipelineduration">Instrument: <code>resilience.polly.pipeline.duration</code></h3>
<ul>
<li>Type: <em>Histogram</em></li>
<li>Unit: <em>milliseconds</em></li>
<li>Description: Measures the duration of resilience pipelines.</li>
</ul>
<p>Tags:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>pipeline.name</code></td>
<td>The name of the pipeline corresponding to the resilience pipeline.</td>
</tr>
<tr>
<td><code>pipeline.instance</code></td>
<td>The instance name of the pipeline corresponding to the resilience pipeline.</td>
</tr>
<tr>
<td><code>operation.key</code></td>
<td>The operation key associated with the call site.</td>
</tr>
<tr>
<td><code>exception.type</code></td>
<td>The full name of the exception assigned to the execution result (<code>System.InvalidOperationException</code>).</td>
</tr>
</tbody>
</table>
<h2 id="logs">Logs</h2>
<p>Logs are registered under the <code>Polly</code> logger name. Here are some examples of the logs:</p>
<pre><code class="lang-text">// This log is recorded whenever a resilience event occurs. EventId = 0
Resilience event occurred. EventName: '{EventName}', Source: '{PipelineName}/{PipelineInstance}/{StrategyName}', Operation Key: '{OperationKey}', Result: '{Result}'

// This log is recorded when a resilience pipeline begins executing. EventId = 1
Resilience pipeline executing. Source: '{PipelineName}/{PipelineInstance}', Operation Key: '{OperationKey}'

// This log is recorded when a resilience pipeline finishes execution. EventId = 2
Resilience pipeline executed. Source: '{PipelineName}/{PipelineInstance}', Operation Key: '{OperationKey}', Result: '{Result}', Execution Health: '{ExecutionHealth}', Execution Time: {ExecutionTime}ms

// This log is recorded upon the completion of every execution attempt. EventId = 3
Execution attempt. Source: '{PipelineName}/{PipelineInstance}/{StrategyName}', Operation Key: '{OperationKey}', Result: '{Result}', Handled: '{Handled}', Attempt: '{Attempt}', Execution Time: '{ExecutionTimeMs}'
</code></pre>
<h2 id="emitting-telemetry-events">Emitting telemetry events</h2>
<p>Each resilience strategy can generate telemetry data through the <a class="xref" href="../api/Polly.Telemetry.ResilienceStrategyTelemetry.html"><code>ResilienceStrategyTelemetry</code></a> API. Polly encapsulates event details as <a class="xref" href="../api/Polly.Telemetry.TelemetryEventArguments-2.html"><code>TelemetryEventArguments</code></a> and emits them via <code>TelemetryListener</code>.</p>
<p>To leverage this telemetry data, users should assign a <code>TelemetryListener</code> instance to <code>ResiliencePipelineBuilder.TelemetryListener</code> and then consume the <code>TelemetryEventArguments</code>.</p>
<p>For common scenarios, it is expected that users would make use of <code>Polly.Extensions</code>. This extension enables telemetry configuration through the <code>ResiliencePipelineBuilder.ConfigureTelemetry(...)</code> method, which processes <code>TelemetryEventArguments</code> to generate logs and metrics.</p>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/App-vNext/Polly/blob/main/docs/advanced/telemetry.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>
        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>