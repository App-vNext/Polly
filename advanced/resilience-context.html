<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Resilience context | Polly </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Resilience context | Polly ">
      
      
      <link rel="icon" href="../icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/App-vNext/Polly/blob/main/docs/advanced/resilience-context.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../icon.png" alt="Polly">
            Polly
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="resilience-context">Resilience context</h1>

<p>The <code>ResilienceContext</code> class in Polly provides an execution-scoped instance that accompanies each execution through a Polly resilience pipeline and across all strategies in the pipeline. This class serves to share context and facilitate information exchange between the pre-execution, mid-execution, and post-execution phases.</p>
<p>The resilience context exposes several properties:</p>
<ul>
<li><code>OperationKey</code>: A user-defined identifier for the operation.</li>
<li><code>CancellationToken</code>: The cancellation token linked to the operation.</li>
<li><code>Properties</code>: An instance of <code>ResilienceProperties</code> for attaching custom data to the context.</li>
<li><code>ContinueOnCapturedContext</code>: Specifies whether the asynchronous execution should continue on the captured context.</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Below is an example demonstrating how to work with <code>ResilienceContext</code>:</p>
<!-- snippet: resilience-context -->
<pre><code class="lang-cs">// Retrieve a context with a cancellation token
ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken);

// Attach custom data to the context
context.Properties.Set(MyResilienceKeys.Key1, &quot;my-data&quot;);
context.Properties.Set(MyResilienceKeys.Key2, 123);

// Utilize the context in a resilience pipeline
ResiliencePipeline pipeline = new ResiliencePipelineBuilder()
    .AddRetry(new()
    {
        OnRetry = static args =&gt;
        {
            // Retrieve custom data from the context, if available
            if (args.Context.Properties.TryGetValue(MyResilienceKeys.Key1, out var data))
            {
                Console.WriteLine(&quot;OnRetry, Custom Data: {0}&quot;, data);
            }

            return default;
        }
    })
    .Build();

// Execute the resilience pipeline asynchronously
await pipeline.ExecuteAsync(
    static async context =&gt;
    {
        // Insert your execution logic here
    },
    context);

// Return the context to the pool
ResilienceContextPool.Shared.Return(context);
</code></pre>
<!-- endSnippet -->
<p>Where <code>ResilienceKeys</code> is defined as:</p>
<!-- snippet: resilience-keys -->
<pre><code class="lang-cs">public static class MyResilienceKeys
{
    public static readonly ResiliencePropertyKey&lt;string&gt; Key1 = new(&quot;my-key-1&quot;);

    public static readonly ResiliencePropertyKey&lt;int&gt; Key2 = new(&quot;my-key-2&quot;);
}
</code></pre>
<!-- endSnippet -->
<div class="NOTE">
<h5>Note</h5>
<p>We recommend defining a static class to hold the resilience property keys used in your project. This approach makes these keys easier to discover and maintain. For simpler scenarios, you can directly use the creation of <code>ResiliencePropertyKey&lt;string&gt;</code> since it's a cheap, struct-based API.</p>
</div>
<h3 id="sequence-diagram">Sequence diagram</h3>
<pre><code class="lang-mermaid">sequenceDiagram
    autonumber
    actor C as Caller
    participant CP as ResilienceContextPool
    participant P as Pipeline
    participant R as Retry
    participant D as DecoratedUserCallback
    participant O as OnRetryUserCallback

    C-&gt;&gt;CP: Rents a context
    CP-&gt;&gt;C: Gives a context
    C-&gt;&gt;P: Calls ExecuteAsync&lt;br/&gt;with context
    P-&gt;&gt;R: Calls ExecuteCore&lt;br/&gt;with context
    Note over R,D: Initial attempt
    R-&gt;&gt;+D: Invokes&lt;br/&gt;with context
    D-&gt;&gt;-R: Fails
    R-&gt;&gt;+O: Invokes&lt;br/&gt;with context
    O-&gt;&gt;-R: Completes
    R--&gt;&gt;R: Sleeps
    Note over R,D: 1st retry attempt
    R-&gt;&gt;+D: Invokes&lt;br/&gt;with context
    D-&gt;&gt;-R: Returns result
    R-&gt;&gt;P: Returns result
    P-&gt;&gt;C: Returns result
    C--&gt;&gt;C: Accesses context
    C-&gt;&gt;CP: Returns the context
</code></pre>
<h2 id="resilient-context-pooling">Resilient context pooling</h2>
<!-- Overview -->
<p>The <code>ResilienceContext</code> object is resource-intensive to create, and recreating it for each execution would negatively impact performance. To address this issue, Polly provides a <code>ResilienceContextPool</code>. This pool allows you to obtain and reuse <code>ResilienceContext</code> instances. Once you've finished using a context instance, you can return it to the pool. This action will reset the context to its initial state, making it available for reuse.</p>
<!-- Methods -->
<p>The <code>ResilienceContextPool</code> offers several <code>Get</code> methods. These methods not only allow you to retrieve a <code>ResilienceContext</code> instance, but also enable you to initialize some of its properties at the time of retrieval.</p>
<!-- snippet: resilience-context-pool -->
<pre><code class="lang-cs">// Retrieve a context with a cancellation token
ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken);

try
{
    // Retrieve a context with a specific operation key
    context = ResilienceContextPool.Shared.Get(&quot;my-operation-key&quot;, cancellationToken);

    // Retrieve a context with multiple properties
    context = ResilienceContextPool.Shared.Get(
        operationKey: &quot;my-operation-key&quot;,
        continueOnCapturedContext: true,
        cancellationToken: cancellationToken);

    // Use the pool here
}
finally
{
    // Returning the context back to the pool is recommended, but not required as it reduces the allocations.
    // It is also OK to not return the context in case of exceptions, if you want to avoid try-catch blocks.
    ResilienceContextPool.Shared.Return(context);
}
</code></pre>
<!-- endSnippet -->
<div class="NOTE">
<h5>Note</h5>
<p>The <code>OperationKey</code> values are reported in <a href="telemetry.html#metrics">telemetry</a>. Beware of using very large or unbounded combinations for the operation key. See <a href="https://learn.microsoft.com/dotnet/core/diagnostics/metrics-instrumentation#best-practices-3">best practices</a> for more details.</p>
</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/App-vNext/Polly/blob/main/docs/advanced/resilience-context.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
