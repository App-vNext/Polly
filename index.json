{
  "advanced/dependency-injection.html": {
    "href": "advanced/dependency-injection.html",
    "title": "Dependency injection | Polly",
    "keywords": "Dependency injection Starting with version 8, Polly provides features that make the integration of Polly with the .NET IServiceCollection Dependency Injection (DI) container more streamlined. This is a thin layer atop the resilience pipeline registry which manages resilience pipelines. Usage To use the DI functionality, add the Polly.Extensions package to your project: dotnet add package Polly.Extensions Afterwards, you can use the AddResiliencePipeline(...) extension method to set up your pipeline: var services = new ServiceCollection(); // Define a resilience pipeline services.AddResiliencePipeline(\"my-key\", builder => { // Add strategies to your pipeline here, timeout for example builder.AddTimeout(TimeSpan.FromSeconds(10)); }); // You can also access IServiceProvider by using the alternate overload services.AddResiliencePipeline(\"my-key\", (builder, context) => { // Resolve any service from DI var loggerFactory = context.ServiceProvider.GetRequiredService<ILoggerFactory>(); // Add strategies to your pipeline here builder.AddTimeout(TimeSpan.FromSeconds(10)); }); // Resolve the resilience pipeline ServiceProvider serviceProvider = services.BuildServiceProvider(); ResiliencePipelineProvider<string> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>(); ResiliencePipeline pipeline = pipelineProvider.GetPipeline(\"my-key\"); // Use it await pipeline.ExecuteAsync( static async cancellation => await Task.Delay(100, cancellation)); The AddResiliencePipeline extension method also registers the following services into the DI container: ResiliencePipelineRegistry<string>: Allows adding and retrieving resilience pipelines. ResiliencePipelineProvider<string>: Allows retrieving resilience pipelines. IOptions<ResiliencePipelineRegistryOptions<string>>: Options for ResiliencePipelineRegistry<string>. Note The generic string is inferred since the pipeline was defined using the \"my-key\" value. If you only need the registry without defining a pipeline, use the AddResiliencePipelineRegistry(...) method. Generic resilience pipelines You can also define generic resilience pipelines (ResiliencePipeline<T>), as demonstrated below: var services = new ServiceCollection(); // Define a generic resilience pipeline // First parameter is the type of key, second one is the type of the results the generic pipeline works with services.AddResiliencePipeline<string, HttpResponseMessage>(\"my-pipeline\", builder => { builder.AddRetry(new() { MaxRetryAttempts = 2, ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<HttpRequestException>() .Handle<TimeoutRejectedException>() .HandleResult(response => response.StatusCode == System.Net.HttpStatusCode.InternalServerError) }) .AddTimeout(TimeSpan.FromSeconds(2)); }); // Resolve the resilience pipeline ServiceProvider serviceProvider = services.BuildServiceProvider(); ResiliencePipelineProvider<string> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>(); ResiliencePipeline<HttpResponseMessage> pipeline = pipelineProvider.GetPipeline<HttpResponseMessage>(\"my-key\"); // Use it await pipeline.ExecuteAsync( async cancellation => await client.GetAsync(endpoint, cancellation), cancellationToken); Keyed services .NET 8 introduced support for keyed services. Starting from version 8.3.0, Polly supports the retrieval of ResiliencePipeline or ResiliencePipeline<T> using keyed services. To begin, define your resilience pipeline: // Define a resilience pipeline services.AddResiliencePipeline<string, HttpResponseMessage>(\"my-pipeline\", builder => { // Configure the pipeline }); // Define a generic resilience pipeline services.AddResiliencePipeline(\"my-pipeline\", builder => { // Configure the pipeline }); Following the definition above, you can resolve the resilience pipelines using keyed services as shown in the example below: public class MyApi { private readonly ResiliencePipeline _pipeline; private readonly ResiliencePipeline<HttpResponseMessage> _genericPipeline; public MyApi( [FromKeyedServices(\"my-pipeline\")] ResiliencePipeline pipeline, [FromKeyedServices(\"my-pipeline\")] ResiliencePipeline<HttpResponseMessage> genericPipeline) { // Although the pipelines are registered with the same key, they are distinct instances. // One is generic, the other is not. _pipeline = pipeline; _genericPipeline = genericPipeline; } } Note The resilience pipelines are registered in the DI container as transient services. This enables the resolution of multiple instances of ResiliencePipeline when complex pipeline keys are used. The resilience pipeline is retrieved and registered using ResiliencePipelineProvider that is responsible for lifetime management of resilience pipelines. Deferred addition of pipelines If you want to use a key for a resilience pipeline that may not be available immediately you can use the AddResiliencePipelines() method to defer adding them until just prior to the ResiliencePipelineProvider<TKey> is instantiated by the DI container, allowing the IServiceProvider to be used if required. services .AddResiliencePipelines<string>((ctx) => { var config = ctx.ServiceProvider.GetRequiredService<IConfiguration>(); var configSection = config.GetSection(\"ResiliencePipelines\"); if (configSection is not null) { foreach (var pipelineConfig in configSection.GetChildren()) { var pipelineName = pipelineConfig.GetValue<string>(\"Name\"); if (!string.IsNullOrEmpty(pipelineName)) { ctx.AddResiliencePipeline(pipelineName, (builder, context) => { // Load configuration and configure pipeline... }); } } } }); Note The AddResiliencePipelines method does not support keyed services. To enable the resolution of a resilience pipeline using keyed services, you should use the AddResiliencePipeline extension method, which adds a single resilience pipeline and registers it into the keyed services. Dynamic reloads Dynamic reloading is a feature of the pipeline registry that is also surfaced when using the AddResiliencePipeline(...) extension method. Use an overload that provides access to AddResiliencePipelineContext: services .Configure<RetryStrategyOptions>(\"my-retry-options\", configurationSection) // Configure the options .AddResiliencePipeline(\"my-pipeline\", (builder, context) => { // Enable the reloads whenever the named options change context.EnableReloads<RetryStrategyOptions>(\"my-retry-options\"); // Utility method to retrieve the named options var retryOptions = context.GetOptions<RetryStrategyOptions>(\"my-retry-options\"); // Add retries using the resolved options builder.AddRetry(retryOptions); }); EnableReloads<T>(...) activates the dynamic reloading of my-pipeline. RetryStrategyOptions are fetched using context.GetOptions(...) utility method. A retry strategy is added. During a reload: The callback re-executes. The previous pipeline is discarded. If an error occurs during reloading, the old pipeline remains, and dynamic reloading stops. Resource disposal Like dynamic reloading, the pipeline registry's resource disposal feature lets you register callbacks. These callbacks run when the pipeline is discarded, reloaded, or the registry is disposed at application shutdown. See the example below: services.AddResiliencePipeline(\"my-pipeline\", (builder, context) => { // Create disposable resource var limiter = new ConcurrencyLimiter(new ConcurrencyLimiterOptions { PermitLimit = 100, QueueLimit = 100 }); // Use it builder.AddRateLimiter(limiter); // Dispose the resource created in the callback when the pipeline is discarded context.OnPipelineDisposed(() => limiter.Dispose()); }); This feature ensures that resources are properly disposed when a pipeline reloads, discarding the old version. Complex pipeline keys The AddResiliencePipeline(...) method supports complex pipeline keys. This capability allows you to define the structure of your pipeline and dynamically resolve and cache multiple instances of the pipeline with different keys. Start by defining your complex key: public record struct MyPipelineKey(string PipelineName, string InstanceName) { } Next, register your pipeline: services.AddResiliencePipeline(new MyPipelineKey(\"my-pipeline\", string.Empty), builder => { // Circuit breaker is a stateful strategy. To isolate the builder across different pipelines, // we must use multiple instances. builder.AddCircuitBreaker(new CircuitBreakerStrategyOptions()); }); The \"my-pipeline\" pipeline is now registered. Note that the InstanceName is an empty string. While we're registering the builder action for a specific pipeline, the InstanceName parameter isn't used during the pipeline's registration. Some further modifications are required for this to function. Introduce the PipelineNameComparer: public sealed class PipelineNameComparer : IEqualityComparer<MyPipelineKey> { public bool Equals(MyPipelineKey x, MyPipelineKey y) => x.PipelineName == y.PipelineName; public int GetHashCode(MyPipelineKey obj) => obj.PipelineName.GetHashCode(StringComparison.Ordinal); } Then, configure the registry behavior: services .AddResiliencePipelineRegistry<MyPipelineKey>(options => { options.BuilderComparer = new PipelineNameComparer(); options.InstanceNameFormatter = key => key.InstanceName; options.BuilderNameFormatter = key => key.PipelineName; }); Let's summarize our actions: We assigned the PipelineNameComparer instance to the BuilderComparer property. This action changes the default registry behavior, ensuring that only the PipelineName is used to find the associated builder. We used the InstanceNameFormatter delegate to represent the MyPipelineKey as an instance name for telemetry purposes, keeping the instance name as it is. Likewise, the BuilderNameFormatter delegate represents the MyPipelineKey as a builder name in telemetry. Finally, use the ResiliencePipelineProvider<MyPipelineKey> to dynamically create and cache multiple instances of the same pipeline: ResiliencePipelineProvider<MyPipelineKey> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<MyPipelineKey>>(); // The registry dynamically creates and caches instance-A using the associated builder action ResiliencePipeline instanceA = pipelineProvider.GetPipeline(new MyPipelineKey(\"my-pipeline\", \"instance-A\")); // The registry creates and caches instance-B ResiliencePipeline instanceB = pipelineProvider.GetPipeline(new MyPipelineKey(\"my-pipeline\", \"instance-B\")); Anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. The sections below highlight anti-patterns to avoid. Accessing the IServiceCollection instead of IServiceProvider ❌ DON'T Capture IServiceCollection inside AddResiliencePipeline(): var services = new ServiceCollection(); services.AddResiliencePipeline(\"myFavoriteStrategy\", builder => { builder.AddRetry(new() { OnRetry = args => { var serviceProvider = services.BuildServiceProvider(); var logger = serviceProvider.GetService<ILogger>(); // ... return default; } }); }); Reasoning: This approach builds a new ServiceProvider before each retry attempt unnecessarily. ✅ DO Use another overload of AddResiliencePipeline() which allows access to IServiceProvider: var services = new ServiceCollection(); services.AddResiliencePipeline(\"myFavoriteStrategy\", static (builder, context) => { builder.AddRetry(new() { OnRetry = args => { var logger = context.ServiceProvider.GetService<ILogger>(); // ... return default; } }); }); Reasoning: This approach uses the already built ServiceProvider and uses the same instance before every retry attempts."
  },
  "advanced/performance.html": {
    "href": "advanced/performance.html",
    "title": "Performance | Polly",
    "keywords": "Performance Polly is fast and avoids allocations wherever possible. We use a comprehensive set of performance benchmarks to monitor Polly's performance. Here's an example of results from an advanced pipeline composed of the following strategies: Timeout (outer) Rate limiter Retry Circuit breaker Timeout (inner) Method Mean Error StdDev Ratio RatioSD Gen0 Allocated Alloc Ratio Execute policy v7 2.277 μs 0.0133 μs 0.0191 μs 1.00 0.00 0.1106 2824 B 1.00 Execute pipeline v8 2.089 μs 0.0105 μs 0.0157 μs 0.92 0.01 - 40 B 0.01 Compared to older versions, Polly v8 is both faster and more memory efficient. Performance tips If you're aiming for the best performance with Polly, consider these tips: Use static lambdas Lambdas capturing variables from their outer scope will allocate on every execution. Polly provides tools to avoid this overhead, as shown in the example below: // This call allocates for each invocation since the \"userId\" variable is captured from the outer scope. await resiliencePipeline.ExecuteAsync( cancellationToken => GetMemberAsync(userId, cancellationToken), cancellationToken); // This approach uses a static lambda, avoiding allocations. // The \"userId\" is stored as state, and the lambda consumes it. await resiliencePipeline.ExecuteAsync( static (state, cancellationToken) => GetMemberAsync(state, cancellationToken), userId, cancellationToken); Use switch expressions for predicates The PredicateBuilder maintains a list of all registered predicates. To determine whether the results should be processed, it iterates through this list. Using switch expressions can help you bypass this overhead. // Here, PredicateBuilder is used to configure which exceptions the retry strategy should handle. new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<SomeExceptionType>() .Handle<InvalidOperationException>() .Handle<HttpRequestException>() }) .Build(); // For optimal performance, it's recommended to use switch expressions instead of PredicateBuilder. new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = args => args.Outcome.Exception switch { SomeExceptionType => PredicateResult.True(), InvalidOperationException => PredicateResult.True(), HttpRequestException => PredicateResult.True(), _ => PredicateResult.False() } }) .Build(); Execute callbacks without throwing exceptions Polly provides the ExecuteOutcomeAsync API, returning results as Outcome<T>. The Outcome<T> might contain an exception instance, which you can check without it being thrown. This is beneficial when employing exception-heavy resilience strategies, like circuit breakers. // Execute GetMemberAsync and handle exceptions externally. try { await pipeline.ExecuteAsync(cancellationToken => GetMemberAsync(id, cancellationToken), cancellationToken); } catch (Exception e) { // Log the exception here. logger.LogWarning(e, \"Failed to get member with id '{id}'.\", id); } // The example above can be restructured as: // Acquire a context from the pool ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken); // Instead of wrapping pipeline execution with try-catch, use ExecuteOutcomeAsync(...). // Certain strategies are optimized for this method, returning an exception instance without actually throwing it. Outcome<Member> outcome = await pipeline.ExecuteOutcomeAsync( static async (context, state) => { // The callback for ExecuteOutcomeAsync must return an Outcome<T> instance. Hence, some wrapping is needed. try { return Outcome.FromResult(await GetMemberAsync(state, context.CancellationToken)); } catch (Exception e) { return Outcome.FromException<Member>(e); } }, context, id); // Handle exceptions using the Outcome<T> instance instead of try-catch. if (outcome.Exception is not null) { logger.LogWarning(outcome.Exception, \"Failed to get member with id '{id}'.\", id); } // Release the context back to the pool ResilienceContextPool.Shared.Return(context); Reuse resilience pipeline instances Creating a resilience pipeline can be resource-intensive, so it's advisable not to discard the instance after each use. Instead, you can either cache the resilience pipeline or use the GetOrAddPipeline(...) method from ResiliencePipelineRegistry<T> to cache the pipeline dynamically: public class MyApi { private readonly ResiliencePipelineRegistry<string> _registry; // Share a single instance of the registry throughout your application. public MyApi(ResiliencePipelineRegistry<string> registry) { _registry = registry; } public async Task UpdateData(CancellationToken cancellationToken) { // Get or create the pipeline, and then cache it for subsequent use. // Choose a sufficiently unique key to prevent collisions. var pipeline = _registry.GetOrAddPipeline(\"my-app.my-api\", builder => { builder.AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<InvalidOperationException>() .Handle<HttpRequestException>() }); }); await pipeline.ExecuteAsync(async token => { // Place your logic here }, cancellationToken); } } Note You can also define your pipeline on startup using dependency injection and then use ResiliencePipelineProvider<T> to retrieve the instance."
  },
  "advanced/resilience-context.html": {
    "href": "advanced/resilience-context.html",
    "title": "Resilience context | Polly",
    "keywords": "Resilience context The ResilienceContext class in Polly provides an execution-scoped instance that accompanies each execution through a Polly resilience pipeline and across all strategies in the pipeline. This class serves to share context and facilitate information exchange between the pre-execution, mid-execution, and post-execution phases. The resilience context exposes several properties: OperationKey: A user-defined identifier for the operation. CancellationToken: The cancellation token linked to the operation. Properties: An instance of ResilienceProperties for attaching custom data to the context. ContinueOnCapturedContext: Specifies whether the asynchronous execution should continue on the captured context. Usage Below is an example demonstrating how to work with ResilienceContext: // Retrieve a context with a cancellation token ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken); // Attach custom data to the context context.Properties.Set(MyResilienceKeys.Key1, \"my-data\"); context.Properties.Set(MyResilienceKeys.Key2, 123); // Utilize the context in a resilience pipeline ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new() { OnRetry = static args => { // Retrieve custom data from the context, if available if (args.Context.Properties.TryGetValue(MyResilienceKeys.Key1, out var data)) { Console.WriteLine(\"OnRetry, Custom Data: {0}\", data); } return default; } }) .Build(); // Execute the resilience pipeline asynchronously await pipeline.ExecuteAsync( static async context => { // Insert your execution logic here }, context); // Return the context to the pool ResilienceContextPool.Shared.Return(context); Where ResilienceKeys is defined as: public static class MyResilienceKeys { public static readonly ResiliencePropertyKey<string> Key1 = new(\"my-key-1\"); public static readonly ResiliencePropertyKey<int> Key2 = new(\"my-key-2\"); } Note We recommend defining a static class to hold the resilience property keys used in your project. This approach makes these keys easier to discover and maintain. For simpler scenarios, you can directly use the creation of ResiliencePropertyKey<string> since it's a cheap, struct-based API. Sequence diagram sequenceDiagram autonumber actor C as Caller participant CP as ResilienceContextPool participant P as Pipeline participant R as Retry participant D as DecoratedUserCallback participant O as OnRetryUserCallback C->>CP: Rents a context CP->>C: Gives a context C->>P: Calls ExecuteAsync<br/>with context P->>R: Calls ExecuteCore<br/>with context Note over R,D: Initial attempt R->>+D: Invokes<br/>with context D->>-R: Fails R->>+O: Invokes<br/>with context O->>-R: Completes R-->>R: Sleeps Note over R,D: 1st retry attempt R->>+D: Invokes<br/>with context D->>-R: Returns result R->>P: Returns result P->>C: Returns result C-->>C: Accesses context C->>CP: Returns the context Resilient context pooling The ResilienceContext object is resource-intensive to create, and recreating it for each execution would negatively impact performance. To address this issue, Polly provides a ResilienceContextPool. This pool allows you to obtain and reuse ResilienceContext instances. Once you've finished using a context instance, you can return it to the pool. This action will reset the context to its initial state, making it available for reuse. The ResilienceContextPool offers several Get methods. These methods not only allow you to retrieve a ResilienceContext instance, but also enable you to initialize some of its properties at the time of retrieval. // Retrieve a context with a cancellation token ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken); try { // Retrieve a context with a specific operation key context = ResilienceContextPool.Shared.Get(\"my-operation-key\", cancellationToken); // Retrieve a context with multiple properties context = ResilienceContextPool.Shared.Get( operationKey: \"my-operation-key\", continueOnCapturedContext: true, cancellationToken: cancellationToken); // Use the pool here } finally { // Returning the context back to the pool is recommended, but not required as it reduces the allocations. // It is also OK to not return the context in case of exceptions, if you want to avoid try-catch blocks. ResilienceContextPool.Shared.Return(context); } Note The OperationKey values are reported in telemetry. Beware of using very large or unbounded combinations for the operation key. See best practices for more details."
  },
  "advanced/telemetry.html": {
    "href": "advanced/telemetry.html",
    "title": "Telemetry | Polly",
    "keywords": "Telemetry Starting with version 8, Polly provides telemetry for all built-in resilience strategies. Usage To enable telemetry in Polly, add the Polly.Extensions package to your project: dotnet add package Polly.Extensions Afterwards, you can use the ConfigureTelemetry(...) extension method on the ResiliencePipelineBuilder: var telemetryOptions = new TelemetryOptions { // Configure logging LoggerFactory = LoggerFactory.Create(builder => builder.AddConsole()) }; // Configure enrichers telemetryOptions.MeteringEnrichers.Add(new MyMeteringEnricher()); // Configure telemetry listeners telemetryOptions.TelemetryListeners.Add(new MyTelemetryListener()); var builder = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(1)) .ConfigureTelemetry(telemetryOptions) // This method enables telemetry in the builder .Build(); The MyTelemetryListener and MyMeteringEnricher is implemented as: internal class MyTelemetryListener : TelemetryListener { public override void Write<TResult, TArgs>(in TelemetryEventArguments<TResult, TArgs> args) { Console.WriteLine($\"Telemetry event occurred: {args.Event.EventName}\"); } } internal class MyMeteringEnricher : MeteringEnricher { public override void Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs> context) { context.Tags.Add(new(\"my-custom-tag\", \"custom-value\")); } } Alternatively, you can use the AddResiliencePipeline(...) extension method which automatically enables telemetry for defined pipeline: var serviceCollection = new ServiceCollection() .AddLogging(builder => builder.AddConsole()) .AddResiliencePipeline(\"my-strategy\", builder => builder.AddTimeout(TimeSpan.FromSeconds(1))) .Configure<TelemetryOptions>(options => { // Configure enrichers options.MeteringEnrichers.Add(new MyMeteringEnricher()); // Configure telemetry listeners options.TelemetryListeners.Add(new MyTelemetryListener()); }); Metrics The metrics are emitted under the Polly meter name. The subsequent sections provide insights into the metrics produced by Polly. Please note that any custom enriched tags are not depicted in the following tables. Every telemetry event has the following tags: pipeline.name: Optional, comes from ResiliencePipelineBuilder.Name. pipeline.instance: Optional, comes from ResiliencePipelineBuilder.InstanceName. strategy.name: Optional, comes from RetryStrategyOptions.Name. operation.key: Optional, comes from ResilienceContext.OperationKey. The sample below demonstrates how to assign these tags: var builder = new ResiliencePipelineBuilder(); builder.Name = \"my-name\"; builder.InstanceName = \"my-instance-name\"; builder.AddRetry(new RetryStrategyOptions { // The default value is \"Retry\" Name = \"my-retry-name\" }); ResiliencePipeline pipeline = builder.Build(); // Create resilience context with operation key ResilienceContext resilienceContext = ResilienceContextPool.Shared.Get(\"my-operation-key\"); // Execute the pipeline with the context pipeline.Execute( context => { // Your code comes here }, resilienceContext); Note Beware of using very large or unbounded combinations of tag values for the tags above. See best practices for more details. These values are subsequently reflected in the following metering instruments exposed by Polly: Instrument: resilience.polly.strategy.events Type: Counter Numerical type of measurement: int Description: Emitted upon the occurrence of a resilience event. Tags: Name Description event.name The name of the emitted event. event.severity The severity of the event (Debug, Information, Warning, Error, Critical). pipeline.name The name of the pipeline corresponding to the resilience pipeline. pipeline.instance The instance name of the pipeline corresponding to the resilience pipeline. strategy.name The name of the strategy generating this event. operation.key The operation key associated with the call site. exception.type The full name of the exception assigned to the execution result (System.InvalidOperationException). Event names The event.name tag is reported by individual resilience strategies. The built-in strategies report the following events: OnRetry OnFallback OnHedging OnTimeout OnCircuitClosed OnCircuitOpened OnCircuitHalfOpened OnRateLimiterRejected Instrument: resilience.polly.strategy.attempt.duration Type: Histogram Unit: milliseconds Numerical type of measurement: double Description: Tracks the duration of execution attempts, produced by Retry and Hedging resilience strategies. Tags: Name Description event.name The name of the emitted event. Currently, the event name is always ExecutionAttempt. event.severity The severity of the event (Debug, Information, Warning, Error, Critical). pipeline.name The name of the pipeline corresponding to the resilience pipeline. pipeline.instance The instance name of the pipeline corresponding to the resilience pipeline. strategy.name The name of the strategy generating this event. operation.key The operation key associated with the call site. exception.type The full name of the exception assigned to the execution result (System.InvalidOperationException). attempt.number The execution attempt number, starting at 0 (0, 1, 2, etc.). attempt.handled Indicates if the execution outcome was handled. A handled outcome indicates execution failure and the need for retry (true, false). Instrument: resilience.polly.pipeline.duration Type: Histogram Unit: milliseconds Numerical type of measurement: double Description: Measures the duration of resilience pipelines. Tags: Name Description pipeline.name The name of the pipeline corresponding to the resilience pipeline. pipeline.instance The instance name of the pipeline corresponding to the resilience pipeline. operation.key The operation key associated with the call site. exception.type The full name of the exception assigned to the execution result (System.InvalidOperationException). Metering enrichment Polly API lets you add extra tags to any resilience event created by resilience strategies. To do this, derive from the MeteringEnricher class and add your custom enricher to the MeteringEnrichers list. The custom enricher: internal sealed class CustomMeteringEnricher : MeteringEnricher { public override void Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs> context) { // You can read additional details from any resilience event and use it to enrich the telemetry if (context.TelemetryEvent.Arguments is OnRetryArguments<TResult> retryArgs) { // See https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md for more details // on how to name the tags. context.Tags.Add(new(\"retry.attempt\", retryArgs.AttemptNumber)); } } } Registering the custom enricher: var telemetryOptions = new TelemetryOptions(); // Register custom enricher telemetryOptions.MeteringEnrichers.Add(new CustomMeteringEnricher()); var builder = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions()) .ConfigureTelemetry(telemetryOptions) // This method enables telemetry in the builder .Build(); Logs Logs are registered under the Polly logger name. Here are some examples of the logs: // This log is recorded whenever a resilience event occurs. EventId = 0 Resilience event occurred. EventName: '{EventName}', Source: '{PipelineName}/{PipelineInstance}/{StrategyName}', Operation Key: '{OperationKey}', Result: '{Result}' // This log is recorded when a resilience pipeline begins executing. EventId = 1 Resilience pipeline executing. Source: '{PipelineName}/{PipelineInstance}', Operation Key: '{OperationKey}' // This log is recorded when a resilience pipeline finishes execution. EventId = 2 Resilience pipeline executed. Source: '{PipelineName}/{PipelineInstance}', Operation Key: '{OperationKey}', Result: '{Result}', Execution Health: '{ExecutionHealth}', Execution Time: {ExecutionTime}ms // This log is recorded upon the completion of every execution attempt. EventId = 3 Execution attempt. Source: '{PipelineName}/{PipelineInstance}/{StrategyName}', Operation Key: '{OperationKey}', Result: '{Result}', Handled: '{Handled}', Attempt: '{Attempt}', Execution Time: '{ExecutionTimeMs}' Emitting telemetry events Each resilience strategy can generate telemetry data through the ResilienceStrategyTelemetry API. Polly encapsulates event details as TelemetryEventArguments and emits them via TelemetryListener. To leverage this telemetry data, users should assign a TelemetryListener instance to ResiliencePipelineBuilder.TelemetryListener and then consume the TelemetryEventArguments. For common scenarios, it is expected that users would make use of Polly.Extensions. This extension enables telemetry configuration through the ResiliencePipelineBuilder.ConfigureTelemetry(...) method, which processes TelemetryEventArguments to generate logs and metrics."
  },
  "advanced/testing.html": {
    "href": "advanced/testing.html",
    "title": "Testing | Polly",
    "keywords": "Testing This document explains how to test Polly's resilience pipelines. You should not test how the resilience pipelines operate internally, but rather test your own settings or custom delegates. To make the testing process simpler, Polly offers the Polly.Testing package. This package has a range of APIs designed to help you test the setup and combination of resilience pipelines in your user code. Usage Begin by adding the Polly.Testing package to your test project: dotnet add package Polly.Testing Use the GetPipelineDescriptor extension method to get the ResiliencePipelineDescriptor which provides details on the pipeline's composition: // Build your resilience pipeline. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { MaxRetryAttempts = 4 }) .AddTimeout(TimeSpan.FromSeconds(1)) .Build(); // Retrieve the descriptor. ResiliencePipelineDescriptor descriptor = pipeline.GetPipelineDescriptor(); // Check the pipeline's composition with the descriptor. Assert.Equal(2, descriptor.Strategies.Count); // Verify the retry settings. var retryOptions = Assert.IsType<RetryStrategyOptions>(descriptor.Strategies[0].Options); Assert.Equal(4, retryOptions.MaxRetryAttempts); // Confirm the timeout settings. var timeoutOptions = Assert.IsType<TimeoutStrategyOptions>(descriptor.Strategies[1].Options); Assert.Equal(TimeSpan.FromSeconds(1), timeoutOptions.Timeout); The GetPipelineDescriptor extension method is also available for the generic ResiliencePipeline<T>: // Construct your resilience pipeline. ResiliencePipeline<string> pipeline = new ResiliencePipelineBuilder<string>() .AddRetry(new RetryStrategyOptions<string> { MaxRetryAttempts = 4 }) .AddTimeout(TimeSpan.FromSeconds(1)) .Build(); // Obtain the descriptor. ResiliencePipelineDescriptor descriptor = pipeline.GetPipelineDescriptor(); // Check the pipeline's composition with the descriptor. // ... Mocking ResiliencePipelineProvider<TKey> Consider the following code that might resemble a part of your project: // Represents an arbitrary API that needs resilience support public class MyApi { private readonly ResiliencePipeline _pipeline; // The value of pipelineProvider is injected via dependency injection public MyApi(ResiliencePipelineProvider<string> pipelineProvider) { _pipeline = pipelineProvider.GetPipeline(\"my-pipeline\"); } public async Task ExecuteAsync(CancellationToken cancellationToken) { await _pipeline.ExecuteAsync( static async token => { // Add your code here }, cancellationToken); } } // Extensions to incorporate MyApi into dependency injection public static class MyApiExtensions { public static IServiceCollection AddMyApi(this IServiceCollection services) { return services .AddResiliencePipeline(\"my-pipeline\", builder => { builder.AddRetry(new RetryStrategyOptions { MaxRetryAttempts = 4 }); }) .AddSingleton<MyApi>(); } } In the example above: The MyApi class is introduced, representing part of your application that requires resilience support. The AddMyApi extension method is also defined, which integrates MyApi into dependency injection (DI) and sets up the resilience pipeline it uses. For unit tests, if you want to assess the behavior of ExecuteAsync, it might not be practical to rely on the entire pipeline, especially since it could slow down tests during failure scenario evaluations. Instead, it's recommended to mock the ResiliencePipelineProvider<string> and return an empty pipeline: ResiliencePipelineProvider<string> pipelineProvider = Substitute.For<ResiliencePipelineProvider<string>>(); // Mock the pipeline provider to return an empty pipeline for testing pipelineProvider .GetPipeline(\"my-pipeline\") .Returns(ResiliencePipeline.Empty); // Use the mocked pipeline provider in your code var api = new MyApi(pipelineProvider); // You can now test the api This example leverages the NSubstitute library to mock the pipeline provider."
  },
  "api/Polly.CircuitBreaker.BreakDurationGeneratorArguments.html": {
    "href": "api/Polly.CircuitBreaker.BreakDurationGeneratorArguments.html",
    "title": "Struct BreakDurationGeneratorArguments | Polly",
    "keywords": "Struct BreakDurationGeneratorArguments Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Represents arguments used to generate a dynamic break duration for a circuit breaker. public readonly struct BreakDurationGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BreakDurationGeneratorArguments(double, int, ResilienceContext, int) Initializes a new instance of the BreakDurationGeneratorArguments struct. public BreakDurationGeneratorArguments(double failureRate, int failureCount, ResilienceContext context, int halfOpenAttempts) Parameters failureRate double The failure rate at which the circuit breaker should trip. It represents the ratio of failed actions to the total executed actions. failureCount int The number of failures that have occurred. This count is used to determine if the failure threshold has been reached. context ResilienceContext The resilience context providing additional information about the execution state and failures. halfOpenAttempts int The number of half-open attempts. Properties Context Gets the context that provides additional information about the resilience operation. public ResilienceContext Context { get; } Property Value ResilienceContext FailureCount Gets the count of failures that have occurred. public int FailureCount { get; } Property Value int FailureRate Gets the failure rate that represents the ratio of failures to total actions. public double FailureRate { get; } Property Value double HalfOpenAttempts Gets the number of half-open attempts. public int HalfOpenAttempts { get; } Property Value int"
  },
  "api/Polly.CircuitBreaker.BrokenCircuitException.html": {
    "href": "api/Polly.CircuitBreaker.BrokenCircuitException.html",
    "title": "Class BrokenCircuitException | Polly",
    "keywords": "Class BrokenCircuitException Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Exception thrown when a circuit is broken. public class BrokenCircuitException : ExecutionRejectedException, ISerializable Inheritance object Exception ExecutionRejectedException BrokenCircuitException Implements ISerializable Derived IsolatedCircuitException Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors BrokenCircuitException() Initializes a new instance of the BrokenCircuitException class. public BrokenCircuitException() BrokenCircuitException(string) Initializes a new instance of the BrokenCircuitException class. public BrokenCircuitException(string message) Parameters message string The message that describes the error. BrokenCircuitException(string, Exception) Initializes a new instance of the BrokenCircuitException class. public BrokenCircuitException(string message, Exception inner) Parameters message string The message that describes the error. inner Exception The inner exception."
  },
  "api/Polly.CircuitBreaker.CircuitBreakerManualControl.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerManualControl.html",
    "title": "Class CircuitBreakerManualControl | Polly",
    "keywords": "Class CircuitBreakerManualControl Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Allows manual control of the circuit-breaker. public sealed class CircuitBreakerManualControl Inheritance object CircuitBreakerManualControl Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks The instance of this class can be reused across multiple circuit breakers. Constructors CircuitBreakerManualControl() Initializes a new instance of the CircuitBreakerManualControl class. public CircuitBreakerManualControl() CircuitBreakerManualControl(bool) Initializes a new instance of the CircuitBreakerManualControl class. public CircuitBreakerManualControl(bool isIsolated) Parameters isIsolated bool Determines whether the circuit breaker is isolated immediately after construction. Methods CloseAsync(CancellationToken) Closes the circuit, and resets any statistics controlling automated circuit-breaking. public Task CloseAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken The cancellation token. Returns Task The instance of Task that represents the asynchronous execution. Exceptions ObjectDisposedException Thrown when calling this method after this object is disposed. IsolateAsync(CancellationToken) Isolates (opens) the circuit manually, and holds it in this state until a call to CloseAsync(CancellationToken) is made. public Task IsolateAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken The cancellation token. Returns Task The instance of Task that represents the asynchronous execution. Exceptions ObjectDisposedException Thrown when calling this method after this object is disposed."
  },
  "api/Polly.CircuitBreaker.CircuitBreakerPredicateArguments-1.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerPredicateArguments-1.html",
    "title": "Struct CircuitBreakerPredicateArguments<TResult> | Polly",
    "keywords": "Struct CircuitBreakerPredicateArguments<TResult> Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Arguments used by ShouldHandle predicate. public readonly struct CircuitBreakerPredicateArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors CircuitBreakerPredicateArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the CircuitBreakerPredicateArguments<TResult> struct. public CircuitBreakerPredicateArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the user-specified callback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.CircuitBreaker.CircuitBreakerStateProvider.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerStateProvider.html",
    "title": "Class CircuitBreakerStateProvider | Polly",
    "keywords": "Class CircuitBreakerStateProvider Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Allows retrieval of the circuit breaker state. public sealed class CircuitBreakerStateProvider Inheritance object CircuitBreakerStateProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties CircuitState Gets the state of the underlying circuit. public CircuitState CircuitState { get; } Property Value CircuitState"
  },
  "api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions-1.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions-1.html",
    "title": "Class CircuitBreakerStrategyOptions<TResult> | Polly",
    "keywords": "Class CircuitBreakerStrategyOptions<TResult> Namespace Polly.CircuitBreaker Assembly Polly.Core.dll The options for circuit breaker resilience strategy. public class CircuitBreakerStrategyOptions<TResult> : ResilienceStrategyOptions Type Parameters TResult The type of result the circuit breaker strategy handles. Inheritance object ResilienceStrategyOptions CircuitBreakerStrategyOptions<TResult> Derived CircuitBreakerStrategyOptions Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The circuit will break if, within any time-slice of duration SamplingDuration, the proportion of actions resulting in a handled exception exceeds FailureRatio, provided also that the number of actions through the circuit in the time-slice is at least MinimumThroughput. The circuit will stay broken for the BreakDuration. Any attempt to execute this while the circuit is broken, will immediately throw a BrokenCircuitException containing the exception that broke the circuit. If the first action after the break duration period results in a handled exception, the circuit will break again for another BreakDuration; if no exception is thrown, the circuit will reset. Constructors CircuitBreakerStrategyOptions() Initializes a new instance of the CircuitBreakerStrategyOptions<TResult> class. public CircuitBreakerStrategyOptions() Properties BreakDuration Gets or sets the duration of break the circuit will stay open before resetting. [Range(typeof(TimeSpan), \"00:00:00.500\", \"1.00:00:00\")] public TimeSpan BreakDuration { get; set; } Property Value TimeSpan The default value is 5 seconds. Value must be greater than 0.5 seconds. BreakDurationGenerator Gets or sets an optional delegate to use to dynamically generate the break duration. public Func<BreakDurationGeneratorArguments, ValueTask<TimeSpan>>? BreakDurationGenerator { get; set; } Property Value Func<BreakDurationGeneratorArguments, ValueTask<TimeSpan>> The default value is null. FailureRatio Gets or sets the failure-to-success ratio at which the circuit will break. [Range(0, 1)] public double FailureRatio { get; set; } Property Value double A ratio number higher than 0, up to 1. The default value is 0.1 (i.e. 10%). Remarks A number between zero and one (inclusive) e.g. 0.5 represents breaking if 50% or more of actions result in a handled failure. ManualControl Gets or sets the manual control for the circuit breaker. public CircuitBreakerManualControl? ManualControl { get; set; } Property Value CircuitBreakerManualControl The default value is null. MinimumThroughput Gets or sets the minimum throughput: this many actions or more must pass through the circuit in the time-slice, for statistics to be considered significant and the circuit-breaker to come into action. [Range(2, 2147483647)] public int MinimumThroughput { get; set; } Property Value int The default value is 100. The value must be 2 or greater. OnClosed Gets or sets the event that is raised when the circuit resets to a Closed state. public Func<OnCircuitClosedArguments<TResult>, ValueTask>? OnClosed { get; set; } Property Value Func<OnCircuitClosedArguments<TResult>, ValueTask> The default value is null. Remarks The callbacks registered to this event are invoked with eventual consistency. There is no guarantee that the circuit breaker doesn't change the state before the callbacks finish. If you need to know the up-to-date state of the circuit breaker use the CircuitState property. Note that these events might be executed asynchronously at a later time when the circuit state is no longer the same as at the point of invocation of the event. However, the invocation order of the OnOpened, OnClosed, and OnHalfOpened events is always maintained to ensure the correct sequence of state transitions. OnHalfOpened Gets or sets the event that is raised when when the circuit transitions to an HalfOpen state. public Func<OnCircuitHalfOpenedArguments, ValueTask>? OnHalfOpened { get; set; } Property Value Func<OnCircuitHalfOpenedArguments, ValueTask> The default value is null. Remarks The callbacks registered to this event are invoked with eventual consistency. There is no guarantee that the circuit breaker doesn't change the state before the callbacks finish. If you need to know the up-to-date state of the circuit breaker use the CircuitState property. Note that these events might be executed asynchronously at a later time when the circuit state is no longer the same as at the point of invocation of the event. However, the invocation order of the OnOpened, OnClosed, and OnHalfOpened events is always maintained to ensure the correct sequence of state transitions. OnOpened Gets or sets the event that is raised when the circuit transitions to an Open state. public Func<OnCircuitOpenedArguments<TResult>, ValueTask>? OnOpened { get; set; } Property Value Func<OnCircuitOpenedArguments<TResult>, ValueTask> The default value is null. Remarks The callbacks registered to this event are invoked with eventual consistency. There is no guarantee that the circuit breaker doesn't change the state before the callbacks finish. If you need to know the up-to-date state of the circuit breaker use the CircuitState property. Note that these events might be executed asynchronously at a later time when the circuit state is no longer the same as at the point of invocation of the event. However, the invocation order of the OnOpened, OnClosed, and OnHalfOpened events is always maintained to ensure the correct sequence of state transitions. SamplingDuration Gets or sets the duration of the sampling over which failure ratios are assessed. [Range(typeof(TimeSpan), \"00:00:00.500\", \"1.00:00:00\")] public TimeSpan SamplingDuration { get; set; } Property Value TimeSpan The default value is 30 seconds. Value must be greater than 0.5 seconds. ShouldHandle Gets or sets a predicate that determines whether the outcome should be handled by the circuit breaker. [Required] public Func<CircuitBreakerPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } Property Value Func<CircuitBreakerPredicateArguments<TResult>, ValueTask<bool>> The default value is a predicate that handles circuit breaker on any exception except OperationCanceledException. This property is required. StateProvider Gets or sets the state provider for the circuit breaker. public CircuitBreakerStateProvider? StateProvider { get; set; } Property Value CircuitBreakerStateProvider The default value is null."
  },
  "api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions.html",
    "title": "Class CircuitBreakerStrategyOptions | Polly",
    "keywords": "Class CircuitBreakerStrategyOptions Namespace Polly.CircuitBreaker Assembly Polly.Core.dll The options for circuit breaker resilience strategy. public class CircuitBreakerStrategyOptions : CircuitBreakerStrategyOptions<object> Inheritance object ResilienceStrategyOptions CircuitBreakerStrategyOptions<object> CircuitBreakerStrategyOptions Inherited Members CircuitBreakerStrategyOptions<object>.FailureRatio CircuitBreakerStrategyOptions<object>.MinimumThroughput CircuitBreakerStrategyOptions<object>.SamplingDuration CircuitBreakerStrategyOptions<object>.BreakDuration CircuitBreakerStrategyOptions<object>.BreakDurationGenerator CircuitBreakerStrategyOptions<object>.ShouldHandle CircuitBreakerStrategyOptions<object>.OnClosed CircuitBreakerStrategyOptions<object>.OnOpened CircuitBreakerStrategyOptions<object>.OnHalfOpened CircuitBreakerStrategyOptions<object>.ManualControl CircuitBreakerStrategyOptions<object>.StateProvider ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The circuit will break if, within any time-slice of duration SamplingDuration, the proportion of actions resulting in a handled exception exceeds FailureRatio, provided also that the number of actions through the circuit in the time-slice is at least MinimumThroughput. The circuit will stay broken for the BreakDuration. Any attempt to execute this while the circuit is broken, will immediately throw a BrokenCircuitException containing the exception that broke the circuit. If the first action after the break duration period results in a handled exception, the circuit will break again for another BreakDuration; if no exception is thrown, the circuit will reset."
  },
  "api/Polly.CircuitBreaker.CircuitState.html": {
    "href": "api/Polly.CircuitBreaker.CircuitState.html",
    "title": "Enum CircuitState | Polly",
    "keywords": "Enum CircuitState Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Describes the possible states the circuit of a Circuit Breaker may be in. public enum CircuitState Fields Closed = 0 Closed - When the circuit is closed. Execution of actions is allowed. HalfOpen = 2 Half-open - When the circuit is half-open, it is recovering from an open state. The duration of break of the preceding open state has typically passed. In the half-open state, actions may be executed, but the results of these actions may be treated with criteria different to normal operation, to decide if the circuit has recovered sufficiently to be placed back in to the closed state, or if continuing failures mean the circuit should revert to open perhaps more quickly than in normal operation. Isolated = 3 Isolated - When the circuit has been placed into a fixed open state by the isolate call. This isolates the circuit manually, blocking execution of all actions until a reset call is made. Open = 1 Open - When the automated controller has opened the circuit (typically due to some failure threshold being exceeded by recent actions). Execution of actions is blocked."
  },
  "api/Polly.CircuitBreaker.IsolatedCircuitException.html": {
    "href": "api/Polly.CircuitBreaker.IsolatedCircuitException.html",
    "title": "Class IsolatedCircuitException | Polly",
    "keywords": "Class IsolatedCircuitException Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Exception thrown when a circuit is isolated (held open) by manual override. public class IsolatedCircuitException : BrokenCircuitException, ISerializable Inheritance object Exception ExecutionRejectedException BrokenCircuitException IsolatedCircuitException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors IsolatedCircuitException() Initializes a new instance of the IsolatedCircuitException class. public IsolatedCircuitException() IsolatedCircuitException(string) Initializes a new instance of the IsolatedCircuitException class. public IsolatedCircuitException(string message) Parameters message string The message that describes the error. IsolatedCircuitException(string, Exception) Initializes a new instance of the IsolatedCircuitException class. public IsolatedCircuitException(string message, Exception innerException) Parameters message string The message that describes the error. innerException Exception The inner exception."
  },
  "api/Polly.CircuitBreaker.OnCircuitClosedArguments-1.html": {
    "href": "api/Polly.CircuitBreaker.OnCircuitClosedArguments-1.html",
    "title": "Struct OnCircuitClosedArguments<TResult> | Polly",
    "keywords": "Struct OnCircuitClosedArguments<TResult> Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Arguments used by OnClosed event. public readonly struct OnCircuitClosedArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnCircuitClosedArguments(ResilienceContext, Outcome<TResult>, bool) Initializes a new instance of the OnCircuitClosedArguments<TResult> struct. public OnCircuitClosedArguments(ResilienceContext context, Outcome<TResult> outcome, bool isManual) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. isManual bool Indicates whether the circuit was closed manually by using CircuitBreakerManualControl. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext IsManual Gets a value indicating whether the circuit was closed manually by using CircuitBreakerManualControl. public bool IsManual { get; } Property Value bool Outcome Gets the outcome that caused the circuit breaker to be closed. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.CircuitBreaker.OnCircuitHalfOpenedArguments.html": {
    "href": "api/Polly.CircuitBreaker.OnCircuitHalfOpenedArguments.html",
    "title": "Struct OnCircuitHalfOpenedArguments | Polly",
    "keywords": "Struct OnCircuitHalfOpenedArguments Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Arguments used by OnHalfOpened event. public readonly struct OnCircuitHalfOpenedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnCircuitHalfOpenedArguments(ResilienceContext) Initializes a new instance of the OnCircuitHalfOpenedArguments struct. public OnCircuitHalfOpenedArguments(ResilienceContext context) Parameters context ResilienceContext The context instance. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.CircuitBreaker.OnCircuitOpenedArguments-1.html": {
    "href": "api/Polly.CircuitBreaker.OnCircuitOpenedArguments-1.html",
    "title": "Struct OnCircuitOpenedArguments<TResult> | Polly",
    "keywords": "Struct OnCircuitOpenedArguments<TResult> Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Arguments used by OnOpened event. public readonly struct OnCircuitOpenedArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnCircuitOpenedArguments(ResilienceContext, Outcome<TResult>, TimeSpan, bool) Initializes a new instance of the OnCircuitOpenedArguments<TResult> struct. public OnCircuitOpenedArguments(ResilienceContext context, Outcome<TResult> outcome, TimeSpan breakDuration, bool isManual) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. breakDuration TimeSpan The duration of break. isManual bool Indicates whether the circuit was opened manually by using CircuitBreakerManualControl. Properties BreakDuration Gets the duration of break. public TimeSpan BreakDuration { get; } Property Value TimeSpan Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext IsManual Gets a value indicating whether the circuit was opened manually by using CircuitBreakerManualControl. public bool IsManual { get; } Property Value bool Outcome Gets the outcome that caused the circuit to open. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.CircuitBreaker.html": {
    "href": "api/Polly.CircuitBreaker.html",
    "title": "Namespace Polly.CircuitBreaker | Polly",
    "keywords": "Namespace Polly.CircuitBreaker Classes BrokenCircuitException Exception thrown when a circuit is broken. CircuitBreakerManualControl Allows manual control of the circuit-breaker. CircuitBreakerStateProvider Allows retrieval of the circuit breaker state. CircuitBreakerStrategyOptions The options for circuit breaker resilience strategy. CircuitBreakerStrategyOptions<TResult> The options for circuit breaker resilience strategy. IsolatedCircuitException Exception thrown when a circuit is isolated (held open) by manual override. Structs BreakDurationGeneratorArguments Represents arguments used to generate a dynamic break duration for a circuit breaker. CircuitBreakerPredicateArguments<TResult> Arguments used by ShouldHandle predicate. OnCircuitClosedArguments<TResult> Arguments used by OnClosed event. OnCircuitHalfOpenedArguments Arguments used by OnHalfOpened event. OnCircuitOpenedArguments<TResult> Arguments used by OnOpened event. Enums CircuitState Describes the possible states the circuit of a Circuit Breaker may be in."
  },
  "api/Polly.CircuitBreakerResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.CircuitBreakerResiliencePipelineBuilderExtensions.html",
    "title": "Class CircuitBreakerResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class CircuitBreakerResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Circuit breaker extensions for ResiliencePipelineBuilder. public static class CircuitBreakerResiliencePipelineBuilderExtensions Inheritance object CircuitBreakerResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddCircuitBreaker(ResiliencePipelineBuilder, CircuitBreakerStrategyOptions) Adds circuit breaker to the builder. public static ResiliencePipelineBuilder AddCircuitBreaker(this ResiliencePipelineBuilder builder, CircuitBreakerStrategyOptions options) Parameters builder ResiliencePipelineBuilder The builder instance. options CircuitBreakerStrategyOptions The options instance. Returns ResiliencePipelineBuilder A builder with the circuit breaker added. Remarks See CircuitBreakerStrategyOptions<TResult> for more details about the circuit breaker. If you are discarding the circuit breaker by this call make sure to use CircuitBreakerManualControl and dispose the manual control instance when the circuit breaker is no longer used. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. AddCircuitBreaker<TResult>(ResiliencePipelineBuilder<TResult>, CircuitBreakerStrategyOptions<TResult>) Adds circuit breaker to the builder. public static ResiliencePipelineBuilder<TResult> AddCircuitBreaker<TResult>(this ResiliencePipelineBuilder<TResult> builder, CircuitBreakerStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. options CircuitBreakerStrategyOptions<TResult> The options instance. Returns ResiliencePipelineBuilder<TResult> A builder with the circuit breaker added. Type Parameters TResult The type of result the circuit breaker handles. Remarks See CircuitBreakerStrategyOptions<TResult> for more details about the circuit breaker. If you are discarding the circuit breaker by this call make sure to use CircuitBreakerManualControl and dispose the manual control instance when the circuit breaker is no longer used. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid."
  },
  "api/Polly.DelayBackoffType.html": {
    "href": "api/Polly.DelayBackoffType.html",
    "title": "Enum DelayBackoffType | Polly",
    "keywords": "Enum DelayBackoffType Namespace Polly Assembly Polly.Core.dll The backoff type used by the strategies. public enum DelayBackoffType Fields Constant = 0 The constant backoff type. Exponential = 2 The exponential backoff type with the power of 2. Linear = 1 The linear backoff type."
  },
  "api/Polly.DependencyInjection.AddResiliencePipelineContext-1.html": {
    "href": "api/Polly.DependencyInjection.AddResiliencePipelineContext-1.html",
    "title": "Class AddResiliencePipelineContext<TKey> | Polly",
    "keywords": "Class AddResiliencePipelineContext<TKey> Namespace Polly.DependencyInjection Assembly Polly.Extensions.dll Represents the context for adding a resilience pipeline with the specified key. public sealed class AddResiliencePipelineContext<TKey> where TKey : notnull Type Parameters TKey The type of the key used to identify the resilience pipeline. Inheritance object AddResiliencePipelineContext<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties PipelineKey Gets the pipeline key for the pipeline being created. public TKey PipelineKey { get; } Property Value TKey ServiceProvider Gets the IServiceProvider that provides access to the dependency injection container. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods EnableReloads<TOptions>(string?) Enables dynamic reloading of the resilience pipeline whenever the TOptions options are changed. public void EnableReloads<TOptions>(string? name = null) Parameters name string The named options, if any. Type Parameters TOptions The options type to listen to. Remarks You can decide based on the name to listen for changes in global options or named options. If name is null then the global options are listened to. You can listen for changes from multiple options by calling this method with different TOptions types. GetOptions<TOptions>(string?) Gets the options identified by name. public TOptions GetOptions<TOptions>(string? name = null) Parameters name string The options name, if any. Returns TOptions The options instance. Type Parameters TOptions The options type. Remarks If name is null then the global options are returned. OnPipelineDisposed(Action) Registers a callback that is called when the pipeline instance being configured is disposed. public void OnPipelineDisposed(Action callback) Parameters callback Action The callback delegate."
  },
  "api/Polly.DependencyInjection.AddResiliencePipelinesContext-1.html": {
    "href": "api/Polly.DependencyInjection.AddResiliencePipelinesContext-1.html",
    "title": "Class AddResiliencePipelinesContext<TKey> | Polly",
    "keywords": "Class AddResiliencePipelinesContext<TKey> Namespace Polly.DependencyInjection Assembly Polly.Extensions.dll Represents the context for configuring resilience pipelines with the specified key. public sealed class AddResiliencePipelinesContext<TKey> where TKey : notnull Type Parameters TKey The type of the key used to identify the resilience pipeline. Inheritance object AddResiliencePipelinesContext<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties ServiceProvider Gets the IServiceProvider that provides access to the dependency injection container. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods AddResiliencePipeline(TKey, Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>>) Adds a resilience pipeline to the registry. public void AddResiliencePipeline(TKey key, Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>> An action that configures the resilience pipeline. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables telemetry for the registered resilience pipeline. AddResiliencePipeline<TResult>(TKey, Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>>) Adds a resilience pipeline to the registry. public void AddResiliencePipeline<TResult>(TKey key, Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>> An action that configures the resilience pipeline. Type Parameters TResult The type of result that the resilience pipeline handles. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables telemetry for the registered resilience pipeline."
  },
  "api/Polly.DependencyInjection.html": {
    "href": "api/Polly.DependencyInjection.html",
    "title": "Namespace Polly.DependencyInjection | Polly",
    "keywords": "Namespace Polly.DependencyInjection Classes AddResiliencePipelineContext<TKey> Represents the context for adding a resilience pipeline with the specified key. AddResiliencePipelinesContext<TKey> Represents the context for configuring resilience pipelines with the specified key."
  },
  "api/Polly.ExecutionRejectedException.html": {
    "href": "api/Polly.ExecutionRejectedException.html",
    "title": "Class ExecutionRejectedException | Polly",
    "keywords": "Class ExecutionRejectedException Namespace Polly Assembly Polly.Core.dll Exception thrown when a policy rejects execution of a delegate. More specific exceptions which derive from this type, are generally thrown. public abstract class ExecutionRejectedException : Exception, ISerializable Inheritance object Exception ExecutionRejectedException Implements ISerializable Derived BrokenCircuitException RateLimiterRejectedException TimeoutRejectedException Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ExecutionRejectedException() Initializes a new instance of the ExecutionRejectedException class. protected ExecutionRejectedException() ExecutionRejectedException(string) Initializes a new instance of the ExecutionRejectedException class. protected ExecutionRejectedException(string message) Parameters message string The message that describes the error. ExecutionRejectedException(string, Exception) Initializes a new instance of the ExecutionRejectedException class. protected ExecutionRejectedException(string message, Exception inner) Parameters message string The message that describes the error. inner Exception The inner exception."
  },
  "api/Polly.Fallback.FallbackActionArguments-1.html": {
    "href": "api/Polly.Fallback.FallbackActionArguments-1.html",
    "title": "Struct FallbackActionArguments<TResult> | Polly",
    "keywords": "Struct FallbackActionArguments<TResult> Namespace Polly.Fallback Assembly Polly.Core.dll Arguments used by FallbackAction. public readonly struct FallbackActionArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors FallbackActionArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the FallbackActionArguments<TResult> struct. public FallbackActionArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome that should be handled by the fallback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Fallback.FallbackPredicateArguments-1.html": {
    "href": "api/Polly.Fallback.FallbackPredicateArguments-1.html",
    "title": "Struct FallbackPredicateArguments<TResult> | Polly",
    "keywords": "Struct FallbackPredicateArguments<TResult> Namespace Polly.Fallback Assembly Polly.Core.dll Represents arguments used in fallback handling scenarios. public readonly struct FallbackPredicateArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors FallbackPredicateArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the FallbackPredicateArguments<TResult> struct. public FallbackPredicateArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the user-specified callback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Fallback.FallbackStrategyOptions-1.html": {
    "href": "api/Polly.Fallback.FallbackStrategyOptions-1.html",
    "title": "Class FallbackStrategyOptions<TResult> | Polly",
    "keywords": "Class FallbackStrategyOptions<TResult> Namespace Polly.Fallback Assembly Polly.Core.dll Represents the options for configuring a fallback resilience strategy with a specific result type. public class FallbackStrategyOptions<TResult> : ResilienceStrategyOptions Type Parameters TResult The result type. Inheritance object ResilienceStrategyOptions FallbackStrategyOptions<TResult> Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FallbackStrategyOptions() Initializes a new instance of the FallbackStrategyOptions<TResult> class. public FallbackStrategyOptions() Properties FallbackAction Gets or sets the fallback action to be executed when the ShouldHandle predicate evaluates as true. [Required] public Func<FallbackActionArguments<TResult>, ValueTask<Outcome<TResult>>>? FallbackAction { get; set; } Property Value Func<FallbackActionArguments<TResult>, ValueTask<Outcome<TResult>>> The default value is null. This property is required. OnFallback Gets or sets event delegate that is raised when fallback happens. public Func<OnFallbackArguments<TResult>, ValueTask>? OnFallback { get; set; } Property Value Func<OnFallbackArguments<TResult>, ValueTask> The default value is null instance. ShouldHandle Gets or sets a predicate that determines whether the fallback should be executed for a given outcome. [Required] public Func<FallbackPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } Property Value Func<FallbackPredicateArguments<TResult>, ValueTask<bool>> The default value is a predicate that falls back on any exception except OperationCanceledException. This property is required."
  },
  "api/Polly.Fallback.OnFallbackArguments-1.html": {
    "href": "api/Polly.Fallback.OnFallbackArguments-1.html",
    "title": "Struct OnFallbackArguments<TResult> | Polly",
    "keywords": "Struct OnFallbackArguments<TResult> Namespace Polly.Fallback Assembly Polly.Core.dll Represents arguments used in fallback handling scenarios. public readonly struct OnFallbackArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnFallbackArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the OnFallbackArguments<TResult> struct. public OnFallbackArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome that caused the fallback to be executed. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Fallback.html": {
    "href": "api/Polly.Fallback.html",
    "title": "Namespace Polly.Fallback | Polly",
    "keywords": "Namespace Polly.Fallback Classes FallbackStrategyOptions<TResult> Represents the options for configuring a fallback resilience strategy with a specific result type. Structs FallbackActionArguments<TResult> Arguments used by FallbackAction. FallbackPredicateArguments<TResult> Represents arguments used in fallback handling scenarios. OnFallbackArguments<TResult> Represents arguments used in fallback handling scenarios."
  },
  "api/Polly.FallbackResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.FallbackResiliencePipelineBuilderExtensions.html",
    "title": "Class FallbackResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class FallbackResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for adding fallback to ResiliencePipelineBuilder. public static class FallbackResiliencePipelineBuilderExtensions Inheritance object FallbackResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddFallback<TResult>(ResiliencePipelineBuilder<TResult>, FallbackStrategyOptions<TResult>) Adds a fallback resilience strategy with the provided options to the builder. public static ResiliencePipelineBuilder<TResult> AddFallback<TResult>(this ResiliencePipelineBuilder<TResult> builder, FallbackStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The resilience pipeline builder. options FallbackStrategyOptions<TResult> The options to configure the fallback resilience strategy. Returns ResiliencePipelineBuilder<TResult> The builder instance with the fallback strategy added. Type Parameters TResult The result type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid."
  },
  "api/Polly.Hedging.HedgingActionGeneratorArguments-1.html": {
    "href": "api/Polly.Hedging.HedgingActionGeneratorArguments-1.html",
    "title": "Struct HedgingActionGeneratorArguments<TResult> | Polly",
    "keywords": "Struct HedgingActionGeneratorArguments<TResult> Namespace Polly.Hedging Assembly Polly.Core.dll Represents arguments used in the hedging resilience strategy. public readonly struct HedgingActionGeneratorArguments<TResult> Type Parameters TResult The type of the result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The PrimaryContext represents the context that was received by the hedging strategy and used to execute the primary action. To prevent race conditions, the hedging strategy then clones the primary context into ActionContext and uses it to execute the hedged action. Every hedged action gets its own context that is cloned from the primary. Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors HedgingActionGeneratorArguments(ResilienceContext, ResilienceContext, int, Func<ResilienceContext, ValueTask<Outcome<TResult>>>) Initializes a new instance of the HedgingActionGeneratorArguments<TResult> struct. public HedgingActionGeneratorArguments(ResilienceContext primaryContext, ResilienceContext actionContext, int attemptNumber, Func<ResilienceContext, ValueTask<Outcome<TResult>>> callback) Parameters primaryContext ResilienceContext The primary context received by the hedging strategy. actionContext ResilienceContext The action context cloned from the primary context. attemptNumber int The zero-based hedging attempt number. callback Func<ResilienceContext, ValueTask<Outcome<TResult>>> The callback passed to the hedging strategy. Properties ActionContext Gets the action context that will be used for the hedged action. public ResilienceContext ActionContext { get; } Property Value ResilienceContext Remarks This context is cloned from PrimaryContext. AttemptNumber Gets the zero-based hedging attempt number. public int AttemptNumber { get; } Property Value int Callback Gets the callback passed to the hedging strategy. public Func<ResilienceContext, ValueTask<Outcome<TResult>>> Callback { get; } Property Value Func<ResilienceContext, ValueTask<Outcome<TResult>>> PrimaryContext Gets the primary resilience context as received by the hedging strategy. public ResilienceContext PrimaryContext { get; } Property Value ResilienceContext"
  },
  "api/Polly.Hedging.HedgingDelayGeneratorArguments.html": {
    "href": "api/Polly.Hedging.HedgingDelayGeneratorArguments.html",
    "title": "Struct HedgingDelayGeneratorArguments | Polly",
    "keywords": "Struct HedgingDelayGeneratorArguments Namespace Polly.Hedging Assembly Polly.Core.dll Arguments used by hedging delay generator. public readonly struct HedgingDelayGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors HedgingDelayGeneratorArguments(ResilienceContext, int) Initializes a new instance of the HedgingDelayGeneratorArguments struct. public HedgingDelayGeneratorArguments(ResilienceContext context, int attemptNumber) Parameters context ResilienceContext The context associated with the execution of a user-provided callback. attemptNumber int The zero-based hedging attempt number. Properties AttemptNumber Gets the zero-based hedging attempt number. public int AttemptNumber { get; } Property Value int Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Hedging.HedgingPredicateArguments-1.html": {
    "href": "api/Polly.Hedging.HedgingPredicateArguments-1.html",
    "title": "Struct HedgingPredicateArguments<TResult> | Polly",
    "keywords": "Struct HedgingPredicateArguments<TResult> Namespace Polly.Hedging Assembly Polly.Core.dll Represents arguments used in hedging handling scenarios. public readonly struct HedgingPredicateArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors HedgingPredicateArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the HedgingPredicateArguments<TResult> struct. public HedgingPredicateArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the user-specified callback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Hedging.HedgingStrategyOptions-1.html": {
    "href": "api/Polly.Hedging.HedgingStrategyOptions-1.html",
    "title": "Class HedgingStrategyOptions<TResult> | Polly",
    "keywords": "Class HedgingStrategyOptions<TResult> Namespace Polly.Hedging Assembly Polly.Core.dll Hedging strategy options. public class HedgingStrategyOptions<TResult> : ResilienceStrategyOptions Type Parameters TResult The type of result these hedging options handle. Inheritance object ResilienceStrategyOptions HedgingStrategyOptions<TResult> Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HedgingStrategyOptions() Initializes a new instance of the HedgingStrategyOptions<TResult> class. public HedgingStrategyOptions() Properties ActionGenerator Gets or sets a generator that creates hedged actions. [Required] public Func<HedgingActionGeneratorArguments<TResult>, Func<ValueTask<Outcome<TResult>>>?> ActionGenerator { get; set; } Property Value Func<HedgingActionGeneratorArguments<TResult>, Func<ValueTask<Outcome<TResult>>>> The default generator executes the original callback that was passed to the hedging resilience strategy. This property is required. Delay Gets or sets the maximum waiting time before spawning a new hedged action. public TimeSpan Delay { get; set; } Property Value TimeSpan The default value is 2 seconds. Remarks You can use Zero to create all hedged actions (value of MaxHedgedAttempts) at once or InfiniteTimeSpan to force the hedging strategy to never create new action before the old one is finished. If you want a greater control over hedging delay customization use DelayGenerator. DelayGenerator Gets or sets a generator that generates hedging delays for each hedging action. public Func<HedgingDelayGeneratorArguments, ValueTask<TimeSpan>>? DelayGenerator { get; set; } Property Value Func<HedgingDelayGeneratorArguments, ValueTask<TimeSpan>> The default value is null. Remarks The DelayGenerator takes precedence over Delay. If specified, the Delay is ignored. MaxHedgedAttempts Gets or sets the maximum number of hedged actions to use, in addition to the original action. [Range(1, 10)] public int MaxHedgedAttempts { get; set; } Property Value int The default value is 1. The value must be bigger or equal to 1, and lower or equal to 10. OnHedging Gets or sets the event that is raised when a hedging is performed. public Func<OnHedgingArguments<TResult>, ValueTask>? OnHedging { get; set; } Property Value Func<OnHedgingArguments<TResult>, ValueTask> The default value is null. Remarks The hedging is executed when the current attempt outcome is not successful and the ShouldHandle predicate returns true or when the current attempt did not finish within the Delay. ShouldHandle Gets or sets a predicate that determines whether the hedging should be executed for a given outcome. [Required] public Func<HedgingPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } Property Value Func<HedgingPredicateArguments<TResult>, ValueTask<bool>> The default value is a predicate that hedges on any exception except OperationCanceledException. This property is required."
  },
  "api/Polly.Hedging.OnHedgingArguments-1.html": {
    "href": "api/Polly.Hedging.OnHedgingArguments-1.html",
    "title": "Struct OnHedgingArguments<TResult> | Polly",
    "keywords": "Struct OnHedgingArguments<TResult> Namespace Polly.Hedging Assembly Polly.Core.dll Represents arguments used by the on-hedging event. public readonly struct OnHedgingArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The PrimaryContext represents the context that was received by the hedging strategy and used to execute the primary action. To prevent race conditions, the hedging strategy then clones the primary context into ActionContext and uses it to execute the hedged action. Every hedged action gets its own context that is cloned from the primary. Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnHedgingArguments(ResilienceContext, ResilienceContext, int) Initializes a new instance of the OnHedgingArguments<TResult> struct. public OnHedgingArguments(ResilienceContext primaryContext, ResilienceContext actionContext, int attemptNumber) Parameters primaryContext ResilienceContext The primary context received by the hedging strategy. actionContext ResilienceContext The action context. cloned from the primary context. attemptNumber int The zero-based hedging attempt number. Properties ActionContext Gets the action context that will be used for the hedged action. public ResilienceContext ActionContext { get; } Property Value ResilienceContext Remarks This context is cloned from PrimaryContext. AttemptNumber Gets the zero-based hedging attempt number. public int AttemptNumber { get; } Property Value int PrimaryContext Gets the primary resilience context as received by the hedging strategy. public ResilienceContext PrimaryContext { get; } Property Value ResilienceContext"
  },
  "api/Polly.Hedging.html": {
    "href": "api/Polly.Hedging.html",
    "title": "Namespace Polly.Hedging | Polly",
    "keywords": "Namespace Polly.Hedging Classes HedgingStrategyOptions<TResult> Hedging strategy options. Structs HedgingActionGeneratorArguments<TResult> Represents arguments used in the hedging resilience strategy. HedgingDelayGeneratorArguments Arguments used by hedging delay generator. HedgingPredicateArguments<TResult> Represents arguments used in hedging handling scenarios. OnHedgingArguments<TResult> Represents arguments used by the on-hedging event."
  },
  "api/Polly.HedgingResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.HedgingResiliencePipelineBuilderExtensions.html",
    "title": "Class HedgingResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class HedgingResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for adding hedging to ResiliencePipelineBuilder. public static class HedgingResiliencePipelineBuilderExtensions Inheritance object HedgingResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddHedging<TResult>(ResiliencePipelineBuilder<TResult>, HedgingStrategyOptions<TResult>) Adds a hedging with the provided options to the builder. public static ResiliencePipelineBuilder<TResult> AddHedging<TResult>(this ResiliencePipelineBuilder<TResult> builder, HedgingStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The resilience pipeline builder. options HedgingStrategyOptions<TResult> The options to configure the hedging. Returns ResiliencePipelineBuilder<TResult> The builder instance with the hedging added. Type Parameters TResult The result type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid."
  },
  "api/Polly.Outcome-1.html": {
    "href": "api/Polly.Outcome-1.html",
    "title": "Struct Outcome<TResult> | Polly",
    "keywords": "Struct Outcome<TResult> Namespace Polly Assembly Polly.Core.dll Represents the outcome of an operation which could be a result of type TResult or an exception. public readonly struct Outcome<TResult> Type Parameters TResult The result type of the operation. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Properties Exception Gets the exception that occurred during the operation, if any. public Exception? Exception { get; } Property Value Exception Result Gets the result of the operation, if any. public TResult? Result { get; } Property Value TResult Methods ThrowIfException() Throws an exception if the operation produced an exception. public void ThrowIfException() Remarks If the operation produced a result, this method does nothing. The thrown exception maintains its original stack trace. ToString() Returns the string representation of the outcome. public override string ToString() Returns string The exception message if the outcome is an exception; otherwise, the string representation of the result."
  },
  "api/Polly.Outcome.html": {
    "href": "api/Polly.Outcome.html",
    "title": "Class Outcome | Polly",
    "keywords": "Class Outcome Namespace Polly Assembly Polly.Core.dll Produces instances of Outcome<TResult>. public static class Outcome Inheritance object Outcome Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods FromExceptionAsValueTask<TResult>(Exception) Returns a Outcome<TResult> with the given exception wrapped as ValueTask<TResult>. public static ValueTask<Outcome<TResult>> FromExceptionAsValueTask<TResult>(Exception exception) Parameters exception Exception The exception. Returns ValueTask<Outcome<TResult>> A completed ValueTask<TResult> that produces Outcome<TResult>. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when exception is null. FromException<TResult>(Exception) Returns a Outcome<TResult> with the given exception. public static Outcome<TResult> FromException<TResult>(Exception exception) Parameters exception Exception The exception. Returns Outcome<TResult> An instance of Outcome<TResult>. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when exception is null. FromResultAsValueTask<TResult>(TResult) Returns a Outcome<TResult> with the given value wrapped as ValueTask<TResult>. public static ValueTask<Outcome<TResult>> FromResultAsValueTask<TResult>(TResult value) Parameters value TResult The result value. Returns ValueTask<Outcome<TResult>> A completed ValueTask<TResult> that produces Outcome<TResult>. Type Parameters TResult The type of the result. FromResult<TResult>(TResult?) Returns a Outcome<TResult> with the given value. public static Outcome<TResult> FromResult<TResult>(TResult? value) Parameters value TResult The result value. Returns Outcome<TResult> An instance of Outcome<TResult>. Type Parameters TResult The type of the result."
  },
  "api/Polly.PollyServiceCollectionExtensions.html": {
    "href": "api/Polly.PollyServiceCollectionExtensions.html",
    "title": "Class PollyServiceCollectionExtensions | Polly",
    "keywords": "Class PollyServiceCollectionExtensions Namespace Polly Assembly Polly.Extensions.dll Provides extension methods for registering resilience pipelines using the IServiceCollection. public static class PollyServiceCollectionExtensions Inheritance object PollyServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddResiliencePipelineRegistry<TKey>(IServiceCollection) Adds ResiliencePipelineRegistry<TKey> and ResiliencePipelineProvider<TKey> to the service collection that allows configuring and retrieving resilience pipelines using the TKey key. public static IServiceCollection AddResiliencePipelineRegistry<TKey>(this IServiceCollection services) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. Returns IServiceCollection The updated IServiceCollection with additional services added. Type Parameters TKey The type of the key used to identify the resilience pipeline. Remarks This call enables telemetry for all resilience pipelines created using ResiliencePipelineRegistry<TKey>. Exceptions ArgumentNullException Thrown when services is null. AddResiliencePipelineRegistry<TKey>(IServiceCollection, Action<ResiliencePipelineRegistryOptions<TKey>>) Adds ResiliencePipelineRegistry<TKey> and ResiliencePipelineProvider<TKey> to the service collection that allows configuring and retrieving resilience pipelines using the TKey key. public static IServiceCollection AddResiliencePipelineRegistry<TKey>(this IServiceCollection services, Action<ResiliencePipelineRegistryOptions<TKey>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. configure Action<ResiliencePipelineRegistryOptions<TKey>> The action that configures the ResiliencePipelineRegistryOptions<TKey> that are used by the registry. Returns IServiceCollection The updated IServiceCollection with additional services added. Type Parameters TKey The type of the key used to identify the resilience pipeline. Remarks This call enables telemetry for all resilience pipelines created using ResiliencePipelineRegistry<TKey>. Exceptions ArgumentNullException Thrown when services is null. AddResiliencePipeline<TKey>(IServiceCollection, TKey, Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>>) Adds a resilience pipeline to service collection. public static IServiceCollection AddResiliencePipeline<TKey>(this IServiceCollection services, TKey key, Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>> An action that configures the resilience pipeline. Returns IServiceCollection The updated IServiceCollection with the registered resilience pipeline. Type Parameters TKey The type of the key used to identify the resilience pipeline. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null. AddResiliencePipeline<TKey>(IServiceCollection, TKey, Action<ResiliencePipelineBuilder>) Adds a resilience pipeline to service collection. public static IServiceCollection AddResiliencePipeline<TKey>(this IServiceCollection services, TKey key, Action<ResiliencePipelineBuilder> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder> An action that configures the resilience pipeline. Returns IServiceCollection The updated IServiceCollection with the registered resilience pipeline. Type Parameters TKey The type of the key used to identify the resilience pipeline. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null. AddResiliencePipeline<TKey, TResult>(IServiceCollection, TKey, Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>>) Adds a resilience pipeline that handles TResult to service collection. public static IServiceCollection AddResiliencePipeline<TKey, TResult>(this IServiceCollection services, TKey key, Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>> An action that configures the resilience pipeline. Returns IServiceCollection The updated IServiceCollection with the registered resilience pipeline. Type Parameters TKey The type of the key used to identify the resilience pipeline. TResult The type of result that the resilience pipeline handles. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null. AddResiliencePipeline<TKey, TResult>(IServiceCollection, TKey, Action<ResiliencePipelineBuilder<TResult>>) Adds a resilience pipeline that handles TResult to service collection. public static IServiceCollection AddResiliencePipeline<TKey, TResult>(this IServiceCollection services, TKey key, Action<ResiliencePipelineBuilder<TResult>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>> An action that configures the resilience pipeline. Returns IServiceCollection The updated IServiceCollection with the registered resilience pipeline. Type Parameters TKey The type of the key used to identify the resilience pipeline. TResult The type of result that the resilience pipeline handles. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null. AddResiliencePipelines<TKey>(IServiceCollection, Action<AddResiliencePipelinesContext<TKey>>) Allows deferred addition of one or more resilience pipelines to the service collection. public static IServiceCollection AddResiliencePipelines<TKey>(this IServiceCollection services, Action<AddResiliencePipelinesContext<TKey>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add resilience pipelines to. configure Action<AddResiliencePipelinesContext<TKey>> An action that allows configuration of resilience pipelines. Returns IServiceCollection The updated IServiceCollection with the addition configuration added. Type Parameters TKey The type of the key used to identify the resilience pipelines. Remarks This method can be useful if you want to add resilience pipelines as late as possible, e.g. to allow other services / configuration to be available before providing the key. You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null."
  },
  "api/Polly.PredicateBuilder-1.html": {
    "href": "api/Polly.PredicateBuilder-1.html",
    "title": "Class PredicateBuilder<TResult> | Polly",
    "keywords": "Class PredicateBuilder<TResult> Namespace Polly Assembly Polly.Core.dll Defines a builder for creating predicates for TResult and Exception combinations. public class PredicateBuilder<TResult> Type Parameters TResult The type of the result. Inheritance object PredicateBuilder<TResult> Derived PredicateBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Build() Builds the predicate. public Predicate<Outcome<TResult>> Build() Returns Predicate<Outcome<TResult>> An instance of predicate delegate. Remarks The returned predicate will return true if any of the configured predicates return true. Please be aware of the performance penalty if you register too many predicates with this builder. In such case, it's better to create your own predicate manually as a delegate. Exceptions InvalidOperationException Thrown when no predicates were configured using this builder. HandleInner<TException>() Adds a predicate for handling inner exceptions of the specified type. public PredicateBuilder<TResult> HandleInner<TException>() where TException : Exception Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Type Parameters TException The type of the inner exception to handle. HandleInner<TException>(Func<TException, bool>) Adds a predicate for handling inner exceptions of the specified type. public PredicateBuilder<TResult> HandleInner<TException>(Func<TException, bool> predicate) where TException : Exception Parameters predicate Func<TException, bool> The predicate function to use for handling the inner exception. Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Type Parameters TException The type of the inner exception to handle. Exceptions ArgumentNullException Thrown when the predicate is null. HandleResult(Func<TResult, bool>) Adds a predicate for handling results. public PredicateBuilder<TResult> HandleResult(Func<TResult, bool> predicate) Parameters predicate Func<TResult, bool> The predicate function to use for handling the result. Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. HandleResult(TResult, IEqualityComparer<TResult>?) Adds a predicate for handling results with a specific value. public PredicateBuilder<TResult> HandleResult(TResult result, IEqualityComparer<TResult>? comparer = null) Parameters result TResult The result value to handle. comparer IEqualityComparer<TResult> The comparer to use for comparing results. If null , the default comparer is used. Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Handle<TException>() Adds a predicate for handling exceptions of the specified type. public PredicateBuilder<TResult> Handle<TException>() where TException : Exception Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Type Parameters TException The type of the exception to handle. Handle<TException>(Func<TException, bool>) Adds a predicate for handling exceptions of the specified type. public PredicateBuilder<TResult> Handle<TException>(Func<TException, bool> predicate) where TException : Exception Parameters predicate Func<TException, bool> The predicate function to use for handling the exception. Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Type Parameters TException The type of the exception to handle. Exceptions ArgumentNullException Thrown when the predicate is null."
  },
  "api/Polly.PredicateBuilder.html": {
    "href": "api/Polly.PredicateBuilder.html",
    "title": "Class PredicateBuilder | Polly",
    "keywords": "Class PredicateBuilder Namespace Polly Assembly Polly.Core.dll Defines a builder for creating exception predicates. public sealed class PredicateBuilder : PredicateBuilder<object> Inheritance object PredicateBuilder<object> PredicateBuilder Inherited Members PredicateBuilder<object>.Handle<TException>() PredicateBuilder<object>.Handle<TException>(Func<TException, bool>) PredicateBuilder<object>.HandleInner<TException>() PredicateBuilder<object>.HandleInner<TException>(Func<TException, bool>) PredicateBuilder<object>.HandleResult(Func<object, bool>) PredicateBuilder<object>.HandleResult(object, IEqualityComparer<object>) PredicateBuilder<object>.Build() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Polly.PredicateResult.html": {
    "href": "api/Polly.PredicateResult.html",
    "title": "Class PredicateResult | Polly",
    "keywords": "Class PredicateResult Namespace Polly Assembly Polly.Core.dll Class that represents the results that can be used in predicates. public static class PredicateResult Inheritance object PredicateResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods False() Returns a finished ValueTask<TResult> that returns false value. public static ValueTask<bool> False() Returns ValueTask<bool> A new instance of finished ValueTask<TResult>. True() Returns a finished ValueTask<TResult> that returns true value. public static ValueTask<bool> True() Returns ValueTask<bool> A new instance of finished ValueTask<TResult>."
  },
  "api/Polly.RateLimiterResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.RateLimiterResiliencePipelineBuilderExtensions.html",
    "title": "Class RateLimiterResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class RateLimiterResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.RateLimiting.dll Extensions for adding rate limiting to ResiliencePipelineBuilder. public static class RateLimiterResiliencePipelineBuilderExtensions Inheritance object RateLimiterResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddConcurrencyLimiter<TBuilder>(TBuilder, int, int) Adds the concurrency limiter. public static TBuilder AddConcurrencyLimiter<TBuilder>(this TBuilder builder, int permitLimit, int queueLimit = 0) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. permitLimit int Maximum number of permits that can be leased concurrently. queueLimit int Maximum number of permits that can be queued concurrently. Returns TBuilder The builder instance with the concurrency limiter added. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder is null. ValidationException Thrown when the options constructed from the arguments are invalid. ArgumentException Thrown when permitLimit or queueLimit is invalid. AddConcurrencyLimiter<TBuilder>(TBuilder, ConcurrencyLimiterOptions) Adds the concurrency limiter. public static TBuilder AddConcurrencyLimiter<TBuilder>(this TBuilder builder, ConcurrencyLimiterOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options ConcurrencyLimiterOptions The concurrency limiter options. Returns TBuilder The builder instance with the concurrency limiter added. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when the options constructed from the arguments are invalid. ArgumentException Thrown when options are invalid. AddRateLimiter<TBuilder>(TBuilder, RateLimiterStrategyOptions) Adds the rate limiter. public static TBuilder AddRateLimiter<TBuilder>(this TBuilder builder, RateLimiterStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options RateLimiterStrategyOptions The rate limiter options. Returns TBuilder The builder instance with the rate limiter added. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. ArgumentException Thrown when DefaultRateLimiterOptions for options are invalid. AddRateLimiter<TBuilder>(TBuilder, RateLimiter) Adds the rate limiter. public static TBuilder AddRateLimiter<TBuilder>(this TBuilder builder, RateLimiter limiter) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. limiter RateLimiter The rate limiter to use. Returns TBuilder The builder instance with the rate limiter added. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or limiter is null. ValidationException Thrown when the options constructed from the arguments are invalid."
  },
  "api/Polly.RateLimiting.OnRateLimiterRejectedArguments.html": {
    "href": "api/Polly.RateLimiting.OnRateLimiterRejectedArguments.html",
    "title": "Struct OnRateLimiterRejectedArguments | Polly",
    "keywords": "Struct OnRateLimiterRejectedArguments Namespace Polly.RateLimiting Assembly Polly.RateLimiting.dll The arguments used by the OnRejected. public readonly struct OnRateLimiterRejectedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnRateLimiterRejectedArguments(ResilienceContext, RateLimitLease) Initializes a new instance of the OnRateLimiterRejectedArguments struct. public OnRateLimiterRejectedArguments(ResilienceContext context, RateLimitLease lease) Parameters context ResilienceContext The context associated with the execution of a user-provided callback. lease RateLimitLease The lease that has no permits and was rejected by the rate limiter. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext Lease Gets the lease that has no permits and was rejected by the rate limiter. public RateLimitLease Lease { get; } Property Value RateLimitLease"
  },
  "api/Polly.RateLimiting.RateLimiterArguments.html": {
    "href": "api/Polly.RateLimiting.RateLimiterArguments.html",
    "title": "Struct RateLimiterArguments | Polly",
    "keywords": "Struct RateLimiterArguments Namespace Polly.RateLimiting Assembly Polly.RateLimiting.dll The arguments used by the RateLimiter delegate. public readonly struct RateLimiterArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors RateLimiterArguments(ResilienceContext) Initializes a new instance of the RateLimiterArguments struct. public RateLimiterArguments(ResilienceContext context) Parameters context ResilienceContext Context associated with the execution of a user-provided callback. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.RateLimiting.RateLimiterRejectedException.html": {
    "href": "api/Polly.RateLimiting.RateLimiterRejectedException.html",
    "title": "Class RateLimiterRejectedException | Polly",
    "keywords": "Class RateLimiterRejectedException Namespace Polly.RateLimiting Assembly Polly.RateLimiting.dll Exception thrown when a rate limiter rejects an execution. public sealed class RateLimiterRejectedException : ExecutionRejectedException, ISerializable Inheritance object Exception ExecutionRejectedException RateLimiterRejectedException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite object.Equals(object) object.Equals(object, object) object.GetHashCode() object.ReferenceEquals(object, object) Constructors RateLimiterRejectedException() Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException() RateLimiterRejectedException(string) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(string message) Parameters message string The message that describes the error. RateLimiterRejectedException(string, Exception) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(string message, Exception inner) Parameters message string The message that describes the error. inner Exception The inner exception. RateLimiterRejectedException(string, TimeSpan) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(string message, TimeSpan retryAfter) Parameters message string The message that describes the error. retryAfter TimeSpan The retry after value. RateLimiterRejectedException(string, TimeSpan, Exception) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(string message, TimeSpan retryAfter, Exception inner) Parameters message string The message that describes the error. retryAfter TimeSpan The retry after value. inner Exception The inner exception. RateLimiterRejectedException(TimeSpan) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(TimeSpan retryAfter) Parameters retryAfter TimeSpan The retry after value. Properties RetryAfter Gets the amount of time to wait before retrying again. public TimeSpan? RetryAfter { get; } Property Value TimeSpan? Remarks This value was retrieved from the RateLimitLease by reading the RetryAfter. Defaults to null."
  },
  "api/Polly.RateLimiting.RateLimiterStrategyOptions.html": {
    "href": "api/Polly.RateLimiting.RateLimiterStrategyOptions.html",
    "title": "Class RateLimiterStrategyOptions | Polly",
    "keywords": "Class RateLimiterStrategyOptions Namespace Polly.RateLimiting Assembly Polly.RateLimiting.dll Options for the rate limiter strategy. public class RateLimiterStrategyOptions : ResilienceStrategyOptions Inheritance object ResilienceStrategyOptions RateLimiterStrategyOptions Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RateLimiterStrategyOptions() Initializes a new instance of the RateLimiterStrategyOptions class. public RateLimiterStrategyOptions() Properties DefaultRateLimiterOptions Gets or sets the default rate limiter options. [Required] public ConcurrencyLimiterOptions DefaultRateLimiterOptions { get; set; } Property Value ConcurrencyLimiterOptions Remarks The options for the default limiter that will be used when RateLimiter is null. PermitLimit defaults to 1000. QueueLimit defaults to 0. OnRejected Gets or sets an event that is raised when the execution of user-provided callback is rejected by the rate limiter. public Func<OnRateLimiterRejectedArguments, ValueTask>? OnRejected { get; set; } Property Value Func<OnRateLimiterRejectedArguments, ValueTask> The default value is null. RateLimiter Gets or sets a rate limiter delegate that produces RateLimitLease. public Func<RateLimiterArguments, ValueTask<RateLimitLease>>? RateLimiter { get; set; } Property Value Func<RateLimiterArguments, ValueTask<RateLimitLease>> The default value is null. If this property is null, then the strategy will use a ConcurrencyLimiter created using DefaultRateLimiterOptions."
  },
  "api/Polly.RateLimiting.html": {
    "href": "api/Polly.RateLimiting.html",
    "title": "Namespace Polly.RateLimiting | Polly",
    "keywords": "Namespace Polly.RateLimiting Classes RateLimiterRejectedException Exception thrown when a rate limiter rejects an execution. RateLimiterStrategyOptions Options for the rate limiter strategy. Structs OnRateLimiterRejectedArguments The arguments used by the OnRejected. RateLimiterArguments The arguments used by the RateLimiter delegate."
  },
  "api/Polly.Registry.ConfigureBuilderContext-1.html": {
    "href": "api/Polly.Registry.ConfigureBuilderContext-1.html",
    "title": "Class ConfigureBuilderContext<TKey> | Polly",
    "keywords": "Class ConfigureBuilderContext<TKey> Namespace Polly.Registry Assembly Polly.Core.dll The context used by ResiliencePipelineRegistry<TKey>. public class ConfigureBuilderContext<TKey> where TKey : notnull Type Parameters TKey The type of the key. Inheritance object ConfigureBuilderContext<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods ConfigureBuilderContextExtensions.EnableReloads<TKey, TOptions>(ConfigureBuilderContext<TKey>, IOptionsMonitor<TOptions>, string?) Properties PipelineKey Gets the pipeline key for the pipeline being created. public TKey PipelineKey { get; } Property Value TKey Methods AddReloadToken(CancellationToken) Reloads the pipeline when cancellationToken is canceled. public void AddReloadToken(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken The cancellation token that triggers the pipeline reload when cancelled. Remarks You can add multiple reload tokens to the context. Non-cancelable or already canceled tokens are ignored. OnPipelineDisposed(Action) Registers a callback that is called when the pipeline instance being configured is disposed. public void OnPipelineDisposed(Action callback) Parameters callback Action The callback delegate."
  },
  "api/Polly.Registry.ConfigureBuilderContextExtensions.html": {
    "href": "api/Polly.Registry.ConfigureBuilderContextExtensions.html",
    "title": "Class ConfigureBuilderContextExtensions | Polly",
    "keywords": "Class ConfigureBuilderContextExtensions Namespace Polly.Registry Assembly Polly.Extensions.dll Extensions for ConfigureBuilderContext<TKey>. public static class ConfigureBuilderContextExtensions Inheritance object ConfigureBuilderContextExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods EnableReloads<TKey, TOptions>(ConfigureBuilderContext<TKey>, IOptionsMonitor<TOptions>, string?) Enables dynamic reloading of the resilience pipeline whenever the TOptions options are changed. public static void EnableReloads<TKey, TOptions>(this ConfigureBuilderContext<TKey> context, IOptionsMonitor<TOptions> optionsMonitor, string? name = null) where TKey : notnull Parameters context ConfigureBuilderContext<TKey> The builder context. optionsMonitor IOptionsMonitor<TOptions> The options monitor. name string The named options, if any. Type Parameters TKey The type of the key used to identify the resilience pipeline. TOptions The options type to listen to. Remarks You can decide based on the name to listen for changes in global options or named options. If name is null then the global options are listened to. You can listen for changes from multiple options by calling this method with different TOptions types."
  },
  "api/Polly.Registry.ResiliencePipelineProvider-1.html": {
    "href": "api/Polly.Registry.ResiliencePipelineProvider-1.html",
    "title": "Class ResiliencePipelineProvider<TKey> | Polly",
    "keywords": "Class ResiliencePipelineProvider<TKey> Namespace Polly.Registry Assembly Polly.Core.dll Represents a provider for resilience pipelines that are accessible by TKey. public abstract class ResiliencePipelineProvider<TKey> where TKey : notnull Type Parameters TKey The type of the key. Inheritance object ResiliencePipelineProvider<TKey> Derived ResiliencePipelineRegistry<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetPipeline(TKey) Retrieves a resilience pipeline from the provider using the specified key. public virtual ResiliencePipeline GetPipeline(TKey key) Parameters key TKey The key used to identify the resilience pipeline. Returns ResiliencePipeline The resilience pipeline associated with the specified key. Exceptions KeyNotFoundException Thrown when no resilience pipeline is found for the specified key. GetPipeline<TResult>(TKey) Retrieves a generic resilience pipeline from the provider using the specified key. public virtual ResiliencePipeline<TResult> GetPipeline<TResult>(TKey key) Parameters key TKey The key used to identify the resilience pipeline. Returns ResiliencePipeline<TResult> The resilience pipeline associated with the specified key. Type Parameters TResult The type of result that the resilience pipeline handles. Exceptions KeyNotFoundException Thrown when no resilience pipeline is found for the specified key. TryGetPipeline(TKey, out ResiliencePipeline?) Tries to get a resilience pipeline from the provider using the specified key. public abstract bool TryGetPipeline(TKey key, out ResiliencePipeline? pipeline) Parameters key TKey The key used to identify the resilience pipeline. pipeline ResiliencePipeline The output resilience pipeline if found, null otherwise. Returns bool true if the pipeline was found, false otherwise. TryGetPipeline<TResult>(TKey, out ResiliencePipeline<TResult>?) Tries to get a generic resilience pipeline from the provider using the specified key. public abstract bool TryGetPipeline<TResult>(TKey key, out ResiliencePipeline<TResult>? pipeline) Parameters key TKey The key used to identify the resilience pipeline. pipeline ResiliencePipeline<TResult> The output resilience pipeline if found, null otherwise. Returns bool true if the pipeline was found, false otherwise. Type Parameters TResult The type of result that the resilience pipeline handles."
  },
  "api/Polly.Registry.ResiliencePipelineRegistry-1.html": {
    "href": "api/Polly.Registry.ResiliencePipelineRegistry-1.html",
    "title": "Class ResiliencePipelineRegistry<TKey> | Polly",
    "keywords": "Class ResiliencePipelineRegistry<TKey> Namespace Polly.Registry Assembly Polly.Core.dll Represents a registry of resilience pipelines and builders that are accessible by TKey. public sealed class ResiliencePipelineRegistry<TKey> : ResiliencePipelineProvider<TKey>, IDisposable, IAsyncDisposable where TKey : notnull Type Parameters TKey The type of the key. Inheritance object ResiliencePipelineProvider<TKey> ResiliencePipelineRegistry<TKey> Implements IDisposable IAsyncDisposable Inherited Members ResiliencePipelineProvider<TKey>.GetPipeline(TKey) ResiliencePipelineProvider<TKey>.GetPipeline<TResult>(TKey) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks This class provides a way to organize and manage multiple resilience pipelines using keys of type TKey. Additionally, it allows registration of callbacks that configure the pipeline using ResiliencePipelineBuilder. These callbacks are called when the resilience pipeline is not yet cached and it's retrieved for the first time. Constructors ResiliencePipelineRegistry() Initializes a new instance of the ResiliencePipelineRegistry<TKey> class with the default comparer. public ResiliencePipelineRegistry() ResiliencePipelineRegistry(ResiliencePipelineRegistryOptions<TKey>) Initializes a new instance of the ResiliencePipelineRegistry<TKey> class with a custom builder factory and comparer. public ResiliencePipelineRegistry(ResiliencePipelineRegistryOptions<TKey> options) Parameters options ResiliencePipelineRegistryOptions<TKey> The registry options. Exceptions ValidationException Thrown when options are invalid. ArgumentNullException Thrown when options are null. Methods Dispose() Disposes all resources that are held by the resilience pipelines created by this builder. public void Dispose() Remarks After the disposal, all resilience pipelines still used outside of the builder are disposed and cannot be used anymore. DisposeAsync() Disposes all resources that are held by the resilience pipelines created by this builder. public ValueTask DisposeAsync() Returns ValueTask Returns a task that represents the asynchronous dispose operation. Remarks After the disposal, all resilience pipelines still used outside of the builder are disposed and cannot be used anymore. GetOrAddPipeline(TKey, Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>>) Gets existing pipeline or creates a new one using the configure callback. public ResiliencePipeline GetOrAddPipeline(TKey key, Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>> The callback that configures the pipeline builder. Returns ResiliencePipeline An instance of pipeline. Exceptions ObjectDisposedException Thrown when the registry is already disposed. GetOrAddPipeline(TKey, Action<ResiliencePipelineBuilder>) Gets existing pipeline or creates a new one using the configure callback. public ResiliencePipeline GetOrAddPipeline(TKey key, Action<ResiliencePipelineBuilder> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder> The callback that configures the pipeline builder. Returns ResiliencePipeline An instance of pipeline. Exceptions ObjectDisposedException Thrown when the registry is already disposed. GetOrAddPipeline<TResult>(TKey, Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>>) Gets existing pipeline or creates a new one using the configure callback. public ResiliencePipeline<TResult> GetOrAddPipeline<TResult>(TKey key, Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>> The callback that configures the pipeline builder. Returns ResiliencePipeline<TResult> An instance of pipeline. Type Parameters TResult The type of result that the resilience pipeline handles. Exceptions ObjectDisposedException Thrown when the registry is already disposed. GetOrAddPipeline<TResult>(TKey, Action<ResiliencePipelineBuilder<TResult>>) Gets existing pipeline or creates a new one using the configure callback. public ResiliencePipeline<TResult> GetOrAddPipeline<TResult>(TKey key, Action<ResiliencePipelineBuilder<TResult>> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>> The callback that configures the pipeline builder. Returns ResiliencePipeline<TResult> An instance of pipeline. Type Parameters TResult The type of result that the resilience pipeline handles. Exceptions ObjectDisposedException Thrown when the registry is already disposed. TryAddBuilder(TKey, Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>>) Tries to add a resilience pipeline builder to the registry. public bool TryAddBuilder(TKey key, Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>> configure) Parameters key TKey The key used to identify the pipeline builder. configure Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>> The action that configures the resilience pipeline builder. Returns bool true if the builder was added successfully, false otherwise. Remarks Use this method when you want to create the pipeline on-demand when it's first accessed. Exceptions ArgumentNullException Thrown when configure is null. ObjectDisposedException Thrown when the registry is already disposed. TryAddBuilder<TResult>(TKey, Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>>) Tries to add a generic resilience pipeline builder to the registry. public bool TryAddBuilder<TResult>(TKey key, Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>> configure) Parameters key TKey The key used to identify the pipeline builder. configure Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>> The action that configures the resilience pipeline builder. Returns bool true if the builder was added successfully, false otherwise. Type Parameters TResult The type of result that the resilience pipeline handles. Remarks Use this method when you want to create the pipeline on-demand when it's first accessed. Exceptions ArgumentNullException Thrown when configure is null. ObjectDisposedException Thrown when the registry is already disposed. TryGetPipeline(TKey, out ResiliencePipeline?) Tries to get a resilience pipeline from the provider using the specified key. public override bool TryGetPipeline(TKey key, out ResiliencePipeline? pipeline) Parameters key TKey The key used to identify the resilience pipeline. pipeline ResiliencePipeline The output resilience pipeline if found, null otherwise. Returns bool true if the pipeline was found, false otherwise. TryGetPipeline<TResult>(TKey, out ResiliencePipeline<TResult>?) Tries to get a generic resilience pipeline from the provider using the specified key. public override bool TryGetPipeline<TResult>(TKey key, out ResiliencePipeline<TResult>? pipeline) Parameters key TKey The key used to identify the resilience pipeline. pipeline ResiliencePipeline<TResult> The output resilience pipeline if found, null otherwise. Returns bool true if the pipeline was found, false otherwise. Type Parameters TResult The type of result that the resilience pipeline handles."
  },
  "api/Polly.Registry.ResiliencePipelineRegistryOptions-1.html": {
    "href": "api/Polly.Registry.ResiliencePipelineRegistryOptions-1.html",
    "title": "Class ResiliencePipelineRegistryOptions<TKey> | Polly",
    "keywords": "Class ResiliencePipelineRegistryOptions<TKey> Namespace Polly.Registry Assembly Polly.Core.dll An options class used by ResiliencePipelineRegistry<TKey>. public class ResiliencePipelineRegistryOptions<TKey> Type Parameters TKey The type of the key used by the registry. Inheritance object ResiliencePipelineRegistryOptions<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties BuilderComparer Gets or sets the comparer that is used by the registry to retrieve the resilience pipeline builders. [Required] public IEqualityComparer<TKey> BuilderComparer { get; set; } Property Value IEqualityComparer<TKey> The default value is Default. BuilderFactory Gets or sets the factory method that creates instances of ResiliencePipelineBuilder. [Required] public Func<ResiliencePipelineBuilder> BuilderFactory { get; set; } Property Value Func<ResiliencePipelineBuilder> The default value is a function that creates a new instance of ResiliencePipelineBuilder using the default constructor. BuilderNameFormatter Gets or sets the formatter that is used by the registry to format the TKey to a string that represents the builder name. [Required] public Func<TKey, string> BuilderNameFormatter { get; set; } Property Value Func<TKey, string> The default value is a formatter that formats the keys using the ToString() method. Remarks Use custom formatter for composite keys in case you want to have different metric values for a builder and strategy key. In general, pipelines can have the same builder name and different pipeline keys. InstanceNameFormatter Gets or sets the formatter that is used by the registry to format the TKey to a string that represents the instance name of the builder. public Func<TKey, string>? InstanceNameFormatter { get; set; } Property Value Func<TKey, string> The default value is null. Remarks Use custom formatter for composite keys in case you want to have different metric values for a builder and instance key. In general, pipelines can have the same builder name and different instance names. PipelineComparer Gets or sets the comparer that is used by the registry to retrieve the resilience pipelines. [Required] public IEqualityComparer<TKey> PipelineComparer { get; set; } Property Value IEqualityComparer<TKey> The default value is Default."
  },
  "api/Polly.Registry.html": {
    "href": "api/Polly.Registry.html",
    "title": "Namespace Polly.Registry | Polly",
    "keywords": "Namespace Polly.Registry Classes ConfigureBuilderContextExtensions Extensions for ConfigureBuilderContext<TKey>. ConfigureBuilderContext<TKey> The context used by ResiliencePipelineRegistry<TKey>. ResiliencePipelineProvider<TKey> Represents a provider for resilience pipelines that are accessible by TKey. ResiliencePipelineRegistryOptions<TKey> An options class used by ResiliencePipelineRegistry<TKey>. ResiliencePipelineRegistry<TKey> Represents a registry of resilience pipelines and builders that are accessible by TKey."
  },
  "api/Polly.ResilienceContext.html": {
    "href": "api/Polly.ResilienceContext.html",
    "title": "Class ResilienceContext | Polly",
    "keywords": "Class ResilienceContext Namespace Polly Assembly Polly.Core.dll A context assigned to a single execution of ResiliencePipeline. It is created manually or automatically when the user calls the various extensions on top of ResiliencePipeline. After every execution the context should be discarded and returned to the pool. public sealed class ResilienceContext Inheritance object ResilienceContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Do not re-use an instance of ResilienceContext across more than one execution. The ResilienceContext is retrieved from the pool by calling the Get(CancellationToken) method. After you are done with it you should return it to the pool by calling the Return(ResilienceContext) method. Properties CancellationToken Gets the CancellationToken associated with the execution. public CancellationToken CancellationToken { get; } Property Value CancellationToken ContinueOnCapturedContext Gets a value indicating whether the execution should continue on the captured context. public bool ContinueOnCapturedContext { get; } Property Value bool OperationKey Gets a key unique to the call site of the current execution. public string? OperationKey { get; } Property Value string The default value is null. Remarks Resilience context instances are commonly reused across multiple call sites. Set an OperationKey so that logging and metrics can distinguish usages of policy instances at different call sites. The operation key value should have a low cardinality (i.e. do not assign values such as Guid to this property). Properties Gets the custom properties attached to the context. public ResilienceProperties Properties { get; } Property Value ResilienceProperties"
  },
  "api/Polly.ResilienceContextCreationArguments.html": {
    "href": "api/Polly.ResilienceContextCreationArguments.html",
    "title": "Struct ResilienceContextCreationArguments | Polly",
    "keywords": "Struct ResilienceContextCreationArguments Namespace Polly Assembly Polly.Core.dll Arguments used by the ResilienceContextPool when creating ResilienceContext. public readonly struct ResilienceContextCreationArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ResilienceContextCreationArguments(string?, bool?, CancellationToken) Initializes a new instance of the ResilienceContextCreationArguments struct. public ResilienceContextCreationArguments(string? operationKey, bool? continueOnCapturedContext, CancellationToken cancellationToken) Parameters operationKey string The operation key, if any. continueOnCapturedContext bool? Value indicating whether to continue on captured context. cancellationToken CancellationToken The cancellation token. Properties CancellationToken Gets the cancellation token. public CancellationToken CancellationToken { get; } Property Value CancellationToken ContinueOnCapturedContext Gets the value indicating whether to continue on captured context, if any. public bool? ContinueOnCapturedContext { get; } Property Value bool? OperationKey Gets the operation key, if any. public string? OperationKey { get; } Property Value string"
  },
  "api/Polly.ResilienceContextPool.html": {
    "href": "api/Polly.ResilienceContextPool.html",
    "title": "Class ResilienceContextPool | Polly",
    "keywords": "Class ResilienceContextPool Namespace Polly Assembly Polly.Core.dll The pool of ResilienceContext instances. public abstract class ResilienceContextPool Inheritance object ResilienceContextPool Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Shared Gets the shared pool instance. public static ResilienceContextPool Shared { get; } Property Value ResilienceContextPool Methods Get(ResilienceContextCreationArguments) Gets a ResilienceContext instance from the pool. public abstract ResilienceContext Get(ResilienceContextCreationArguments arguments) Parameters arguments ResilienceContextCreationArguments The creation arguments. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Get(bool, CancellationToken) Gets a ResilienceContext instance from the pool. public ResilienceContext Get(bool continueOnCapturedContext, CancellationToken cancellationToken = default) Parameters continueOnCapturedContext bool Value indicating whether to continue on captured context. cancellationToken CancellationToken The cancellation token. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Get(string?, bool?, CancellationToken) Gets a ResilienceContext instance from the pool. public ResilienceContext Get(string? operationKey, bool? continueOnCapturedContext, CancellationToken cancellationToken = default) Parameters operationKey string An operation key associated with the context. continueOnCapturedContext bool? Value indicating whether to continue on captured context. cancellationToken CancellationToken The cancellation token. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Get(string?, CancellationToken) Gets a ResilienceContext instance from the pool. public ResilienceContext Get(string? operationKey, CancellationToken cancellationToken = default) Parameters operationKey string An operation key associated with the context. cancellationToken CancellationToken The cancellation token. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Get(CancellationToken) Gets a ResilienceContext instance from the pool. public ResilienceContext Get(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken The cancellation token. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Return(ResilienceContext) Returns a context back to the pool. public abstract void Return(ResilienceContext context) Parameters context ResilienceContext The context instance. Exceptions ArgumentNullException Thrown when context is null."
  },
  "api/Polly.ResiliencePipeline-1.html": {
    "href": "api/Polly.ResiliencePipeline-1.html",
    "title": "Class ResiliencePipeline<T> | Polly",
    "keywords": "Class ResiliencePipeline<T> Namespace Polly Assembly Polly.Core.dll Resilience pipeline is used to execute the user-provided callbacks. public sealed class ResiliencePipeline<T> Type Parameters T The type of result this pipeline supports. Inheritance object ResiliencePipeline<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods ResiliencePipelineExtensions.GetPipelineDescriptor<TResult>(ResiliencePipeline<TResult>) Remarks Resilience pipeline supports various types of callbacks of T result type and provides a unified way to execute them. This includes overloads for synchronous and asynchronous callbacks. Fields Empty Resilience pipeline that executes the user-provided callback without any additional logic. public static readonly ResiliencePipeline<T> Empty Field Value ResiliencePipeline<T> Methods ExecuteAsync<TResult>(Func<ResilienceContext, ValueTask<TResult>>, ResilienceContext) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult>(Func<ResilienceContext, ValueTask<TResult>> callback, ResilienceContext context) where TResult : T Parameters callback Func<ResilienceContext, ValueTask<TResult>> The user-provided callback. context ResilienceContext The context associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TResult>(Func<CancellationToken, ValueTask<TResult>>, CancellationToken) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult>(Func<CancellationToken, ValueTask<TResult>> callback, CancellationToken cancellationToken = default) where TResult : T Parameters callback Func<CancellationToken, ValueTask<TResult>> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<TResult>>, ResilienceContext, TState) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<TResult>> callback, ResilienceContext context, TState state) where TResult : T Parameters callback Func<ResilienceContext, TState, ValueTask<TResult>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TResult, TState>(Func<TState, CancellationToken, ValueTask<TResult>>, TState, CancellationToken) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult, TState>(Func<TState, CancellationToken, ValueTask<TResult>> callback, TState state, CancellationToken cancellationToken = default) where TResult : T Parameters callback Func<TState, CancellationToken, ValueTask<TResult>> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteOutcomeAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) Executes the specified outcome-based callback. public ValueTask<Outcome<TResult>> ExecuteOutcomeAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) where TResult : T Parameters callback Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<Outcome<TResult>> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Remarks This method is for advanced and high performance scenarios. The caller must make sure that the callback does not throw any exceptions. Instead, it converts them to Outcome<TResult>. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult>(Func<ResilienceContext, TResult>, ResilienceContext) Executes the specified callback. public TResult Execute<TResult>(Func<ResilienceContext, TResult> callback, ResilienceContext context) where TResult : T Parameters callback Func<ResilienceContext, TResult> The user-provided callback. context ResilienceContext The context associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult>(Func<CancellationToken, TResult>, CancellationToken) Executes the specified callback. public TResult Execute<TResult>(Func<CancellationToken, TResult> callback, CancellationToken cancellationToken = default) where TResult : T Parameters callback Func<CancellationToken, TResult> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult>(Func<TResult>) Executes the specified callback. public TResult Execute<TResult>(Func<TResult> callback) where TResult : T Parameters callback Func<TResult> The user-provided callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult, TState>(Func<ResilienceContext, TState, TResult>, ResilienceContext, TState) Executes the specified callback. public TResult Execute<TResult, TState>(Func<ResilienceContext, TState, TResult> callback, ResilienceContext context, TState state) where TResult : T Parameters callback Func<ResilienceContext, TState, TResult> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult, TState>(Func<TState, CancellationToken, TResult>, TState, CancellationToken) Executes the specified callback. public TResult Execute<TResult, TState>(Func<TState, CancellationToken, TResult> callback, TState state, CancellationToken cancellationToken = default) where TResult : T Parameters callback Func<TState, CancellationToken, TResult> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult, TState>(Func<TState, TResult>, TState) Executes the specified callback. public TResult Execute<TResult, TState>(Func<TState, TResult> callback, TState state) where TResult : T Parameters callback Func<TState, TResult> The user-provided callback. state TState The state associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null."
  },
  "api/Polly.ResiliencePipeline.html": {
    "href": "api/Polly.ResiliencePipeline.html",
    "title": "Class ResiliencePipeline | Polly",
    "keywords": "Class ResiliencePipeline Namespace Polly Assembly Polly.Core.dll Resilience pipeline is used to execute the user-provided callbacks. public sealed class ResiliencePipeline Inheritance object ResiliencePipeline Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods ResiliencePipelineExtensions.GetPipelineDescriptor(ResiliencePipeline) Remarks Resilience pipeline supports various types of callbacks and provides a unified way to execute them. This includes overloads for synchronous and asynchronous callbacks, generic and non-generic callbacks. Fields Empty Resilience pipeline that executes the user-provided callback without any additional logic. public static readonly ResiliencePipeline Empty Field Value ResiliencePipeline Methods Execute(Action) Executes the specified callback. public void Execute(Action callback) Parameters callback Action The user-provided callback. Exceptions ArgumentNullException Thrown when callback is null. Execute(Action<ResilienceContext>, ResilienceContext) Executes the specified callback. public void Execute(Action<ResilienceContext> callback, ResilienceContext context) Parameters callback Action<ResilienceContext> The user-provided callback. context ResilienceContext The context associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute(Action<CancellationToken>, CancellationToken) Executes the specified callback. public void Execute(Action<CancellationToken> callback, CancellationToken cancellationToken = default) Parameters callback Action<CancellationToken> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync(Func<ResilienceContext, ValueTask>, ResilienceContext) Executes the specified callback. public ValueTask ExecuteAsync(Func<ResilienceContext, ValueTask> callback, ResilienceContext context) Parameters callback Func<ResilienceContext, ValueTask> The user-provided callback. context ResilienceContext The context associated with the callback. Returns ValueTask The instance of ValueTask that represents the asynchronous execution. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync(Func<CancellationToken, ValueTask>, CancellationToken) Executes the specified callback. public ValueTask ExecuteAsync(Func<CancellationToken, ValueTask> callback, CancellationToken cancellationToken = default) Parameters callback Func<CancellationToken, ValueTask> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask The instance of ValueTask that represents an asynchronous callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync<TResult>(Func<ResilienceContext, ValueTask<TResult>>, ResilienceContext) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult>(Func<ResilienceContext, ValueTask<TResult>> callback, ResilienceContext context) Parameters callback Func<ResilienceContext, ValueTask<TResult>> The user-provided callback. context ResilienceContext The context associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TState>(Func<ResilienceContext, TState, ValueTask>, ResilienceContext, TState) Executes the specified callback. public ValueTask ExecuteAsync<TState>(Func<ResilienceContext, TState, ValueTask> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask The instance of ValueTask that represents the asynchronous execution. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TResult>(Func<CancellationToken, ValueTask<TResult>>, CancellationToken) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult>(Func<CancellationToken, ValueTask<TResult>> callback, CancellationToken cancellationToken = default) Parameters callback Func<CancellationToken, ValueTask<TResult>> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync<TState>(Func<TState, CancellationToken, ValueTask>, TState, CancellationToken) Executes the specified callback. public ValueTask ExecuteAsync<TState>(Func<TState, CancellationToken, ValueTask> callback, TState state, CancellationToken cancellationToken = default) Parameters callback Func<TState, CancellationToken, ValueTask> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask The instance of ValueTask that represents an asynchronous callback. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<TResult>>, ResilienceContext, TState) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<TResult>> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask<TResult>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TResult, TState>(Func<TState, CancellationToken, ValueTask<TResult>>, TState, CancellationToken) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult, TState>(Func<TState, CancellationToken, ValueTask<TResult>> callback, TState state, CancellationToken cancellationToken = default) Parameters callback Func<TState, CancellationToken, ValueTask<TResult>> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteOutcomeAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) Executes the specified outcome-based callback. public ValueTask<Outcome<TResult>> ExecuteOutcomeAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<Outcome<TResult>> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Remarks This method is for advanced and high performance scenarios. The caller must make sure that the callback does not throw any exceptions. Instead, it converts them to Outcome<TResult>. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TState>(Action<ResilienceContext, TState>, ResilienceContext, TState) Executes the specified callback. public void Execute<TState>(Action<ResilienceContext, TState> callback, ResilienceContext context, TState state) Parameters callback Action<ResilienceContext, TState> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TState>(Action<TState, CancellationToken>, TState, CancellationToken) Executes the specified callback. public void Execute<TState>(Action<TState, CancellationToken> callback, TState state, CancellationToken cancellationToken = default) Parameters callback Action<TState, CancellationToken> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TState>(Action<TState>, TState) Executes the specified callback. public void Execute<TState>(Action<TState> callback, TState state) Parameters callback Action<TState> The user-provided callback. state TState The state associated with the callback. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult>(Func<ResilienceContext, TResult>, ResilienceContext) Executes the specified callback. public TResult Execute<TResult>(Func<ResilienceContext, TResult> callback, ResilienceContext context) Parameters callback Func<ResilienceContext, TResult> The user-provided callback. context ResilienceContext The context associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult>(Func<CancellationToken, TResult>, CancellationToken) Executes the specified callback. public TResult Execute<TResult>(Func<CancellationToken, TResult> callback, CancellationToken cancellationToken = default) Parameters callback Func<CancellationToken, TResult> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult>(Func<TResult>) Executes the specified callback. public TResult Execute<TResult>(Func<TResult> callback) Parameters callback Func<TResult> The user-provided callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult, TState>(Func<ResilienceContext, TState, TResult>, ResilienceContext, TState) Executes the specified callback. public TResult Execute<TResult, TState>(Func<ResilienceContext, TState, TResult> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, TResult> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult, TState>(Func<TState, CancellationToken, TResult>, TState, CancellationToken) Executes the specified callback. public TResult Execute<TResult, TState>(Func<TState, CancellationToken, TResult> callback, TState state, CancellationToken cancellationToken = default) Parameters callback Func<TState, CancellationToken, TResult> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult, TState>(Func<TState, TResult>, TState) Executes the specified callback. public TResult Execute<TResult, TState>(Func<TState, TResult> callback, TState state) Parameters callback Func<TState, TResult> The user-provided callback. state TState The state associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null."
  },
  "api/Polly.ResiliencePipelineBuilder-1.html": {
    "href": "api/Polly.ResiliencePipelineBuilder-1.html",
    "title": "Class ResiliencePipelineBuilder<TResult> | Polly",
    "keywords": "Class ResiliencePipelineBuilder<TResult> Namespace Polly Assembly Polly.Core.dll A builder that is used to create an instance of ResiliencePipeline<T>. public sealed class ResiliencePipelineBuilder<TResult> : ResiliencePipelineBuilderBase Type Parameters TResult The type of result to handle. Inheritance object ResiliencePipelineBuilderBase ResiliencePipelineBuilder<TResult> Inherited Members ResiliencePipelineBuilderBase.Name ResiliencePipelineBuilderBase.InstanceName ResiliencePipelineBuilderBase.ContextPool ResiliencePipelineBuilderBase.TimeProvider object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods CircuitBreakerResiliencePipelineBuilderExtensions.AddCircuitBreaker<TResult>(ResiliencePipelineBuilder<TResult>, CircuitBreakerStrategyOptions<TResult>) FallbackResiliencePipelineBuilderExtensions.AddFallback<TResult>(ResiliencePipelineBuilder<TResult>, FallbackStrategyOptions<TResult>) HedgingResiliencePipelineBuilderExtensions.AddHedging<TResult>(ResiliencePipelineBuilder<TResult>, HedgingStrategyOptions<TResult>) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, int, int) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, ConcurrencyLimiterOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiterStrategyOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiter) ResiliencePipelineBuilderExtensions.AddPipeline<TBuilder>(TBuilder, ResiliencePipeline) ResiliencePipelineBuilderExtensions.AddPipeline<TResult>(ResiliencePipelineBuilder<TResult>, ResiliencePipeline<TResult>) ResiliencePipelineBuilderExtensions.AddStrategy<TResult>(ResiliencePipelineBuilder<TResult>, Func<StrategyBuilderContext, ResilienceStrategy<TResult>>, ResilienceStrategyOptions) ResiliencePipelineBuilderExtensions.AddStrategy<TBuilder>(TBuilder, Func<StrategyBuilderContext, ResilienceStrategy>, ResilienceStrategyOptions) RetryResiliencePipelineBuilderExtensions.AddRetry<TResult>(ResiliencePipelineBuilder<TResult>, RetryStrategyOptions<TResult>) ChaosBehaviorPipelineBuilderExtensions.AddChaosBehavior<TBuilder>(TBuilder, ChaosBehaviorStrategyOptions) ChaosBehaviorPipelineBuilderExtensions.AddChaosBehavior<TBuilder>(TBuilder, double, Func<CancellationToken, ValueTask>) ChaosFaultPipelineBuilderExtensions.AddChaosFault<TBuilder>(TBuilder, ChaosFaultStrategyOptions) ChaosFaultPipelineBuilderExtensions.AddChaosFault<TBuilder>(TBuilder, double, Func<Exception?>) ChaosLatencyPipelineBuilderExtensions.AddChaosLatency<TBuilder>(TBuilder, ChaosLatencyStrategyOptions) ChaosLatencyPipelineBuilderExtensions.AddChaosLatency<TBuilder>(TBuilder, double, TimeSpan) ChaosOutcomePipelineBuilderExtensions.AddChaosOutcome<TResult>(ResiliencePipelineBuilder<TResult>, ChaosOutcomeStrategyOptions<TResult>) ChaosOutcomePipelineBuilderExtensions.AddChaosOutcome<TResult>(ResiliencePipelineBuilder<TResult>, double, Func<TResult?>) TelemetryResiliencePipelineBuilderExtensions.ConfigureTelemetry<TBuilder>(TBuilder, ILoggerFactory) TelemetryResiliencePipelineBuilderExtensions.ConfigureTelemetry<TBuilder>(TBuilder, TelemetryOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeoutStrategyOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeSpan) Remarks The builder supports combining multiple strategies into a pipeline of resilience strategies. The resulting instance of ResiliencePipeline<T> created by the Build() call will execute the strategies in the same order they were added to the builder. The order of the strategies is important. Constructors ResiliencePipelineBuilder() Initializes a new instance of the ResiliencePipelineBuilder<TResult> class. public ResiliencePipelineBuilder() Methods Build() Builds the resilience pipeline. public ResiliencePipeline<TResult> Build() Returns ResiliencePipeline<TResult> An instance of ResiliencePipeline<T>. Exceptions ValidationException Thrown when this builder has invalid configuration."
  },
  "api/Polly.ResiliencePipelineBuilder.html": {
    "href": "api/Polly.ResiliencePipelineBuilder.html",
    "title": "Class ResiliencePipelineBuilder | Polly",
    "keywords": "Class ResiliencePipelineBuilder Namespace Polly Assembly Polly.Core.dll A builder that is used to create an instance of ResiliencePipeline. public sealed class ResiliencePipelineBuilder : ResiliencePipelineBuilderBase Inheritance object ResiliencePipelineBuilderBase ResiliencePipelineBuilder Inherited Members ResiliencePipelineBuilderBase.Name ResiliencePipelineBuilderBase.InstanceName ResiliencePipelineBuilderBase.ContextPool ResiliencePipelineBuilderBase.TimeProvider object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods CircuitBreakerResiliencePipelineBuilderExtensions.AddCircuitBreaker(ResiliencePipelineBuilder, CircuitBreakerStrategyOptions) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, int, int) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, ConcurrencyLimiterOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiterStrategyOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiter) ResiliencePipelineBuilderExtensions.AddPipeline<TBuilder>(TBuilder, ResiliencePipeline) ResiliencePipelineBuilderExtensions.AddStrategy(ResiliencePipelineBuilder, Func<StrategyBuilderContext, ResilienceStrategy<object>>, ResilienceStrategyOptions) ResiliencePipelineBuilderExtensions.AddStrategy<TBuilder>(TBuilder, Func<StrategyBuilderContext, ResilienceStrategy>, ResilienceStrategyOptions) RetryResiliencePipelineBuilderExtensions.AddRetry(ResiliencePipelineBuilder, RetryStrategyOptions) ChaosBehaviorPipelineBuilderExtensions.AddChaosBehavior<TBuilder>(TBuilder, ChaosBehaviorStrategyOptions) ChaosBehaviorPipelineBuilderExtensions.AddChaosBehavior<TBuilder>(TBuilder, double, Func<CancellationToken, ValueTask>) ChaosFaultPipelineBuilderExtensions.AddChaosFault<TBuilder>(TBuilder, ChaosFaultStrategyOptions) ChaosFaultPipelineBuilderExtensions.AddChaosFault<TBuilder>(TBuilder, double, Func<Exception?>) ChaosLatencyPipelineBuilderExtensions.AddChaosLatency<TBuilder>(TBuilder, ChaosLatencyStrategyOptions) ChaosLatencyPipelineBuilderExtensions.AddChaosLatency<TBuilder>(TBuilder, double, TimeSpan) TelemetryResiliencePipelineBuilderExtensions.ConfigureTelemetry<TBuilder>(TBuilder, ILoggerFactory) TelemetryResiliencePipelineBuilderExtensions.ConfigureTelemetry<TBuilder>(TBuilder, TelemetryOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeoutStrategyOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeSpan) Remarks The builder supports combining multiple strategies into a pipeline of resilience strategies. The resulting instance of ResiliencePipeline created by the Build() call executes the strategies in the same order they were added to the builder. The order of the strategies is important. Methods Build() Builds the resilience pipeline. public ResiliencePipeline Build() Returns ResiliencePipeline An instance of ResiliencePipeline. Exceptions ValidationException Thrown when this builder has invalid configuration."
  },
  "api/Polly.ResiliencePipelineBuilderBase.html": {
    "href": "api/Polly.ResiliencePipelineBuilderBase.html",
    "title": "Class ResiliencePipelineBuilderBase | Polly",
    "keywords": "Class ResiliencePipelineBuilderBase Namespace Polly Assembly Polly.Core.dll A builder that is used to create an instance of ResiliencePipeline. public abstract class ResiliencePipelineBuilderBase Inheritance object ResiliencePipelineBuilderBase Derived ResiliencePipelineBuilder ResiliencePipelineBuilder<TResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, int, int) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, ConcurrencyLimiterOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiterStrategyOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiter) ResiliencePipelineBuilderExtensions.AddPipeline<TBuilder>(TBuilder, ResiliencePipeline) ResiliencePipelineBuilderExtensions.AddStrategy<TBuilder>(TBuilder, Func<StrategyBuilderContext, ResilienceStrategy>, ResilienceStrategyOptions) ChaosBehaviorPipelineBuilderExtensions.AddChaosBehavior<TBuilder>(TBuilder, ChaosBehaviorStrategyOptions) ChaosBehaviorPipelineBuilderExtensions.AddChaosBehavior<TBuilder>(TBuilder, double, Func<CancellationToken, ValueTask>) ChaosFaultPipelineBuilderExtensions.AddChaosFault<TBuilder>(TBuilder, ChaosFaultStrategyOptions) ChaosFaultPipelineBuilderExtensions.AddChaosFault<TBuilder>(TBuilder, double, Func<Exception?>) ChaosLatencyPipelineBuilderExtensions.AddChaosLatency<TBuilder>(TBuilder, ChaosLatencyStrategyOptions) ChaosLatencyPipelineBuilderExtensions.AddChaosLatency<TBuilder>(TBuilder, double, TimeSpan) TelemetryResiliencePipelineBuilderExtensions.ConfigureTelemetry<TBuilder>(TBuilder, ILoggerFactory) TelemetryResiliencePipelineBuilderExtensions.ConfigureTelemetry<TBuilder>(TBuilder, TelemetryOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeoutStrategyOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeSpan) Remarks The builder supports combining multiple strategies into a pipeline of resilience strategies. The resulting instance of ResiliencePipeline executes the strategies in the same order they were added to the builder. The order of the strategies is important. Properties ContextPool Gets or sets the ResilienceContextPool associated with the builder. public ResilienceContextPool? ContextPool { get; set; } Property Value ResilienceContextPool If the default value of null is used, Shared will be used. Remarks A custom pool can be used to configure custom behavior for creation. This can include setting a default continueOnCapturedContext parameter or custom operation key resolution. InstanceName Gets or sets the instance name of the builder. public string? InstanceName { get; set; } Property Value string The default value is null. Remarks This property is also included in the telemetry that is produced by the individual resilience strategies. The instance name can be used to differentiate between multiple builder instances with the same Name. Name Gets or sets the name of the builder. public string? Name { get; set; } Property Value string The default value is null. Remarks This property is also included in the telemetry that is produced by the individual resilience strategies. TimeProvider Gets or sets a TimeProvider that is used by strategies that work with time. public TimeProvider? TimeProvider { get; set; } Property Value TimeProvider The default value is null and unless set, System will be used."
  },
  "api/Polly.ResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.ResiliencePipelineBuilderExtensions.html",
    "title": "Class ResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class ResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for ResiliencePipelineBuilderBase. public static class ResiliencePipelineBuilderExtensions Inheritance object ResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddPipeline<TResult>(ResiliencePipelineBuilder<TResult>, ResiliencePipeline<TResult>) Adds an already created pipeline instance to the builder. public static ResiliencePipelineBuilder<TResult> AddPipeline<TResult>(this ResiliencePipelineBuilder<TResult> builder, ResiliencePipeline<TResult> pipeline) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. pipeline ResiliencePipeline<TResult> The pipeline instance. Returns ResiliencePipelineBuilder<TResult> The same builder instance. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when pipeline is null. InvalidOperationException Thrown when this builder was already used to create a strategy. The builder cannot be modified after it has been used. AddPipeline<TBuilder>(TBuilder, ResiliencePipeline) Adds an already created pipeline instance to the builder. public static TBuilder AddPipeline<TBuilder>(this TBuilder builder, ResiliencePipeline pipeline) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. pipeline ResiliencePipeline The pipeline instance. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when pipeline is null. InvalidOperationException Thrown when this builder was already used to create a pipeline. The builder cannot be modified after it has been used. AddStrategy(ResiliencePipelineBuilder, Func<StrategyBuilderContext, ResilienceStrategy<object>>, ResilienceStrategyOptions) Adds a reactive strategy to the builder. public static ResiliencePipelineBuilder AddStrategy(this ResiliencePipelineBuilder builder, Func<StrategyBuilderContext, ResilienceStrategy<object>> factory, ResilienceStrategyOptions options) Parameters builder ResiliencePipelineBuilder The builder instance. factory Func<StrategyBuilderContext, ResilienceStrategy<object>> The factory that creates a resilience strategy. options ResilienceStrategyOptions The options associated with the strategy. If none are provided the default instance of ResilienceStrategyOptions is created. Returns ResiliencePipelineBuilder The same builder instance. Exceptions ArgumentNullException Thrown when builder, factory or options is null. InvalidOperationException Thrown when this builder was already used to create a pipeline. The builder cannot be modified after it has been used. ValidationException Thrown when options is invalid. AddStrategy<TResult>(ResiliencePipelineBuilder<TResult>, Func<StrategyBuilderContext, ResilienceStrategy<TResult>>, ResilienceStrategyOptions) Adds a reactive strategy to the builder. public static ResiliencePipelineBuilder<TResult> AddStrategy<TResult>(this ResiliencePipelineBuilder<TResult> builder, Func<StrategyBuilderContext, ResilienceStrategy<TResult>> factory, ResilienceStrategyOptions options) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. factory Func<StrategyBuilderContext, ResilienceStrategy<TResult>> The factory that creates a resilience strategy. options ResilienceStrategyOptions The options associated with the strategy. If none are provided the default instance of ResilienceStrategyOptions is created. Returns ResiliencePipelineBuilder<TResult> The same builder instance. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when builder, factory or options is null. InvalidOperationException Thrown when this builder was already used to create a pipeline. The builder cannot be modified after it has been used. ValidationException Thrown when options is invalid. AddStrategy<TBuilder>(TBuilder, Func<StrategyBuilderContext, ResilienceStrategy>, ResilienceStrategyOptions) Adds a proactive resilience strategy to the builder. public static TBuilder AddStrategy<TBuilder>(this TBuilder builder, Func<StrategyBuilderContext, ResilienceStrategy> factory, ResilienceStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. factory Func<StrategyBuilderContext, ResilienceStrategy> The factory that creates a resilience strategy. options ResilienceStrategyOptions The options associated with the strategy. If none are provided the default instance of ResilienceStrategyOptions is created. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder, factory or options is null. InvalidOperationException Thrown when this builder was already used to create a pipeline. The builder cannot be modified after it has been used. ValidationException Thrown when options is invalid."
  },
  "api/Polly.ResilienceProperties.html": {
    "href": "api/Polly.ResilienceProperties.html",
    "title": "Class ResilienceProperties | Polly",
    "keywords": "Class ResilienceProperties Namespace Polly Assembly Polly.Core.dll Represents a collection of custom resilience properties. public sealed class ResilienceProperties Inheritance object ResilienceProperties Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods GetValue<TValue>(ResiliencePropertyKey<TValue>, TValue) Gets the value of a given property with a fallback default value. public TValue GetValue<TValue>(ResiliencePropertyKey<TValue> key, TValue defaultValue) Parameters key ResiliencePropertyKey<TValue> Strongly typed key to get the value of the property. defaultValue TValue The default value to use if property is not found. Returns TValue The property value or the default value. Type Parameters TValue The type of property value as defined by key parameter. Set<TValue>(ResiliencePropertyKey<TValue>, TValue) Sets the value of a given property. public void Set<TValue>(ResiliencePropertyKey<TValue> key, TValue value) Parameters key ResiliencePropertyKey<TValue> Strongly typed key to get the value of the property. value TValue Returns the value of the property. Type Parameters TValue The type of property value as defined by key parameter. TryGetValue<TValue>(ResiliencePropertyKey<TValue>, out TValue) Gets the value of a given property. public bool TryGetValue<TValue>(ResiliencePropertyKey<TValue> key, out TValue value) Parameters key ResiliencePropertyKey<TValue> Strongly typed key to get the value of the property. value TValue Returns the value of the property. Returns bool True, if a property was retrieved. Type Parameters TValue The type of property value as defined by key parameter."
  },
  "api/Polly.ResiliencePropertyKey-1.html": {
    "href": "api/Polly.ResiliencePropertyKey-1.html",
    "title": "Struct ResiliencePropertyKey<TValue> | Polly",
    "keywords": "Struct ResiliencePropertyKey<TValue> Namespace Polly Assembly Polly.Core.dll Represents a key used by ResilienceProperties. public readonly struct ResiliencePropertyKey<TValue> Type Parameters TValue The type of the value of the property. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ResiliencePropertyKey(string) Initializes a new instance of the ResiliencePropertyKey<TValue> struct. public ResiliencePropertyKey(string key) Parameters key string The key name. Properties Key Gets the name of the key. public string Key { get; } Property Value string Methods ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/Polly.ResilienceStrategy-1.html": {
    "href": "api/Polly.ResilienceStrategy-1.html",
    "title": "Class ResilienceStrategy<TResult> | Polly",
    "keywords": "Class ResilienceStrategy<TResult> Namespace Polly Assembly Polly.Core.dll This base strategy class is used to simplify the implementation of generic (reactive) strategies by limiting the number of generic types the execute method receives. public abstract class ResilienceStrategy<TResult> Type Parameters TResult The type of result this strategy handles. Inheritance object ResilienceStrategy<TResult> Derived ChaosStrategy<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks For strategies that handle all result types the generic parameter must be of type object. Methods ExecuteCore<TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) An implementation of a reactive resilience strategy that executes the specified callback. protected abstract ValueTask<Outcome<TResult>> ExecuteCore<TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<Outcome<TResult>> An instance of a pending ValueTask for asynchronous executions or a completed ValueTask task for synchronous executions. Type Parameters TState The type of state associated with the callback. Remarks The provided callback never throws an exception. Instead, the exception is captured and converted to an Outcome<TResult>. Similarly, do not throw exceptions from your strategy implementation. Instead, return an exception instance as Outcome<TResult>."
  },
  "api/Polly.ResilienceStrategy.html": {
    "href": "api/Polly.ResilienceStrategy.html",
    "title": "Class ResilienceStrategy | Polly",
    "keywords": "Class ResilienceStrategy Namespace Polly Assembly Polly.Core.dll Base class for all proactive resilience strategies. public abstract class ResilienceStrategy Inheritance object ResilienceStrategy Derived ChaosStrategy Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExecuteCore<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) An implementation of a proactive resilience strategy that executes the specified callback. protected abstract ValueTask<Outcome<TResult>> ExecuteCore<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<Outcome<TResult>> An instance of a pending ValueTask for asynchronous executions or a completed ValueTask task for synchronous executions. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Remarks The provided callback never throws an exception. Instead, the exception is captured and converted to an Outcome<TResult>. Similarly, do not throw exceptions from your strategy implementation. Instead, return an exception instance as Outcome<TResult>."
  },
  "api/Polly.ResilienceStrategyOptions.html": {
    "href": "api/Polly.ResilienceStrategyOptions.html",
    "title": "Class ResilienceStrategyOptions | Polly",
    "keywords": "Class ResilienceStrategyOptions Namespace Polly Assembly Polly.Core.dll The options associated with the individual resilience strategy. public abstract class ResilienceStrategyOptions Inheritance object ResilienceStrategyOptions Derived CircuitBreakerStrategyOptions<TResult> FallbackStrategyOptions<TResult> HedgingStrategyOptions<TResult> RateLimiterStrategyOptions RetryStrategyOptions<TResult> ChaosStrategyOptions TimeoutStrategyOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Name Gets or sets the name of the strategy. public string? Name { get; set; } Property Value string The default value is null. Remarks This name uniquely identifies a particular instance of a specific strategy and is also included in the telemetry that is produced by the individual resilience strategies."
  },
  "api/Polly.Retry.OnRetryArguments-1.html": {
    "href": "api/Polly.Retry.OnRetryArguments-1.html",
    "title": "Struct OnRetryArguments<TResult> | Polly",
    "keywords": "Struct OnRetryArguments<TResult> Namespace Polly.Retry Assembly Polly.Core.dll Represents the arguments used by OnRetry for handling the retry event. public readonly struct OnRetryArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnRetryArguments(ResilienceContext, Outcome<TResult>, int, TimeSpan, TimeSpan) Initializes a new instance of the OnRetryArguments<TResult> struct. public OnRetryArguments(ResilienceContext context, Outcome<TResult> outcome, int attemptNumber, TimeSpan retryDelay, TimeSpan duration) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. attemptNumber int The zero-based attempt number. retryDelay TimeSpan The delay before the next retry. duration TimeSpan The duration of this attempt. Properties AttemptNumber Gets the zero-based attempt number. public int AttemptNumber { get; } Property Value int Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Duration Gets the duration of this attempt. public TimeSpan Duration { get; } Property Value TimeSpan Outcome Gets the outcome that will be retried. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult> RetryDelay Gets the delay before the next retry. public TimeSpan RetryDelay { get; } Property Value TimeSpan"
  },
  "api/Polly.Retry.RetryDelayGeneratorArguments-1.html": {
    "href": "api/Polly.Retry.RetryDelayGeneratorArguments-1.html",
    "title": "Struct RetryDelayGeneratorArguments<TResult> | Polly",
    "keywords": "Struct RetryDelayGeneratorArguments<TResult> Namespace Polly.Retry Assembly Polly.Core.dll Represents the arguments used by DelayGenerator for generating the next retry delay. public readonly struct RetryDelayGeneratorArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors RetryDelayGeneratorArguments(ResilienceContext, Outcome<TResult>, int) Initializes a new instance of the RetryDelayGeneratorArguments<TResult> struct. public RetryDelayGeneratorArguments(ResilienceContext context, Outcome<TResult> outcome, int attemptNumber) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. attemptNumber int The zero-based attempt number. Properties AttemptNumber Gets The zero-based attempt number. public int AttemptNumber { get; } Property Value int Context Gets the context in which the resilience operation or event occurred. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the resilience operation or event. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Retry.RetryPredicateArguments-1.html": {
    "href": "api/Polly.Retry.RetryPredicateArguments-1.html",
    "title": "Struct RetryPredicateArguments<TResult> | Polly",
    "keywords": "Struct RetryPredicateArguments<TResult> Namespace Polly.Retry Assembly Polly.Core.dll Represents the arguments used by ShouldHandle for determining whether a retry should be performed. public readonly struct RetryPredicateArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors RetryPredicateArguments(ResilienceContext, Outcome<TResult>, int) Initializes a new instance of the RetryPredicateArguments<TResult> struct. public RetryPredicateArguments(ResilienceContext context, Outcome<TResult> outcome, int attemptNumber) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. attemptNumber int The zero-based attempt number. Properties AttemptNumber Gets the zero-based attempt number. public int AttemptNumber { get; } Property Value int Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the user-specified callback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Retry.RetryStrategyOptions-1.html": {
    "href": "api/Polly.Retry.RetryStrategyOptions-1.html",
    "title": "Class RetryStrategyOptions<TResult> | Polly",
    "keywords": "Class RetryStrategyOptions<TResult> Namespace Polly.Retry Assembly Polly.Core.dll Represents the options used to configure a retry strategy. public class RetryStrategyOptions<TResult> : ResilienceStrategyOptions Type Parameters TResult The type of result the retry strategy handles. Inheritance object ResilienceStrategyOptions RetryStrategyOptions<TResult> Derived RetryStrategyOptions Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RetryStrategyOptions() Initializes a new instance of the RetryStrategyOptions<TResult> class. public RetryStrategyOptions() Properties BackoffType Gets or sets the type of the back-off. public DelayBackoffType BackoffType { get; set; } Property Value DelayBackoffType The default value is Constant. Remarks This property is ignored when DelayGenerator is set. Delay Gets or sets the base delay between retries. [Range(typeof(TimeSpan), \"00:00:00\", \"1.00:00:00\")] public TimeSpan Delay { get; set; } Property Value TimeSpan The default value is 2 seconds. Remarks This value is used with the combination of BackoffType to generate the final delay for each individual retry attempt: Exponential: Represents the median delay to target before the first retry. Linear: Represents the initial delay, the following delays increasing linearly with this value. Constant Represents the constant delay between retries. This property is ignored when DelayGenerator is set and returns a valid TimeSpan value. DelayGenerator Gets or sets a generator that calculates the delay between retries. public Func<RetryDelayGeneratorArguments<TResult>, ValueTask<TimeSpan?>>? DelayGenerator { get; set; } Property Value Func<RetryDelayGeneratorArguments<TResult>, ValueTask<TimeSpan?>> The default value is null. Remarks The generator can override the delay generated by the retry strategy. If the generator returns null, the delay generated by the retry strategy for that attempt will be used. MaxDelay Gets or sets the maximum delay between retries. [Range(typeof(TimeSpan), \"00:00:00\", \"1.00:00:00\")] public TimeSpan? MaxDelay { get; set; } Property Value TimeSpan? The default value is null. Remarks This property is used to cap the maximum delay between retries. It is useful when you want to limit the maximum delay after a certain number of retries when it could reach a unreasonably high values, especially if Exponential backoff is used. If not specified, the delay is not capped. This property is ignored for delays generated by DelayGenerator. MaxRetryAttempts Gets or sets the maximum number of retries to use, in addition to the original call. [Range(1, 2147483647)] public int MaxRetryAttempts { get; set; } Property Value int The default value is 3 retries. Remarks To retry indefinitely use MaxValue. Note that the reported attempt number is capped at MaxValue. OnRetry Gets or sets an event delegate that is raised when the retry happens. public Func<OnRetryArguments<TResult>, ValueTask>? OnRetry { get; set; } Property Value Func<OnRetryArguments<TResult>, ValueTask> The default value is null. Remarks After this event, the result produced the by user-callback is discarded and disposed to prevent resource over-consumption. If you need to preserve the result for further processing, create the copy of the result or extract and store all necessary information from the result within the event. ShouldHandle Gets or sets a predicate that determines whether the retry should be executed for a given outcome. [Required] public Func<RetryPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } Property Value Func<RetryPredicateArguments<TResult>, ValueTask<bool>> The default is a delegate that retries on any exception except OperationCanceledException. This property is required. UseJitter Gets or sets a value indicating whether jitter should be used when calculating the backoff delay between retries. public bool UseJitter { get; set; } Property Value bool The default value is false. Remarks See https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry#new-jitter-recommendation for more details on how jitter can improve the resilience when the retries are correlated."
  },
  "api/Polly.Retry.RetryStrategyOptions.html": {
    "href": "api/Polly.Retry.RetryStrategyOptions.html",
    "title": "Class RetryStrategyOptions | Polly",
    "keywords": "Class RetryStrategyOptions Namespace Polly.Retry Assembly Polly.Core.dll Represents the options used to configure a retry strategy. public class RetryStrategyOptions : RetryStrategyOptions<object> Inheritance object ResilienceStrategyOptions RetryStrategyOptions<object> RetryStrategyOptions Inherited Members RetryStrategyOptions<object>.MaxRetryAttempts RetryStrategyOptions<object>.BackoffType RetryStrategyOptions<object>.UseJitter RetryStrategyOptions<object>.Delay RetryStrategyOptions<object>.MaxDelay RetryStrategyOptions<object>.ShouldHandle RetryStrategyOptions<object>.DelayGenerator RetryStrategyOptions<object>.OnRetry ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Polly.Retry.html": {
    "href": "api/Polly.Retry.html",
    "title": "Namespace Polly.Retry | Polly",
    "keywords": "Namespace Polly.Retry Classes RetryStrategyOptions Represents the options used to configure a retry strategy. RetryStrategyOptions<TResult> Represents the options used to configure a retry strategy. Structs OnRetryArguments<TResult> Represents the arguments used by OnRetry for handling the retry event. RetryDelayGeneratorArguments<TResult> Represents the arguments used by DelayGenerator for generating the next retry delay. RetryPredicateArguments<TResult> Represents the arguments used by ShouldHandle for determining whether a retry should be performed."
  },
  "api/Polly.RetryResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.RetryResiliencePipelineBuilderExtensions.html",
    "title": "Class RetryResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class RetryResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for adding retries to ResiliencePipelineBuilder. public static class RetryResiliencePipelineBuilderExtensions Inheritance object RetryResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddRetry(ResiliencePipelineBuilder, RetryStrategyOptions) Adds a retry to the builder. public static ResiliencePipelineBuilder AddRetry(this ResiliencePipelineBuilder builder, RetryStrategyOptions options) Parameters builder ResiliencePipelineBuilder The builder instance. options RetryStrategyOptions The retry options. Returns ResiliencePipelineBuilder The builder instance with the retry strategy added. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. AddRetry<TResult>(ResiliencePipelineBuilder<TResult>, RetryStrategyOptions<TResult>) Adds a retry to the builder. public static ResiliencePipelineBuilder<TResult> AddRetry<TResult>(this ResiliencePipelineBuilder<TResult> builder, RetryStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. options RetryStrategyOptions<TResult> The retry options. Returns ResiliencePipelineBuilder<TResult> The builder instance with the retry added. Type Parameters TResult The type of result the retry handles. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid."
  },
  "api/Polly.Simmy.Behavior.BehaviorGeneratorArguments.html": {
    "href": "api/Polly.Simmy.Behavior.BehaviorGeneratorArguments.html",
    "title": "Struct BehaviorGeneratorArguments | Polly",
    "keywords": "Struct BehaviorGeneratorArguments Namespace Polly.Simmy.Behavior Assembly Polly.Core.dll Arguments used by the behavior chaos strategy to execute a user's delegate custom action. public readonly struct BehaviorGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors BehaviorGeneratorArguments(ResilienceContext) Initializes a new instance of the BehaviorGeneratorArguments struct. public BehaviorGeneratorArguments(ResilienceContext context) Parameters context ResilienceContext The resilience context instance. Properties Context Gets the resilience context instance. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Simmy.Behavior.ChaosBehaviorStrategyOptions.html": {
    "href": "api/Polly.Simmy.Behavior.ChaosBehaviorStrategyOptions.html",
    "title": "Class ChaosBehaviorStrategyOptions | Polly",
    "keywords": "Class ChaosBehaviorStrategyOptions Namespace Polly.Simmy.Behavior Assembly Polly.Core.dll Represents the options for the behavior chaos strategy. public class ChaosBehaviorStrategyOptions : ChaosStrategyOptions Inheritance object ResilienceStrategyOptions ChaosStrategyOptions ChaosBehaviorStrategyOptions Inherited Members ChaosStrategyOptions.InjectionRate ChaosStrategyOptions.InjectionRateGenerator ChaosStrategyOptions.EnabledGenerator ChaosStrategyOptions.Enabled ChaosStrategyOptions.Randomizer ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ChaosBehaviorStrategyOptions() Initializes a new instance of the ChaosBehaviorStrategyOptions class. public ChaosBehaviorStrategyOptions() Properties BehaviorGenerator Gets or sets the behavior that is going to be injected for a given execution. [Required] public Func<BehaviorGeneratorArguments, ValueTask>? BehaviorGenerator { get; set; } Property Value Func<BehaviorGeneratorArguments, ValueTask> Defaults to null. This property is required. OnBehaviorInjected Gets or sets the delegate that's raised when the behavior is injected. public Func<OnBehaviorInjectedArguments, ValueTask>? OnBehaviorInjected { get; set; } Property Value Func<OnBehaviorInjectedArguments, ValueTask> Defaults to null."
  },
  "api/Polly.Simmy.Behavior.OnBehaviorInjectedArguments.html": {
    "href": "api/Polly.Simmy.Behavior.OnBehaviorInjectedArguments.html",
    "title": "Struct OnBehaviorInjectedArguments | Polly",
    "keywords": "Struct OnBehaviorInjectedArguments Namespace Polly.Simmy.Behavior Assembly Polly.Core.dll Arguments used by the behavior chaos strategy to notify that a custom behavior was injected. public readonly struct OnBehaviorInjectedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors OnBehaviorInjectedArguments(ResilienceContext) Initializes a new instance of the OnBehaviorInjectedArguments struct. public OnBehaviorInjectedArguments(ResilienceContext context) Parameters context ResilienceContext The resilience context instance. Properties Context Gets the resilience context instance. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Simmy.Behavior.html": {
    "href": "api/Polly.Simmy.Behavior.html",
    "title": "Namespace Polly.Simmy.Behavior | Polly",
    "keywords": "Namespace Polly.Simmy.Behavior Classes ChaosBehaviorStrategyOptions Represents the options for the behavior chaos strategy. Structs BehaviorGeneratorArguments Arguments used by the behavior chaos strategy to execute a user's delegate custom action. OnBehaviorInjectedArguments Arguments used by the behavior chaos strategy to notify that a custom behavior was injected."
  },
  "api/Polly.Simmy.ChaosBehaviorPipelineBuilderExtensions.html": {
    "href": "api/Polly.Simmy.ChaosBehaviorPipelineBuilderExtensions.html",
    "title": "Class ChaosBehaviorPipelineBuilderExtensions | Polly",
    "keywords": "Class ChaosBehaviorPipelineBuilderExtensions Namespace Polly.Simmy Assembly Polly.Core.dll Extension methods for adding chaos behaviors to a ResiliencePipelineBuilder. public static class ChaosBehaviorPipelineBuilderExtensions Inheritance object ChaosBehaviorPipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddChaosBehavior<TBuilder>(TBuilder, ChaosBehaviorStrategyOptions) Adds a behavior chaos strategy to the builder. public static TBuilder AddChaosBehavior<TBuilder>(this TBuilder builder, ChaosBehaviorStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options ChaosBehaviorStrategyOptions The behavior options. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. AddChaosBehavior<TBuilder>(TBuilder, double, Func<CancellationToken, ValueTask>) Adds a behavior chaos strategy to the builder. public static TBuilder AddChaosBehavior<TBuilder>(this TBuilder builder, double injectionRate, Func<CancellationToken, ValueTask> behavior) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. injectionRate double The injection rate for a given execution, which the value should be between [0, 1] (inclusive). behavior Func<CancellationToken, ValueTask> The behavior to be injected. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder is null. ValidationException Thrown when the options produced from the arguments are invalid."
  },
  "api/Polly.Simmy.ChaosFaultPipelineBuilderExtensions.html": {
    "href": "api/Polly.Simmy.ChaosFaultPipelineBuilderExtensions.html",
    "title": "Class ChaosFaultPipelineBuilderExtensions | Polly",
    "keywords": "Class ChaosFaultPipelineBuilderExtensions Namespace Polly.Simmy Assembly Polly.Core.dll Extension methods for adding chaos fault strategy to a ResiliencePipelineBuilder. public static class ChaosFaultPipelineBuilderExtensions Inheritance object ChaosFaultPipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddChaosFault<TBuilder>(TBuilder, ChaosFaultStrategyOptions) Adds a fault chaos strategy to the builder. public static TBuilder AddChaosFault<TBuilder>(this TBuilder builder, ChaosFaultStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options ChaosFaultStrategyOptions The fault strategy options. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. AddChaosFault<TBuilder>(TBuilder, double, Func<Exception?>) Adds a fault chaos strategy to the builder. public static TBuilder AddChaosFault<TBuilder>(this TBuilder builder, double injectionRate, Func<Exception?> faultGenerator) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. injectionRate double The injection rate for a given execution, which the value should be between [0, 1] (inclusive). faultGenerator Func<Exception> The exception generator delegate. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type."
  },
  "api/Polly.Simmy.ChaosLatencyPipelineBuilderExtensions.html": {
    "href": "api/Polly.Simmy.ChaosLatencyPipelineBuilderExtensions.html",
    "title": "Class ChaosLatencyPipelineBuilderExtensions | Polly",
    "keywords": "Class ChaosLatencyPipelineBuilderExtensions Namespace Polly.Simmy Assembly Polly.Core.dll Extension methods for adding chaos latency strategies to a ResiliencePipelineBuilderBase. public static class ChaosLatencyPipelineBuilderExtensions Inheritance object ChaosLatencyPipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddChaosLatency<TBuilder>(TBuilder, ChaosLatencyStrategyOptions) Adds a latency chaos strategy to the builder. public static TBuilder AddChaosLatency<TBuilder>(this TBuilder builder, ChaosLatencyStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options ChaosLatencyStrategyOptions The latency options. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. AddChaosLatency<TBuilder>(TBuilder, double, TimeSpan) Adds a latency chaos strategy to the builder. public static TBuilder AddChaosLatency<TBuilder>(this TBuilder builder, double injectionRate, TimeSpan latency) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. injectionRate double The injection rate for a given execution, which the value should be between [0, 1] (inclusive). latency TimeSpan The delay value. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder is null. ValidationException Thrown when the options produced from the arguments are invalid."
  },
  "api/Polly.Simmy.ChaosOutcomePipelineBuilderExtensions.html": {
    "href": "api/Polly.Simmy.ChaosOutcomePipelineBuilderExtensions.html",
    "title": "Class ChaosOutcomePipelineBuilderExtensions | Polly",
    "keywords": "Class ChaosOutcomePipelineBuilderExtensions Namespace Polly.Simmy Assembly Polly.Core.dll Extension methods for adding chaos outcome strategy to a ResiliencePipelineBuilder. public static class ChaosOutcomePipelineBuilderExtensions Inheritance object ChaosOutcomePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddChaosOutcome<TResult>(ResiliencePipelineBuilder<TResult>, ChaosOutcomeStrategyOptions<TResult>) Adds an outcome chaos strategy to the builder. public static ResiliencePipelineBuilder<TResult> AddChaosOutcome<TResult>(this ResiliencePipelineBuilder<TResult> builder, ChaosOutcomeStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. options ChaosOutcomeStrategyOptions<TResult> The strategy options. Returns ResiliencePipelineBuilder<TResult> The same builder instance. Type Parameters TResult The type of result the strategy handles. AddChaosOutcome<TResult>(ResiliencePipelineBuilder<TResult>, double, Func<TResult?>) Adds an outcome chaos strategy to the builder. public static ResiliencePipelineBuilder<TResult> AddChaosOutcome<TResult>(this ResiliencePipelineBuilder<TResult> builder, double injectionRate, Func<TResult?> resultGenerator) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. injectionRate double The injection rate for a given execution, which the value should be between [0, 1] (inclusive). resultGenerator Func<TResult> The outcome generator delegate. Returns ResiliencePipelineBuilder<TResult> The same builder instance. Type Parameters TResult The type of result the strategy handles."
  },
  "api/Polly.Simmy.ChaosStrategy-1.html": {
    "href": "api/Polly.Simmy.ChaosStrategy-1.html",
    "title": "Class ChaosStrategy<T> | Polly",
    "keywords": "Class ChaosStrategy<T> Namespace Polly.Simmy Assembly Polly.Core.dll Base class for generic (reactive) chaos strategies. public abstract class ChaosStrategy<T> : ResilienceStrategy<T> Type Parameters T The type of result this strategy handles. Inheritance object ResilienceStrategy<T> ChaosStrategy<T> Inherited Members ResilienceStrategy<T>.ExecuteCore<TState>(Func<ResilienceContext, TState, ValueTask<Outcome<T>>>, ResilienceContext, TState) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks For strategies that handle all result types the generic parameter must be of type object. Constructors ChaosStrategy(ChaosStrategyOptions) Initializes a new instance of the ChaosStrategy<T> class. protected ChaosStrategy(ChaosStrategyOptions options) Parameters options ChaosStrategyOptions The chaos strategy options. Methods ShouldInjectAsync(ResilienceContext) Determines whether or not the chaos strategy should be injected based on the injection rate and enabled flag. protected ValueTask<bool> ShouldInjectAsync(ResilienceContext context) Parameters context ResilienceContext The ResilienceContext instance. Returns ValueTask<bool> A boolean value that indicates whether or not the chaos strategy should be injected. Remarks Use this method before injecting any chaos strategy to evaluate whether a given chaos strategy needs to be injected during the execution."
  },
  "api/Polly.Simmy.ChaosStrategy.html": {
    "href": "api/Polly.Simmy.ChaosStrategy.html",
    "title": "Class ChaosStrategy | Polly",
    "keywords": "Class ChaosStrategy Namespace Polly.Simmy Assembly Polly.Core.dll Base class for chaos strategies. public abstract class ChaosStrategy : ResilienceStrategy Inheritance object ResilienceStrategy ChaosStrategy Inherited Members ResilienceStrategy.ExecuteCore<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ChaosStrategy(ChaosStrategyOptions) Initializes a new instance of the ChaosStrategy class. protected ChaosStrategy(ChaosStrategyOptions options) Parameters options ChaosStrategyOptions The chaos strategy options. Methods ShouldInjectAsync(ResilienceContext) Determines whether or not the chaos strategy should be injected based on the injection rate and enabled flag. protected ValueTask<bool> ShouldInjectAsync(ResilienceContext context) Parameters context ResilienceContext The ResilienceContext instance. Returns ValueTask<bool> A boolean value that indicates whether or not the chaos strategy should be injected. Remarks Use this method before injecting any chaos strategy to evaluate whether a given chaos strategy needs to be injected during the execution."
  },
  "api/Polly.Simmy.ChaosStrategyOptions.html": {
    "href": "api/Polly.Simmy.ChaosStrategyOptions.html",
    "title": "Class ChaosStrategyOptions | Polly",
    "keywords": "Class ChaosStrategyOptions Namespace Polly.Simmy Assembly Polly.Core.dll The options associated with the ChaosStrategy. public abstract class ChaosStrategyOptions : ResilienceStrategyOptions Inheritance object ResilienceStrategyOptions ChaosStrategyOptions Derived ChaosBehaviorStrategyOptions ChaosFaultStrategyOptions ChaosLatencyStrategyOptions ChaosOutcomeStrategyOptions<TResult> Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Enabled Gets or sets a value indicating whether or not the chaos strategy is enabled for a given execution. public bool Enabled { get; set; } Property Value bool Defaults to true. When EnabledGenerator is specified, this property is ignored. EnabledGenerator Gets or sets the enable generator that indicates whether or not the chaos strategy is enabled for a given execution. public Func<EnabledGeneratorArguments, ValueTask<bool>>? EnabledGenerator { get; set; } Property Value Func<EnabledGeneratorArguments, ValueTask<bool>> Defaults to null. When the generator is specified, the Enabled property is ignored. InjectionRate Gets or sets the injection rate for a given execution, which the value should be between [0, 1] (inclusive). [Range(0, 1)] public double InjectionRate { get; set; } Property Value double Defaults to 0.001, meaning one in a thousand executions/0.1%. When InjectionRateGenerator is specified, this property is ignored. InjectionRateGenerator Gets or sets the injection rate generator for a given execution, which the value should be between [0, 1] (inclusive). public Func<InjectionRateGeneratorArguments, ValueTask<double>>? InjectionRateGenerator { get; set; } Property Value Func<InjectionRateGeneratorArguments, ValueTask<double>> Defaults to null. When generator is specified, the InjectionRate property is ignored. Randomizer Gets or sets the Randomizer generator instance that is used to evaluate the injection rate. [Required] public Func<double> Randomizer { get; set; } Property Value Func<double> The default randomizer is thread safe and returns values between 0.0 and 1.0."
  },
  "api/Polly.Simmy.EnabledGeneratorArguments.html": {
    "href": "api/Polly.Simmy.EnabledGeneratorArguments.html",
    "title": "Struct EnabledGeneratorArguments | Polly",
    "keywords": "Struct EnabledGeneratorArguments Namespace Polly.Simmy Assembly Polly.Core.dll Defines the arguments for the EnabledGenerator. public readonly struct EnabledGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors EnabledGeneratorArguments(ResilienceContext) Initializes a new instance of the EnabledGeneratorArguments struct. public EnabledGeneratorArguments(ResilienceContext context) Parameters context ResilienceContext The resilience context instance. Properties Context Gets the ResilienceContext instance. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Simmy.Fault.ChaosFaultStrategyOptions.html": {
    "href": "api/Polly.Simmy.Fault.ChaosFaultStrategyOptions.html",
    "title": "Class ChaosFaultStrategyOptions | Polly",
    "keywords": "Class ChaosFaultStrategyOptions Namespace Polly.Simmy.Fault Assembly Polly.Core.dll Represents the options for the fault chaos strategy. public class ChaosFaultStrategyOptions : ChaosStrategyOptions Inheritance object ResilienceStrategyOptions ChaosStrategyOptions ChaosFaultStrategyOptions Inherited Members ChaosStrategyOptions.InjectionRate ChaosStrategyOptions.InjectionRateGenerator ChaosStrategyOptions.EnabledGenerator ChaosStrategyOptions.Enabled ChaosStrategyOptions.Randomizer ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ChaosFaultStrategyOptions() Initializes a new instance of the ChaosFaultStrategyOptions class. public ChaosFaultStrategyOptions() Properties FaultGenerator Gets or sets the fault generator to be used for fault injection. [Required] public Func<FaultGeneratorArguments, ValueTask<Exception?>>? FaultGenerator { get; set; } Property Value Func<FaultGeneratorArguments, ValueTask<Exception>> Defaults to null. This property is required. OnFaultInjected Gets or sets the delegate that's raised when the fault is injected. public Func<OnFaultInjectedArguments, ValueTask>? OnFaultInjected { get; set; } Property Value Func<OnFaultInjectedArguments, ValueTask> Defaults to null."
  },
  "api/Polly.Simmy.Fault.FaultGenerator.html": {
    "href": "api/Polly.Simmy.Fault.FaultGenerator.html",
    "title": "Class FaultGenerator | Polly",
    "keywords": "Class FaultGenerator Namespace Polly.Simmy.Fault Assembly Polly.Core.dll A generator for creating faults (exceptions) using registered delegate functions. public sealed class FaultGenerator Inheritance object FaultGenerator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks An instance of this class can be assigned to the FaultGenerator property. Constructors FaultGenerator() Initializes a new instance of the FaultGenerator class. public FaultGenerator() Methods AddException(Func<ResilienceContext, Exception>, int) Registers an exception generator delegate that accepts a ResilienceContext. public FaultGenerator AddException(Func<ResilienceContext, Exception> generator, int weight = 100) Parameters generator Func<ResilienceContext, Exception> The delegate that generates the exception, accepting a ResilienceContext. weight int The weight assigned to this generator. Defaults to 100. Returns FaultGenerator The current instance of FaultGenerator. AddException(Func<Exception>, int) Registers an exception generator delegate. public FaultGenerator AddException(Func<Exception> generator, int weight = 100) Parameters generator Func<Exception> The delegate that generates the exception. weight int The weight assigned to this generator. Defaults to 100. Returns FaultGenerator The current instance of FaultGenerator. AddException<TException>(int) Registers an exception generator for a specific exception type, using the default constructor of that exception. public FaultGenerator AddException<TException>(int weight = 100) where TException : Exception, new() Parameters weight int The weight assigned to this generator. Defaults to 100. Returns FaultGenerator The current instance of FaultGenerator. Type Parameters TException The type of the exception to generate."
  },
  "api/Polly.Simmy.Fault.FaultGeneratorArguments.html": {
    "href": "api/Polly.Simmy.Fault.FaultGeneratorArguments.html",
    "title": "Struct FaultGeneratorArguments | Polly",
    "keywords": "Struct FaultGeneratorArguments Namespace Polly.Simmy.Fault Assembly Polly.Core.dll Arguments used by the fault chaos strategy to ge the fault that is going to be injected. public readonly struct FaultGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors FaultGeneratorArguments(ResilienceContext) Initializes a new instance of the FaultGeneratorArguments struct. public FaultGeneratorArguments(ResilienceContext context) Parameters context ResilienceContext The resilience context instance. Properties Context Gets the resilience context instance. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Simmy.Fault.OnFaultInjectedArguments.html": {
    "href": "api/Polly.Simmy.Fault.OnFaultInjectedArguments.html",
    "title": "Struct OnFaultInjectedArguments | Polly",
    "keywords": "Struct OnFaultInjectedArguments Namespace Polly.Simmy.Fault Assembly Polly.Core.dll Arguments used by the fault chaos strategy to notify that an fault was injected. public readonly struct OnFaultInjectedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors OnFaultInjectedArguments(ResilienceContext, Exception) Initializes a new instance of the OnFaultInjectedArguments struct. public OnFaultInjectedArguments(ResilienceContext context, Exception fault) Parameters context ResilienceContext The resilience context instance. fault Exception The fault that was injected. Properties Context Gets the resilience context instance. public ResilienceContext Context { get; } Property Value ResilienceContext Fault Gets the fault that was injected. public Exception Fault { get; } Property Value Exception"
  },
  "api/Polly.Simmy.Fault.html": {
    "href": "api/Polly.Simmy.Fault.html",
    "title": "Namespace Polly.Simmy.Fault | Polly",
    "keywords": "Namespace Polly.Simmy.Fault Classes ChaosFaultStrategyOptions Represents the options for the fault chaos strategy. FaultGenerator A generator for creating faults (exceptions) using registered delegate functions. Structs FaultGeneratorArguments Arguments used by the fault chaos strategy to ge the fault that is going to be injected. OnFaultInjectedArguments Arguments used by the fault chaos strategy to notify that an fault was injected."
  },
  "api/Polly.Simmy.InjectionRateGeneratorArguments.html": {
    "href": "api/Polly.Simmy.InjectionRateGeneratorArguments.html",
    "title": "Struct InjectionRateGeneratorArguments | Polly",
    "keywords": "Struct InjectionRateGeneratorArguments Namespace Polly.Simmy Assembly Polly.Core.dll Defines the arguments for the InjectionRateGenerator. public readonly struct InjectionRateGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors InjectionRateGeneratorArguments(ResilienceContext) Initializes a new instance of the InjectionRateGeneratorArguments struct. public InjectionRateGeneratorArguments(ResilienceContext context) Parameters context ResilienceContext The resilience context instance. Properties Context Gets the ResilienceContext instance. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Simmy.Latency.ChaosLatencyStrategyOptions.html": {
    "href": "api/Polly.Simmy.Latency.ChaosLatencyStrategyOptions.html",
    "title": "Class ChaosLatencyStrategyOptions | Polly",
    "keywords": "Class ChaosLatencyStrategyOptions Namespace Polly.Simmy.Latency Assembly Polly.Core.dll Represents the options for the latency chaos strategy. public class ChaosLatencyStrategyOptions : ChaosStrategyOptions Inheritance object ResilienceStrategyOptions ChaosStrategyOptions ChaosLatencyStrategyOptions Inherited Members ChaosStrategyOptions.InjectionRate ChaosStrategyOptions.InjectionRateGenerator ChaosStrategyOptions.EnabledGenerator ChaosStrategyOptions.Enabled ChaosStrategyOptions.Randomizer ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ChaosLatencyStrategyOptions() Initializes a new instance of the ChaosLatencyStrategyOptions class. public ChaosLatencyStrategyOptions() Properties Latency Gets or sets the latency to be injected for a given execution. public TimeSpan Latency { get; set; } Property Value TimeSpan Defaults to 30 seconds. When LatencyGenerator is specified, this property is ignored. LatencyGenerator Gets or sets the latency generator that generates the delay for a given execution. public Func<LatencyGeneratorArguments, ValueTask<TimeSpan>>? LatencyGenerator { get; set; } Property Value Func<LatencyGeneratorArguments, ValueTask<TimeSpan>> Defaults to null. When this property is null the Latency is used. OnLatencyInjected Gets or sets the delegate that's raised when a latency is injected. public Func<OnLatencyInjectedArguments, ValueTask>? OnLatencyInjected { get; set; } Property Value Func<OnLatencyInjectedArguments, ValueTask> Defaults to null."
  },
  "api/Polly.Simmy.Latency.LatencyGeneratorArguments.html": {
    "href": "api/Polly.Simmy.Latency.LatencyGeneratorArguments.html",
    "title": "Struct LatencyGeneratorArguments | Polly",
    "keywords": "Struct LatencyGeneratorArguments Namespace Polly.Simmy.Latency Assembly Polly.Core.dll Arguments used by the LatencyGenerator. public readonly struct LatencyGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors LatencyGeneratorArguments(ResilienceContext) Initializes a new instance of the LatencyGeneratorArguments struct. public LatencyGeneratorArguments(ResilienceContext context) Parameters context ResilienceContext The resilience context instance. Properties Context Gets the resilience context instance. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Simmy.Latency.OnLatencyInjectedArguments.html": {
    "href": "api/Polly.Simmy.Latency.OnLatencyInjectedArguments.html",
    "title": "Struct OnLatencyInjectedArguments | Polly",
    "keywords": "Struct OnLatencyInjectedArguments Namespace Polly.Simmy.Latency Assembly Polly.Core.dll Arguments used by the latency chaos strategy to notify that a latency was injected. public readonly struct OnLatencyInjectedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors OnLatencyInjectedArguments(ResilienceContext, TimeSpan) Initializes a new instance of the OnLatencyInjectedArguments struct. public OnLatencyInjectedArguments(ResilienceContext context, TimeSpan latency) Parameters context ResilienceContext The resilience context instance. latency TimeSpan The latency that was injected. Properties Context Gets the resilience context instance. public ResilienceContext Context { get; } Property Value ResilienceContext Latency Gets the latency that was injected. public TimeSpan Latency { get; } Property Value TimeSpan"
  },
  "api/Polly.Simmy.Latency.html": {
    "href": "api/Polly.Simmy.Latency.html",
    "title": "Namespace Polly.Simmy.Latency | Polly",
    "keywords": "Namespace Polly.Simmy.Latency Classes ChaosLatencyStrategyOptions Represents the options for the latency chaos strategy. Structs LatencyGeneratorArguments Arguments used by the LatencyGenerator. OnLatencyInjectedArguments Arguments used by the latency chaos strategy to notify that a latency was injected."
  },
  "api/Polly.Simmy.Outcomes.ChaosOutcomeStrategyOptions-1.html": {
    "href": "api/Polly.Simmy.Outcomes.ChaosOutcomeStrategyOptions-1.html",
    "title": "Class ChaosOutcomeStrategyOptions<TResult> | Polly",
    "keywords": "Class ChaosOutcomeStrategyOptions<TResult> Namespace Polly.Simmy.Outcomes Assembly Polly.Core.dll Represents the options for the outcome chaos strategy. public class ChaosOutcomeStrategyOptions<TResult> : ChaosStrategyOptions Type Parameters TResult The type of the outcome that was injected. Inheritance object ResilienceStrategyOptions ChaosStrategyOptions ChaosOutcomeStrategyOptions<TResult> Inherited Members ChaosStrategyOptions.InjectionRate ChaosStrategyOptions.InjectionRateGenerator ChaosStrategyOptions.EnabledGenerator ChaosStrategyOptions.Enabled ChaosStrategyOptions.Randomizer ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ChaosOutcomeStrategyOptions() Initializes a new instance of the ChaosOutcomeStrategyOptions<TResult> class. public ChaosOutcomeStrategyOptions() Properties OnOutcomeInjected Gets or sets the delegate that's invoked when the outcome is injected. public Func<OnOutcomeInjectedArguments<TResult>, ValueTask>? OnOutcomeInjected { get; set; } Property Value Func<OnOutcomeInjectedArguments<TResult>, ValueTask> Defaults to null. OutcomeGenerator Gets or sets the generator that generates the outcomes to be injected. [Required] public Func<OutcomeGeneratorArguments, ValueTask<Outcome<TResult>?>> OutcomeGenerator { get; set; } Property Value Func<OutcomeGeneratorArguments, ValueTask<Outcome<TResult>?>> Defaults to null. This property is required."
  },
  "api/Polly.Simmy.Outcomes.OnOutcomeInjectedArguments-1.html": {
    "href": "api/Polly.Simmy.Outcomes.OnOutcomeInjectedArguments-1.html",
    "title": "Struct OnOutcomeInjectedArguments<TResult> | Polly",
    "keywords": "Struct OnOutcomeInjectedArguments<TResult> Namespace Polly.Simmy.Outcomes Assembly Polly.Core.dll Arguments used by the outcome chaos strategy to notify that an outcome was injected. public readonly struct OnOutcomeInjectedArguments<TResult> Type Parameters TResult The type of the outcome that was injected. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors OnOutcomeInjectedArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the OnOutcomeInjectedArguments<TResult> struct. public OnOutcomeInjectedArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The resilience context instance. outcome Outcome<TResult> The outcome that was injected. Properties Context Gets the resilience context instance. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome that was injected. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Simmy.Outcomes.OutcomeGenerator-1.html": {
    "href": "api/Polly.Simmy.Outcomes.OutcomeGenerator-1.html",
    "title": "Class OutcomeGenerator<TResult> | Polly",
    "keywords": "Class OutcomeGenerator<TResult> Namespace Polly.Simmy.Outcomes Assembly Polly.Core.dll Generator that produces outcomes such as exceptions or results. public sealed class OutcomeGenerator<TResult> Type Parameters TResult The type of the result. Inheritance object OutcomeGenerator<TResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks An instance of this class is assignable to OutcomeGenerator. Constructors OutcomeGenerator() Initializes a new instance of the OutcomeGenerator<TResult> class. public OutcomeGenerator() Methods AddException(Func<ResilienceContext, Exception>, int) Registers an exception generator delegate that accepts a ResilienceContext. public OutcomeGenerator<TResult> AddException(Func<ResilienceContext, Exception> generator, int weight = 100) Parameters generator Func<ResilienceContext, Exception> The delegate that generates the exception, accepting a ResilienceContext. weight int The weight assigned to this generator. Defaults to 100. Returns OutcomeGenerator<TResult> The current instance of OutcomeGenerator<TResult>. AddException(Func<Exception>, int) Registers an exception generator delegate. public OutcomeGenerator<TResult> AddException(Func<Exception> generator, int weight = 100) Parameters generator Func<Exception> The delegate that generates the exception. weight int The weight assigned to this generator. Defaults to 100. Returns OutcomeGenerator<TResult> The current instance of OutcomeGenerator<TResult>. AddException<TException>(int) Registers an exception generator for a specific exception type, using the default constructor of that exception. public OutcomeGenerator<TResult> AddException<TException>(int weight = 100) where TException : Exception, new() Parameters weight int The weight assigned to this generator. Defaults to 100. Returns OutcomeGenerator<TResult> The current instance of OutcomeGenerator<TResult>. Type Parameters TException The type of the exception to generate. AddResult(Func<ResilienceContext, TResult>, int) Registers a result generator. public OutcomeGenerator<TResult> AddResult(Func<ResilienceContext, TResult> generator, int weight = 100) Parameters generator Func<ResilienceContext, TResult> The delegate that generates the result, accepting a ResilienceContext. weight int The weight assigned to this generator. Defaults to 100. Returns OutcomeGenerator<TResult> The current instance of OutcomeGenerator<TResult>. AddResult(Func<TResult>, int) Registers a result generator. public OutcomeGenerator<TResult> AddResult(Func<TResult> generator, int weight = 100) Parameters generator Func<TResult> The delegate that generates the result. weight int The weight assigned to this generator. Defaults to 100. Returns OutcomeGenerator<TResult> The current instance of OutcomeGenerator<TResult>."
  },
  "api/Polly.Simmy.Outcomes.OutcomeGeneratorArguments.html": {
    "href": "api/Polly.Simmy.Outcomes.OutcomeGeneratorArguments.html",
    "title": "Struct OutcomeGeneratorArguments | Polly",
    "keywords": "Struct OutcomeGeneratorArguments Namespace Polly.Simmy.Outcomes Assembly Polly.Core.dll Arguments used by OutcomeGenerator. public readonly struct OutcomeGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors OutcomeGeneratorArguments(ResilienceContext) Initializes a new instance of the OutcomeGeneratorArguments struct. public OutcomeGeneratorArguments(ResilienceContext context) Parameters context ResilienceContext The resilience context instance. Properties Context Gets the resilience context instance. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Simmy.Outcomes.html": {
    "href": "api/Polly.Simmy.Outcomes.html",
    "title": "Namespace Polly.Simmy.Outcomes | Polly",
    "keywords": "Namespace Polly.Simmy.Outcomes Classes ChaosOutcomeStrategyOptions<TResult> Represents the options for the outcome chaos strategy. OutcomeGenerator<TResult> Generator that produces outcomes such as exceptions or results. Structs OnOutcomeInjectedArguments<TResult> Arguments used by the outcome chaos strategy to notify that an outcome was injected. OutcomeGeneratorArguments Arguments used by OutcomeGenerator."
  },
  "api/Polly.Simmy.html": {
    "href": "api/Polly.Simmy.html",
    "title": "Namespace Polly.Simmy | Polly",
    "keywords": "Namespace Polly.Simmy Classes ChaosBehaviorPipelineBuilderExtensions Extension methods for adding chaos behaviors to a ResiliencePipelineBuilder. ChaosFaultPipelineBuilderExtensions Extension methods for adding chaos fault strategy to a ResiliencePipelineBuilder. ChaosLatencyPipelineBuilderExtensions Extension methods for adding chaos latency strategies to a ResiliencePipelineBuilderBase. ChaosOutcomePipelineBuilderExtensions Extension methods for adding chaos outcome strategy to a ResiliencePipelineBuilder. ChaosStrategy Base class for chaos strategies. ChaosStrategyOptions The options associated with the ChaosStrategy. ChaosStrategy<T> Base class for generic (reactive) chaos strategies. Structs EnabledGeneratorArguments Defines the arguments for the EnabledGenerator. InjectionRateGeneratorArguments Defines the arguments for the InjectionRateGenerator."
  },
  "api/Polly.StrategyBuilderContext.html": {
    "href": "api/Polly.StrategyBuilderContext.html",
    "title": "Class StrategyBuilderContext | Polly",
    "keywords": "Class StrategyBuilderContext Namespace Polly Assembly Polly.Core.dll The context used for building an individual resilience strategy. public sealed class StrategyBuilderContext Inheritance object StrategyBuilderContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Telemetry Gets the resilience telemetry used to report important events. public ResilienceStrategyTelemetry Telemetry { get; } Property Value ResilienceStrategyTelemetry TimeProvider Gets the TimeProvider used by this strategy. public TimeProvider TimeProvider { get; } Property Value TimeProvider"
  },
  "api/Polly.Telemetry.EnrichmentContext-2.html": {
    "href": "api/Polly.Telemetry.EnrichmentContext-2.html",
    "title": "Struct EnrichmentContext<TResult, TArgs> | Polly",
    "keywords": "Struct EnrichmentContext<TResult, TArgs> Namespace Polly.Telemetry Assembly Polly.Extensions.dll Enrichment context used when reporting resilience events. public readonly struct EnrichmentContext<TResult, TArgs> Type Parameters TResult The type of the result. TArgs The type of the arguments attached to the resilience event. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This context is passed to enrichers in MeteringEnrichers. Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors EnrichmentContext(in TelemetryEventArguments<TResult, TArgs>, IList<KeyValuePair<string, object?>>) Initializes a new instance of the EnrichmentContext<TResult, TArgs> struct. public EnrichmentContext(in TelemetryEventArguments<TResult, TArgs> telemetryEvent, IList<KeyValuePair<string, object?>> tags) Parameters telemetryEvent TelemetryEventArguments<TResult, TArgs> The telemetry event info. tags IList<KeyValuePair<string, object>> Tags associated with the resilience event. Properties Tags Gets the tags associated with the resilience event. public IList<KeyValuePair<string, object?>> Tags { get; } Property Value IList<KeyValuePair<string, object>> Remarks Custom enricher can add tags to this collection. TelemetryEvent Gets the info about the telemetry event. public TelemetryEventArguments<TResult, TArgs> TelemetryEvent { get; } Property Value TelemetryEventArguments<TResult, TArgs>"
  },
  "api/Polly.Telemetry.ExecutionAttemptArguments.html": {
    "href": "api/Polly.Telemetry.ExecutionAttemptArguments.html",
    "title": "Struct ExecutionAttemptArguments | Polly",
    "keywords": "Struct ExecutionAttemptArguments Namespace Polly.Telemetry Assembly Polly.Core.dll Arguments that encapsulate the execution attempt for retries or hedging. public readonly struct ExecutionAttemptArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors ExecutionAttemptArguments(int, TimeSpan, bool) Initializes a new instance of the ExecutionAttemptArguments struct. public ExecutionAttemptArguments(int attemptNumber, TimeSpan duration, bool handled) Parameters attemptNumber int The execution attempt number. duration TimeSpan The execution duration. handled bool Determines whether the attempt was handled by the strategy. Properties AttemptNumber Gets the attempt number. public int AttemptNumber { get; } Property Value int Duration Gets the execution duration of the attempt. public TimeSpan Duration { get; } Property Value TimeSpan Handled Gets a value indicating whether the outcome was handled by retry or hedging strategy. public bool Handled { get; } Property Value bool"
  },
  "api/Polly.Telemetry.MeteringEnricher.html": {
    "href": "api/Polly.Telemetry.MeteringEnricher.html",
    "title": "Class MeteringEnricher | Polly",
    "keywords": "Class MeteringEnricher Namespace Polly.Telemetry Assembly Polly.Extensions.dll Enricher used to enrich the metrics with additional information. public abstract class MeteringEnricher Inheritance object MeteringEnricher Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs>) Enriches the metrics with additional information. public abstract void Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs> context) Parameters context EnrichmentContext<TResult, TArgs> The enrichment context. Type Parameters TResult The type of result. TArgs The type of arguments."
  },
  "api/Polly.Telemetry.PipelineExecutedArguments.html": {
    "href": "api/Polly.Telemetry.PipelineExecutedArguments.html",
    "title": "Struct PipelineExecutedArguments | Polly",
    "keywords": "Struct PipelineExecutedArguments Namespace Polly.Telemetry Assembly Polly.Core.dll Arguments that indicate the pipeline execution started. public readonly struct PipelineExecutedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors PipelineExecutedArguments(TimeSpan) Initializes a new instance of the PipelineExecutedArguments struct. public PipelineExecutedArguments(TimeSpan duration) Parameters duration TimeSpan The pipeline execution duration. Properties Duration Gets the pipeline execution duration. public TimeSpan Duration { get; } Property Value TimeSpan"
  },
  "api/Polly.Telemetry.PipelineExecutingArguments.html": {
    "href": "api/Polly.Telemetry.PipelineExecutingArguments.html",
    "title": "Struct PipelineExecutingArguments | Polly",
    "keywords": "Struct PipelineExecutingArguments Namespace Polly.Telemetry Assembly Polly.Core.dll Arguments that indicate the pipeline execution started. public readonly struct PipelineExecutingArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility."
  },
  "api/Polly.Telemetry.ResilienceEvent.html": {
    "href": "api/Polly.Telemetry.ResilienceEvent.html",
    "title": "Struct ResilienceEvent | Polly",
    "keywords": "Struct ResilienceEvent Namespace Polly.Telemetry Assembly Polly.Core.dll Represents a resilience event that has been reported. public readonly struct ResilienceEvent Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors ResilienceEvent(ResilienceEventSeverity, string) Initializes a new instance of the ResilienceEvent struct. public ResilienceEvent(ResilienceEventSeverity severity, string eventName) Parameters severity ResilienceEventSeverity The severity of the event. eventName string The event name. Properties EventName Gets the event name. public string EventName { get; } Property Value string Severity Gets the severity of the event. public ResilienceEventSeverity Severity { get; } Property Value ResilienceEventSeverity Methods ToString() Returns an EventName. public override string ToString() Returns string An event name."
  },
  "api/Polly.Telemetry.ResilienceEventSeverity.html": {
    "href": "api/Polly.Telemetry.ResilienceEventSeverity.html",
    "title": "Enum ResilienceEventSeverity | Polly",
    "keywords": "Enum ResilienceEventSeverity Namespace Polly.Telemetry Assembly Polly.Core.dll The severity of reported resilience event. public enum ResilienceEventSeverity Fields Critical = 5 The resilience event should be treated as a critical error. Debug = 1 The resilience event is used for debugging purposes only. Error = 4 The resilience event should be treated as an error. Information = 2 The resilience event is informational. None = 0 The resilience event is not recorded. Warning = 3 The resilience event should be treated as a warning."
  },
  "api/Polly.Telemetry.ResilienceStrategyTelemetry.html": {
    "href": "api/Polly.Telemetry.ResilienceStrategyTelemetry.html",
    "title": "Class ResilienceStrategyTelemetry | Polly",
    "keywords": "Class ResilienceStrategyTelemetry Namespace Polly.Telemetry Assembly Polly.Core.dll Resilience telemetry is used by individual resilience strategies to report some important events. public sealed class ResilienceStrategyTelemetry Inheritance object ResilienceStrategyTelemetry Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks For example, the timeout strategy reports \"OnTimeout\" event when the timeout is reached or \"OnRetry\" for retry strategy. Methods Report<TArgs>(ResilienceEvent, ResilienceContext, TArgs) Reports an event that occurred in a resilience strategy. public void Report<TArgs>(ResilienceEvent resilienceEvent, ResilienceContext context, TArgs args) Parameters resilienceEvent ResilienceEvent The reported resilience event. context ResilienceContext The resilience context associated with this event. args TArgs The event arguments. Type Parameters TArgs The arguments associated with this event. Exceptions ArgumentNullException Thrown when context is null. Report<TArgs, TResult>(ResilienceEvent, ResilienceContext, Outcome<TResult>, TArgs) Reports an event that occurred in a resilience strategy. public void Report<TArgs, TResult>(ResilienceEvent resilienceEvent, ResilienceContext context, Outcome<TResult> outcome, TArgs args) Parameters resilienceEvent ResilienceEvent The reported resilience event. context ResilienceContext The resilience context associated with this event. outcome Outcome<TResult> The outcome associated with the event. args TArgs The event arguments. Type Parameters TArgs The arguments associated with this event. TResult The type of the result."
  },
  "api/Polly.Telemetry.ResilienceTelemetrySource.html": {
    "href": "api/Polly.Telemetry.ResilienceTelemetrySource.html",
    "title": "Class ResilienceTelemetrySource | Polly",
    "keywords": "Class ResilienceTelemetrySource Namespace Polly.Telemetry Assembly Polly.Core.dll The source of resilience telemetry events. public sealed class ResilienceTelemetrySource Inheritance object ResilienceTelemetrySource Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks This class is used by the telemetry infrastructure and should not be used directly by user code. Constructors ResilienceTelemetrySource(string?, string?, string?) Initializes a new instance of the ResilienceTelemetrySource class. public ResilienceTelemetrySource(string? pipelineName, string? pipelineInstanceName, string? strategyName) Parameters pipelineName string The pipeline name. pipelineInstanceName string The pipeline instance name. strategyName string The strategy name. Properties PipelineInstanceName Gets the pipeline instance name. public string? PipelineInstanceName { get; } Property Value string PipelineName Gets the pipeline name. public string? PipelineName { get; } Property Value string StrategyName Gets the strategy name. public string? StrategyName { get; } Property Value string"
  },
  "api/Polly.Telemetry.TelemetryEventArguments-2.html": {
    "href": "api/Polly.Telemetry.TelemetryEventArguments-2.html",
    "title": "Struct TelemetryEventArguments<TResult, TArgs> | Polly",
    "keywords": "Struct TelemetryEventArguments<TResult, TArgs> Namespace Polly.Telemetry Assembly Polly.Core.dll Represents the information about the resilience event. public readonly struct TelemetryEventArguments<TResult, TArgs> Type Parameters TResult The type of result. TArgs The arguments associated with the resilience event. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors TelemetryEventArguments(ResilienceTelemetrySource, ResilienceEvent, ResilienceContext, TArgs, Outcome<TResult>?) Initializes a new instance of the TelemetryEventArguments<TResult, TArgs> struct. public TelemetryEventArguments(ResilienceTelemetrySource source, ResilienceEvent resilienceEvent, ResilienceContext context, TArgs args, Outcome<TResult>? outcome) Parameters source ResilienceTelemetrySource The source that produced the resilience event. resilienceEvent ResilienceEvent The resilience event. context ResilienceContext The context associated with the resilience event. args TArgs The arguments associated with the resilience event. outcome Outcome<TResult>? The outcome associated with the resilience event, if any. Properties Arguments Gets the arguments associated with the resilience event. public TArgs Arguments { get; } Property Value TArgs Context Gets the context associated with the resilience event. public ResilienceContext Context { get; } Property Value ResilienceContext Event Gets the resilience event. public ResilienceEvent Event { get; } Property Value ResilienceEvent Outcome Gets the outcome associated with the resilience event, if any. public Outcome<TResult>? Outcome { get; } Property Value Outcome<TResult>? Source Gets the source that produced the resilience event. public ResilienceTelemetrySource Source { get; } Property Value ResilienceTelemetrySource"
  },
  "api/Polly.Telemetry.TelemetryListener.html": {
    "href": "api/Polly.Telemetry.TelemetryListener.html",
    "title": "Class TelemetryListener | Polly",
    "keywords": "Class TelemetryListener Namespace Polly.Telemetry Assembly Polly.Core.dll Listener of resilience telemetry events. public abstract class TelemetryListener Inheritance object TelemetryListener Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Write<TResult, TArgs>(in TelemetryEventArguments<TResult, TArgs>) Writes a resilience event to the listener. public abstract void Write<TResult, TArgs>(in TelemetryEventArguments<TResult, TArgs> args) Parameters args TelemetryEventArguments<TResult, TArgs> The arguments associated with the event. Type Parameters TResult The result type. TArgs The type of arguments associated with the event."
  },
  "api/Polly.Telemetry.TelemetryOptions.html": {
    "href": "api/Polly.Telemetry.TelemetryOptions.html",
    "title": "Class TelemetryOptions | Polly",
    "keywords": "Class TelemetryOptions Namespace Polly.Telemetry Assembly Polly.Extensions.dll The options that are used to configure the telemetry that is produced by the resilience strategies. public class TelemetryOptions Inheritance object TelemetryOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties LoggerFactory Gets or sets the logger factory. [Required] public ILoggerFactory LoggerFactory { get; set; } Property Value ILoggerFactory The default value is Instance. MeteringEnrichers Gets the collection of telemetry enrichers. public ICollection<MeteringEnricher> MeteringEnrichers { get; } Property Value ICollection<MeteringEnricher> The default value is an empty collection. ResultFormatter Gets or sets the result formatter. [Required] public Func<ResilienceContext, object?, object?> ResultFormatter { get; set; } Property Value Func<ResilienceContext, object, object> The default value is a formatter that returns a status code for HTTP based responses and the result as-is for all other result types. This property is required. TelemetryListeners Gets the collection of telemetry listeners. public ICollection<TelemetryListener> TelemetryListeners { get; } Property Value ICollection<TelemetryListener> The default value is an empty collection."
  },
  "api/Polly.Telemetry.html": {
    "href": "api/Polly.Telemetry.html",
    "title": "Namespace Polly.Telemetry | Polly",
    "keywords": "Namespace Polly.Telemetry Classes MeteringEnricher Enricher used to enrich the metrics with additional information. ResilienceStrategyTelemetry Resilience telemetry is used by individual resilience strategies to report some important events. ResilienceTelemetrySource The source of resilience telemetry events. TelemetryListener Listener of resilience telemetry events. TelemetryOptions The options that are used to configure the telemetry that is produced by the resilience strategies. Structs EnrichmentContext<TResult, TArgs> Enrichment context used when reporting resilience events. ExecutionAttemptArguments Arguments that encapsulate the execution attempt for retries or hedging. PipelineExecutedArguments Arguments that indicate the pipeline execution started. PipelineExecutingArguments Arguments that indicate the pipeline execution started. ResilienceEvent Represents a resilience event that has been reported. TelemetryEventArguments<TResult, TArgs> Represents the information about the resilience event. Enums ResilienceEventSeverity The severity of reported resilience event."
  },
  "api/Polly.TelemetryResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.TelemetryResiliencePipelineBuilderExtensions.html",
    "title": "Class TelemetryResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class TelemetryResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Extensions.dll The telemetry extensions for the ResiliencePipelineBuilder. public static class TelemetryResiliencePipelineBuilderExtensions Inheritance object TelemetryResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ConfigureTelemetry<TBuilder>(TBuilder, ILoggerFactory) Enables telemetry for this builder. public static TBuilder ConfigureTelemetry<TBuilder>(this TBuilder builder, ILoggerFactory loggerFactory) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. loggerFactory ILoggerFactory The logger factory to be used for logging. Returns TBuilder The builder instance with the telemetry enabled. Type Parameters TBuilder The builder type. Remarks By enabling telemetry, the resilience pipeline will log and meter all resilience events. Additionally, the telemetry strategy that logs and meters the executions is added to the beginning of the composite strategy. Exceptions ArgumentNullException Thrown when builder or loggerFactory is null. ConfigureTelemetry<TBuilder>(TBuilder, TelemetryOptions) Enables telemetry for this builder. public static TBuilder ConfigureTelemetry<TBuilder>(this TBuilder builder, TelemetryOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options TelemetryOptions The resilience telemetry options. Returns TBuilder The builder instance with the telemetry enabled. Type Parameters TBuilder The builder type. Remarks By enabling telemetry, the resilience pipeline will log and meter all resilience events. Additionally, the telemetry strategy that logs and meters the executions is added to the beginning of the composite strategy. Exceptions ArgumentNullException Thrown when builder or options is null."
  },
  "api/Polly.Testing.ResiliencePipelineDescriptor.html": {
    "href": "api/Polly.Testing.ResiliencePipelineDescriptor.html",
    "title": "Class ResiliencePipelineDescriptor | Polly",
    "keywords": "Class ResiliencePipelineDescriptor Namespace Polly.Testing Assembly Polly.Testing.dll Describes the resilience pipeline. public sealed class ResiliencePipelineDescriptor Inheritance object ResiliencePipelineDescriptor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties FirstStrategy Gets the first strategy of the pipeline. public ResilienceStrategyDescriptor FirstStrategy { get; } Property Value ResilienceStrategyDescriptor IsReloadable Gets a value indicating whether the resilience pipeline is reloadable. public bool IsReloadable { get; } Property Value bool Strategies Gets the strategies the pipeline is composed of. public IReadOnlyList<ResilienceStrategyDescriptor> Strategies { get; } Property Value IReadOnlyList<ResilienceStrategyDescriptor>"
  },
  "api/Polly.Testing.ResiliencePipelineExtensions.html": {
    "href": "api/Polly.Testing.ResiliencePipelineExtensions.html",
    "title": "Class ResiliencePipelineExtensions | Polly",
    "keywords": "Class ResiliencePipelineExtensions Namespace Polly.Testing Assembly Polly.Testing.dll The test-related extensions for ResiliencePipeline and ResiliencePipeline<T>. public static class ResiliencePipelineExtensions Inheritance object ResiliencePipelineExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetPipelineDescriptor(ResiliencePipeline) Gets the pipeline descriptor. public static ResiliencePipelineDescriptor GetPipelineDescriptor(this ResiliencePipeline pipeline) Parameters pipeline ResiliencePipeline The pipeline instance. Returns ResiliencePipelineDescriptor A pipeline descriptor. Exceptions ArgumentNullException Thrown when pipeline is null. GetPipelineDescriptor<TResult>(ResiliencePipeline<TResult>) Gets the pipeline descriptor. public static ResiliencePipelineDescriptor GetPipelineDescriptor<TResult>(this ResiliencePipeline<TResult> pipeline) Parameters pipeline ResiliencePipeline<TResult> The pipeline instance. Returns ResiliencePipelineDescriptor A pipeline descriptor. Type Parameters TResult The type of result. Exceptions ArgumentNullException Thrown when pipeline is null."
  },
  "api/Polly.Testing.ResilienceStrategyDescriptor.html": {
    "href": "api/Polly.Testing.ResilienceStrategyDescriptor.html",
    "title": "Class ResilienceStrategyDescriptor | Polly",
    "keywords": "Class ResilienceStrategyDescriptor Namespace Polly.Testing Assembly Polly.Testing.dll This class provides additional information about a ResiliencePipeline. public sealed class ResilienceStrategyDescriptor Inheritance object ResilienceStrategyDescriptor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Options Gets the options used by the resilience strategy, if any. public ResilienceStrategyOptions? Options { get; } Property Value ResilienceStrategyOptions StrategyInstance Gets the strategy instance. public object StrategyInstance { get; } Property Value object"
  },
  "api/Polly.Testing.html": {
    "href": "api/Polly.Testing.html",
    "title": "Namespace Polly.Testing | Polly",
    "keywords": "Namespace Polly.Testing Classes ResiliencePipelineDescriptor Describes the resilience pipeline. ResiliencePipelineExtensions The test-related extensions for ResiliencePipeline and ResiliencePipeline<T>. ResilienceStrategyDescriptor This class provides additional information about a ResiliencePipeline."
  },
  "api/Polly.Timeout.OnTimeoutArguments.html": {
    "href": "api/Polly.Timeout.OnTimeoutArguments.html",
    "title": "Struct OnTimeoutArguments | Polly",
    "keywords": "Struct OnTimeoutArguments Namespace Polly.Timeout Assembly Polly.Core.dll Arguments used by the timeout strategy to notify that a timeout occurred. public readonly struct OnTimeoutArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnTimeoutArguments(ResilienceContext, TimeSpan) Initializes a new instance of the OnTimeoutArguments struct. public OnTimeoutArguments(ResilienceContext context, TimeSpan timeout) Parameters context ResilienceContext The context associated with the execution of a user-provided callback. timeout TimeSpan The timeout value assigned. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext Timeout Gets the timeout value assigned. public TimeSpan Timeout { get; } Property Value TimeSpan"
  },
  "api/Polly.Timeout.TimeoutGeneratorArguments.html": {
    "href": "api/Polly.Timeout.TimeoutGeneratorArguments.html",
    "title": "Struct TimeoutGeneratorArguments | Polly",
    "keywords": "Struct TimeoutGeneratorArguments Namespace Polly.Timeout Assembly Polly.Core.dll Arguments used by the timeout strategy to retrieve a timeout for current execution. public readonly struct TimeoutGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors TimeoutGeneratorArguments(ResilienceContext) Initializes a new instance of the TimeoutGeneratorArguments struct. public TimeoutGeneratorArguments(ResilienceContext context) Parameters context ResilienceContext The context associated with the execution of a user-provided callback. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Timeout.TimeoutRejectedException.html": {
    "href": "api/Polly.Timeout.TimeoutRejectedException.html",
    "title": "Class TimeoutRejectedException | Polly",
    "keywords": "Class TimeoutRejectedException Namespace Polly.Timeout Assembly Polly.Core.dll Exception thrown when a delegate executed through a timeout resilience strategy does not complete, before the configured timeout. public class TimeoutRejectedException : ExecutionRejectedException, ISerializable Inheritance object Exception ExecutionRejectedException TimeoutRejectedException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors TimeoutRejectedException() Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException() TimeoutRejectedException(string) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(string message) Parameters message string The message. TimeoutRejectedException(string, Exception) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(string message, Exception innerException) Parameters message string The message. innerException Exception The inner exception. TimeoutRejectedException(string, TimeSpan) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(string message, TimeSpan timeout) Parameters message string The message. timeout TimeSpan The timeout value that caused this exception. TimeoutRejectedException(string, TimeSpan, Exception) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(string message, TimeSpan timeout, Exception innerException) Parameters message string The message. timeout TimeSpan The timeout value that caused this exception. innerException Exception The inner exception. TimeoutRejectedException(TimeSpan) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(TimeSpan timeout) Parameters timeout TimeSpan The timeout value that caused this exception. Properties Timeout Gets the timeout value that caused this exception. public TimeSpan Timeout { get; } Property Value TimeSpan"
  },
  "api/Polly.Timeout.TimeoutStrategyOptions.html": {
    "href": "api/Polly.Timeout.TimeoutStrategyOptions.html",
    "title": "Class TimeoutStrategyOptions | Polly",
    "keywords": "Class TimeoutStrategyOptions Namespace Polly.Timeout Assembly Polly.Core.dll Represents the options for the timeout strategy. public class TimeoutStrategyOptions : ResilienceStrategyOptions Inheritance object ResilienceStrategyOptions TimeoutStrategyOptions Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TimeoutStrategyOptions() Initializes a new instance of the TimeoutStrategyOptions class. public TimeoutStrategyOptions() Properties OnTimeout Gets or sets the timeout delegate that raised when timeout occurs. public Func<OnTimeoutArguments, ValueTask>? OnTimeout { get; set; } Property Value Func<OnTimeoutArguments, ValueTask> The default value is null. Timeout Gets or sets the default timeout. [Range(typeof(TimeSpan), \"00:00:00.010\", \"1.00:00:00\")] public TimeSpan Timeout { get; set; } Property Value TimeSpan This value must be greater than 10 milliseconds and less than 24 hours. The default value is 30 seconds. TimeoutGenerator Gets or sets a timeout generator that generates the timeout for a given execution. public Func<TimeoutGeneratorArguments, ValueTask<TimeSpan>>? TimeoutGenerator { get; set; } Property Value Func<TimeoutGeneratorArguments, ValueTask<TimeSpan>> The default value is null. Remarks If generator returns a TimeSpan value that is less or equal to Zero its value is ignored and Timeout is used instead. When generator is null the Timeout is used. Return InfiniteTimeSpan to disable the timeout for the given execution."
  },
  "api/Polly.Timeout.html": {
    "href": "api/Polly.Timeout.html",
    "title": "Namespace Polly.Timeout | Polly",
    "keywords": "Namespace Polly.Timeout Classes TimeoutRejectedException Exception thrown when a delegate executed through a timeout resilience strategy does not complete, before the configured timeout. TimeoutStrategyOptions Represents the options for the timeout strategy. Structs OnTimeoutArguments Arguments used by the timeout strategy to notify that a timeout occurred. TimeoutGeneratorArguments Arguments used by the timeout strategy to retrieve a timeout for current execution."
  },
  "api/Polly.TimeoutResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.TimeoutResiliencePipelineBuilderExtensions.html",
    "title": "Class TimeoutResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class TimeoutResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for adding timeout to ResiliencePipelineBuilder. public static class TimeoutResiliencePipelineBuilderExtensions Inheritance object TimeoutResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddTimeout<TBuilder>(TBuilder, TimeoutStrategyOptions) Adds a timeout to the builder. public static TBuilder AddTimeout<TBuilder>(this TBuilder builder, TimeoutStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options TimeoutStrategyOptions The timeout options. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. AddTimeout<TBuilder>(TBuilder, TimeSpan) Adds a timeout to the builder. public static TBuilder AddTimeout<TBuilder>(this TBuilder builder, TimeSpan timeout) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. timeout TimeSpan The timeout value. This value should be greater than Zero. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder is null. ValidationException Thrown when the options produced from the arguments are invalid."
  },
  "api/Polly.html": {
    "href": "api/Polly.html",
    "title": "Namespace Polly | Polly",
    "keywords": "Namespace Polly Classes CircuitBreakerResiliencePipelineBuilderExtensions Circuit breaker extensions for ResiliencePipelineBuilder. ExecutionRejectedException Exception thrown when a policy rejects execution of a delegate. More specific exceptions which derive from this type, are generally thrown. FallbackResiliencePipelineBuilderExtensions Extensions for adding fallback to ResiliencePipelineBuilder. HedgingResiliencePipelineBuilderExtensions Extensions for adding hedging to ResiliencePipelineBuilder. Outcome Produces instances of Outcome<TResult>. PollyServiceCollectionExtensions Provides extension methods for registering resilience pipelines using the IServiceCollection. PredicateBuilder Defines a builder for creating exception predicates. PredicateBuilder<TResult> Defines a builder for creating predicates for TResult and Exception combinations. PredicateResult Class that represents the results that can be used in predicates. RateLimiterResiliencePipelineBuilderExtensions Extensions for adding rate limiting to ResiliencePipelineBuilder. ResilienceContext A context assigned to a single execution of ResiliencePipeline. It is created manually or automatically when the user calls the various extensions on top of ResiliencePipeline. After every execution the context should be discarded and returned to the pool. ResilienceContextPool The pool of ResilienceContext instances. ResiliencePipeline Resilience pipeline is used to execute the user-provided callbacks. ResiliencePipelineBuilder A builder that is used to create an instance of ResiliencePipeline. ResiliencePipelineBuilderBase A builder that is used to create an instance of ResiliencePipeline. ResiliencePipelineBuilderExtensions Extensions for ResiliencePipelineBuilderBase. ResiliencePipelineBuilder<TResult> A builder that is used to create an instance of ResiliencePipeline<T>. ResiliencePipeline<T> Resilience pipeline is used to execute the user-provided callbacks. ResilienceProperties Represents a collection of custom resilience properties. ResilienceStrategy Base class for all proactive resilience strategies. ResilienceStrategyOptions The options associated with the individual resilience strategy. ResilienceStrategy<TResult> This base strategy class is used to simplify the implementation of generic (reactive) strategies by limiting the number of generic types the execute method receives. RetryResiliencePipelineBuilderExtensions Extensions for adding retries to ResiliencePipelineBuilder. StrategyBuilderContext The context used for building an individual resilience strategy. TelemetryResiliencePipelineBuilderExtensions The telemetry extensions for the ResiliencePipelineBuilder. TimeoutResiliencePipelineBuilderExtensions Extensions for adding timeout to ResiliencePipelineBuilder. Structs Outcome<TResult> Represents the outcome of an operation which could be a result of type TResult or an exception. ResilienceContextCreationArguments Arguments used by the ResilienceContextPool when creating ResilienceContext. ResiliencePropertyKey<TValue> Represents a key used by ResilienceProperties. Enums DelayBackoffType The backoff type used by the strategies."
  },
  "api/Snippets.Docs.MyApi.html": {
    "href": "api/Snippets.Docs.MyApi.html",
    "title": "Class MyApi | Polly",
    "keywords": "Class MyApi Namespace Snippets.Docs Assembly Snippets.dll public class MyApi Inheritance object MyApi Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MyApi(ResiliencePipelineProvider<string>) public MyApi(ResiliencePipelineProvider<string> pipelineProvider) Parameters pipelineProvider ResiliencePipelineProvider<string> Methods ExecuteAsync(CancellationToken) public Task ExecuteAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Returns Task"
  },
  "api/Snippets.Docs.MyApiExtensions.html": {
    "href": "api/Snippets.Docs.MyApiExtensions.html",
    "title": "Class MyApiExtensions | Polly",
    "keywords": "Class MyApiExtensions Namespace Snippets.Docs Assembly Snippets.dll public static class MyApiExtensions Inheritance object MyApiExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddMyApi(IServiceCollection) public static IServiceCollection AddMyApi(this IServiceCollection services) Parameters services IServiceCollection Returns IServiceCollection"
  },
  "api/Snippets.Docs.html": {
    "href": "api/Snippets.Docs.html",
    "title": "Namespace Snippets.Docs | Polly",
    "keywords": "Namespace Snippets.Docs Classes MyApi MyApiExtensions"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | Polly",
    "keywords": "PLACEHOLDER docfx automatically generates this file when GitHub Pages are built."
  },
  "chaos/behavior.html": {
    "href": "chaos/behavior.html",
    "title": "Behavior chaos strategy | Polly",
    "keywords": "Behavior chaos strategy About Options: ChaosBehaviorStrategyOptions Extensions: AddChaosBehavior Strategy Type: Proactive The behavior chaos strategy is designed to inject custom behaviors into system operations right before such an operation is invoked. This strategy is flexible, allowing users to define specific behaviors such as altering the input, simulating resource exhaustion, putting the system in a given state before the actual operation is called, or other operational variations to simulate real-world scenarios. Usage // To use a custom delegated for injected behavior var optionsWithBehaviorGenerator = new ChaosBehaviorStrategyOptions { BehaviorGenerator = static args => RestartRedisAsync(args.Context.CancellationToken), InjectionRate = 0.05 }; // To get notifications when a behavior is injected var optionsOnBehaviorInjected = new ChaosBehaviorStrategyOptions { BehaviorGenerator = static args => RestartRedisAsync(args.Context.CancellationToken), InjectionRate = 0.05, OnBehaviorInjected = static args => { Console.WriteLine(\"OnBehaviorInjected, Operation: {0}.\", args.Context.OperationKey); return default; } }; // Add a behavior strategy with a ChaosBehaviorStrategyOptions instance to the pipeline new ResiliencePipelineBuilder().AddChaosBehavior(optionsWithBehaviorGenerator); new ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosBehavior(optionsOnBehaviorInjected); // There are also a handy overload to inject the chaos easily new ResiliencePipelineBuilder().AddChaosBehavior(0.05, RestartRedisAsync); Example execution: var pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<RedisConnectionException>(), BackoffType = DelayBackoffType.Exponential, UseJitter = true, // Adds a random factor to the delay MaxRetryAttempts = 4, Delay = TimeSpan.FromSeconds(3), }) .AddChaosBehavior(new ChaosBehaviorStrategyOptions // Chaos strategies are usually placed as the last ones in the pipeline { BehaviorGenerator = static args => RestartRedisAsync(args.Context.CancellationToken), InjectionRate = 0.05 }) .Build(); Defaults Property Default Value Description OnBehaviorInjected null Action executed when the behavior is injected. BehaviorGenerator null Custom behavior to be injected. Diagrams Normal 🐵 sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant B as Behavior participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>B: Calls ExecuteCore activate B B-->>B: Determines Injection<br/>Decision: 🐵 deactivate B B->>+D: Invokes D->>-B: Returns result B->>P: Returns result P->>C: Returns result Chaos 🙈 sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant B as Behavior participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>B: Calls ExecuteCore activate B B-->>B: Determines Injection<br/>Decision: 🙈 B-->>B: Injects Behavior deactivate B B->>+D: Invokes D->>-B: Returns result B->>P: Returns result P->>C: Returns result Anti-patterns Injecting delay ❌ DON'T Use behavior strategies to inject delays. var pipeline = new ResiliencePipelineBuilder() .AddChaosBehavior(new ChaosBehaviorStrategyOptions { BehaviorGenerator = static async args => { await Task.Delay(TimeSpan.FromSeconds(7), args.Context.CancellationToken); } }) .Build(); ✅ DO Use the latency chaos instead as the ChaosLatencyStrategy already correctly handles synchronous/asynchronous delay executions, cancellations, etc. var pipeline = new ResiliencePipelineBuilder() .AddChaosLatency(new ChaosLatencyStrategyOptions { Latency = TimeSpan.FromSeconds(7), }) .Build();"
  },
  "chaos/fault.html": {
    "href": "chaos/fault.html",
    "title": "Fault chaos strategy | Polly",
    "keywords": "Fault chaos strategy About Options: ChaosFaultStrategyOptions Extensions: AddChaosFault Strategy Type: Proactive The fault chaos strategy is designed to introduce faults (exceptions) into the system, simulating real-world scenarios where operations might fail unexpectedly. It is configurable to inject specific types of exceptions or use custom logic to generate faults dynamically. Usage // 10% of invocations will be randomly affected and one of the exceptions will be thrown (equal probability). var optionsBasic = new ChaosFaultStrategyOptions { FaultGenerator = new FaultGenerator() .AddException<InvalidOperationException>() // Uses default constructor .AddException(() => new TimeoutException(\"Chaos timeout injected.\")), // Custom exception generator InjectionRate = 0.1 }; // To use a custom delegate to generate the fault to be injected var optionsWithFaultGenerator = new ChaosFaultStrategyOptions { FaultGenerator = static args => { Exception? exception = args.Context.OperationKey switch { \"DataLayer\" => new TimeoutException(), \"ApplicationLayer\" => new InvalidOperationException(), // When the fault generator returns null, the strategy won't inject // any fault and just invokes the user's callback. _ => null }; return new ValueTask<Exception?>(exception); }, InjectionRate = 0.1 }; // To get notifications when a fault is injected var optionsOnFaultInjected = new ChaosFaultStrategyOptions { FaultGenerator = new FaultGenerator().AddException<InvalidOperationException>(), InjectionRate = 0.1, OnFaultInjected = static args => { Console.WriteLine(\"OnFaultInjected, Exception: {0}, Operation: {1}.\", args.Fault.Message, args.Context.OperationKey); return default; } }; // Add a fault strategy with a ChaosFaultStrategyOptions instance to the pipeline new ResiliencePipelineBuilder().AddChaosFault(optionsBasic); new ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosFault(optionsWithFaultGenerator); // There are also a couple of handy overloads to inject the chaos easily new ResiliencePipelineBuilder().AddChaosFault(0.1, () => new InvalidOperationException(\"Dummy exception\")); Example execution: var pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<InvalidOperationException>(), BackoffType = DelayBackoffType.Exponential, UseJitter = true, // Adds a random factor to the delay MaxRetryAttempts = 4, Delay = TimeSpan.FromSeconds(3), }) .AddChaosFault(new ChaosFaultStrategyOptions // Chaos strategies are usually placed as the last ones in the pipeline { FaultGenerator = static args => new ValueTask<Exception?>(new InvalidOperationException(\"Dummy exception\")), InjectionRate = 0.1 }) .Build(); Defaults Property Default Value Description OnFaultInjected null Action executed when the fault is injected. FaultGenerator null Generates the fault to inject for a given execution. Diagrams Normal 🐵 sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant F as Fault participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>F: Calls ExecuteCore activate F F-->>F: Determines Injection<br/>Decision: 🐵 deactivate F F->>+D: Invokes D->>-F: Returns result F->>P: Returns result P->>C: Returns result Chaos 🙈 sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant F as Fault participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>F: Calls ExecuteCore activate F F-->>F: Determines Injection<br/>Decision: 🙈 F-->>F: Injects Fault deactivate F Note over D: The user's Callback is not invoked<br/>when a fault is injected F->>P: Throws injected Fault P->>C: Propagates Exception Generating faults To generate a fault, you need to specify a FaultGenerator delegate. You have the following options as to how you customize this delegate: Use FaultGenerator class to generate faults The FaultGenerator is convenience API that allows you to specify what faults (exceptions) are to be injected. Additionally, it also allows assigning weight to each registered fault. new ResiliencePipelineBuilder() .AddChaosFault(new ChaosFaultStrategyOptions { // Use FaultGenerator to register exceptions to be injected FaultGenerator = new FaultGenerator() .AddException<InvalidOperationException>() // Uses default constructor .AddException(() => new TimeoutException(\"Chaos timeout injected.\")) // Custom exception generator .AddException(context => CreateExceptionFromContext(context)) // Access the ResilienceContext .AddException<TimeoutException>(weight: 50), // Assign weight to the exception, default is 100 }); Use delegates to generate faults Delegates give you the most flexibility at the expense of slightly more complicated syntax. Delegates also support asynchronous fault generation, if you ever need that possibility. new ResiliencePipelineBuilder() .AddChaosFault(new ChaosFaultStrategyOptions { // The same behavior can be achieved with delegates FaultGenerator = args => { Exception? exception = Random.Shared.Next(350) switch { < 100 => new InvalidOperationException(), < 200 => new TimeoutException(\"Chaos timeout injected.\"), < 300 => CreateExceptionFromContext(args.Context), < 350 => new TimeoutException(), _ => null }; return new ValueTask<Exception?>(exception); } });"
  },
  "chaos/index.html": {
    "href": "chaos/index.html",
    "title": "Chaos engineering | Polly",
    "keywords": "Chaos engineering Chaos engineering is the discipline of experimenting on a system in order to build confidence in the system's capability to withstand turbulent conditions in production. If you want to learn more about chaos engineering: Chaos engineering on Wikipedia: Describes the basic concepts, history and tools related to chaos engineering. Chaos engineering, the history, principles and practices: Excellent article about chaos engineering by Gremlin, a chaos engineering platform. Understanding chaos engineering and resilience: Intro to chaos engineering in the context of Azure Chaos Studio, managed service that uses chaos engineering to help you measure, understand, and improve your cloud application and service resilience. Chaos engineering with Simmy Simmy is a major new addition to Polly library, adding a chaos engineering and fault-injection dimension to Polly, through the provision of strategies to selectively inject faults, latency, custom behavior or fake results. Usage var builder = new ResiliencePipelineBuilder<HttpResponseMessage>(); // First, configure regular resilience strategies builder .AddConcurrencyLimiter(10, 100) .AddRetry(new RetryStrategyOptions<HttpResponseMessage> { /* configure options */ }) .AddCircuitBreaker(new CircuitBreakerStrategyOptions<HttpResponseMessage> { /* configure options */ }) .AddTimeout(TimeSpan.FromSeconds(5)); // Finally, configure chaos strategies if you want to inject chaos. // These should come after the regular resilience strategies. // 2% of invocations will be injected with chaos const double InjectionRate = 0.02; builder .AddChaosLatency(InjectionRate, TimeSpan.FromMinutes(1)) // Inject a chaos latency to executions .AddChaosFault(InjectionRate, () => new InvalidOperationException(\"Injected by chaos strategy!\")) // Inject a chaos fault to executions .AddChaosOutcome(InjectionRate, () => new HttpResponseMessage(System.Net.HttpStatusCode.InternalServerError)) // Inject a chaos outcome to executions .AddChaosBehavior(0.001, cancellationToken => RestartRedisAsync(cancellationToken)); // Inject a chaos behavior to executions Note It is usual to place the chaos strategy as the last strategy in the resilience pipeline. By placing the chaos strategies as last, they subvert the usual outbound call at the last minute, substituting their fault or adding extra latency, etc. The existing resilience strategies - further out in the ResiliencePipeline - still apply, so you can test how the Polly resilience strategies you have configured handle the chaos/faults injected by Simmy. Major differences This section highlights the major differences compared to the Polly.Contrib.Simmy library: From MonkeyPolicy to ChaosStrategy: We've updated the terminology from Monkey to Chaos to better align with the well-recognized principles of chaos engineering. Unified configuration options: The InjectOptionsBase and InjectOptionsAsyncBase are now consolidated into ChaosStrategyOptions. This change brings Simmy in line with the Polly v8 API, offering built-in support for options-based configuration and seamless integration of synchronous and asynchronous executions. Chaos strategies enabled by default: Adding a chaos strategy (previously known as monkey policy) now means it's active right away. This is a departure from earlier versions, where the monkey policy had to be explicitly enabled. API changes: The new version of Simmy introduces several API updates. While this list isn't complete, it includes key changes like renaming Inject to AddChaos and switching from Result to Outcome. Here are some specific renames: InjectException is now AddChaosFault InjectResult is now AddChaosOutcome InjectBehavior is now AddChaosBehavior InjectLatency is now AddChaosLatency Sync and async unification: Before, Simmy had various methods to set policies like InjectLatency, InjectLatencyAsync, InjectLatency<T>, and InjectLatencyAsync<T>. With the new version based on Polly v8, these methods have been combined into a single AddChaosLatency extension that works for both ResiliencePipelineBuilder and ResiliencePipelineBuilder<T>. These rules are covering all types of chaos strategies (Outcome, Fault, Latency, and Behavior). Motivation There are a lot of questions when it comes to chaos engineering and making sure that a system is actually ready to face the worst possible scenarios: Is my system resilient enough? Am I handling the right exceptions/scenarios? How will my system behave if X happens? How can I test without waiting for a handled (or even unhandled) exception to happen in my production environment? Using Polly helps introduce resilience to a project, but we don't want to have to wait for expected or unexpected failures to test it out. A resilience could be wrongly implemented; testing the scenarios is not straightforward; and mocking failure of some dependencies (for example a cloud SaaS or PaaS service) is not always straightforward. What is needed to simulate chaotic scenarios? A way to simulate failures of dependencies (any service dependency for example). Define when to fail based on some external factors - maybe global configuration or some rule. A way to revert easily, to control the blast radius. To be production grade, to run this in a production or near-production system with automation. Chaos strategies Chaos strategies (formerly known as Monkey strategies) are in essence a Resilience strategy, which means, as a Resilience Strategy is the minimum unit of resilience for Polly, a Chaos Strategy is the minimum unit of chaos for Simmy. Built-in strategies Strategy Reactive What does the strategy do? Fault No Injects exceptions in your system. Outcome Yes Injects fake outcomes (results or exceptions) in your system. Latency No Injects latency into executions before the calls are made. Behavior No Allows you to inject any extra behavior, before a call is placed. Common options across strategies All the strategies' options implement the ChaosStrategyOptions class as it contains the basic configuration for every chaos strategy. Important Please bear in mind that with the V8 API the chaos strategies are enabled by default. So, you can opt-out of them one-by-one either via the Enabled or via the EnabledGenerator property. In previous Simmy versions you had to explicitly call either the Enabled or the EnabledWhen method to opt-in a chaos policy. Property Default Value Description InjectionRate 0.001 A decimal between 0 and 1 inclusive. The strategy will inject the chaos, randomly, that proportion of the time, e.g.: if 0.2, twenty percent of calls will be randomly affected; if 0.01, one percent of calls; if 1, all calls. InjectionRateGenerator null Generates the injection rate for a given execution, which the value should be between [0, 1] (inclusive). Enabled true Determines whether the strategy is enabled or not. EnabledGenerator null The generator that indicates whether the chaos strategy is enabled for a given execution. Note If both InjectionRate and InjectionRateGenerator are specified then InjectionRate will be ignored. If both Enabled and EnabledGenerator are specified then Enabled will be ignored. Telemetry The telemetry of chaos strategies is seamlessly integrated with Polly telemetry infrastructure. The chaos strategies produce the following events: Chaos.OnFault Chaos.OnOutcome Chaos.OnLatency Chaos.OnBehavior Patterns Inject chaos selectively You aim to dynamically adjust the frequency and timing of chaos injection. For instance, in pre-production and test environments, it's sensible to consistently inject chaos. This proactive approach helps in preparing for potential failures. In production environments, however, you may prefer to limit chaos to certain users and tenants, ensuring that regular users remain unaffected. The chaos API offers the flexibility needed to manage these varying scenarios. Additionally, you have the option to dynamically alter the injection rate and simulate extreme scenarios by setting the injection rate to 1.0 (100%). Exercise caution when applying this high rate, restricting it to a subset of tenants and users to avoid rendering the system unusable for regular users. The following example illustrates how to configure chaos strategies accordingly: services.AddResiliencePipeline(\"chaos-pipeline\", (builder, context) => { var environment = context.ServiceProvider.GetRequiredService<IHostEnvironment>(); builder.AddChaosFault(new ChaosFaultStrategyOptions { EnabledGenerator = args => { // Enable chaos in development and staging environments. if (environment.IsDevelopment() || environment.IsStaging()) { return ValueTask.FromResult(true); } // Enable chaos for specific users or tenants, even in production environments. if (ShouldEnableChaos(args.Context)) { return ValueTask.FromResult(true); } return ValueTask.FromResult(false); }, InjectionRateGenerator = args => { if (environment.IsStaging()) { // 1% chance of failure on staging environments. return ValueTask.FromResult(0.01); } if (environment.IsDevelopment()) { // 5% chance of failure on development environments. return ValueTask.FromResult(0.05); } // The context can carry information to help determine the injection rate. // For instance, in production environments, you might have certain test users or tenants // for whom you wish to inject chaos. if (ResolveInjectionRate(args.Context, out double injectionRate)) { return ValueTask.FromResult(injectionRate); } // No chaos on production environments. return ValueTask.FromResult(0.0); }, FaultGenerator = new FaultGenerator() .AddException<TimeoutException>() .AddException<HttpRequestException>() }); }); We suggest encapsulating the chaos decisions and injection rate in a shared class, such as IChaosManager: public interface IChaosManager { ValueTask<bool> IsChaosEnabled(ResilienceContext context); ValueTask<double> GetInjectionRate(ResilienceContext context); } This approach allows you to consistently apply and manage chaos-related settings across various chaos strategies by reusing IChaosManager. By centralizing the logic for enabling chaos and determining injection rates, you can ensure uniformity and ease of maintenance across your application and reuse it across multiple chaos strategies: services.AddResiliencePipeline(\"chaos-pipeline\", (builder, context) => { var chaosManager = context.ServiceProvider.GetRequiredService<IChaosManager>(); builder .AddChaosFault(new ChaosFaultStrategyOptions { EnabledGenerator = args => chaosManager.IsChaosEnabled(args.Context), InjectionRateGenerator = args => chaosManager.GetInjectionRate(args.Context), FaultGenerator = new FaultGenerator() .AddException<TimeoutException>() .AddException<HttpRequestException>() }) .AddChaosLatency(new ChaosLatencyStrategyOptions { EnabledGenerator = args => chaosManager.IsChaosEnabled(args.Context), InjectionRateGenerator = args => chaosManager.GetInjectionRate(args.Context), Latency = TimeSpan.FromSeconds(60) }); }); Note An alternative method involves using Microsoft.Extensions.AsyncState for storing information relevant to chaos injection decisions. This can be particularly useful in frameworks like ASP.NET Core. For instance, you could implement a middleware that retrieves user information from HttpContext, assesses the user type, and then stores this data in IAsyncContext<ChaosUser>. Subsequently, IChaosManager can access IAsyncContext<ChaosUser> to retrieve this information. This approach eliminates the need to manually insert such data into ResilienceContext for each call within the resilience pipeline, thereby streamlining the process. Integrating chaos pipelines When integrating chaos pipelines with resilience strategies, consider the following approaches: Establish a central resilience pipeline and apply it across various pipelines. Incorporate chaos strategies into each resilience pipeline individually. Each approach has its own set of advantages and disadvantages. Integrating chaos pipelines with a central pipeline To integrate chaos pipelines using a central approach, first define a central chaos pipeline that will be reused across various resilience pipelines: services.AddResiliencePipeline(\"chaos-pipeline\", (builder, context) => { var chaosManager = context.ServiceProvider.GetRequiredService<IChaosManager>(); builder .AddChaosFault(new ChaosFaultStrategyOptions { FaultGenerator = new FaultGenerator() .AddException<TimeoutException>() .AddException<HttpRequestException>() }) .AddChaosLatency(new ChaosLatencyStrategyOptions { Latency = TimeSpan.FromSeconds(60) }); }); Next, when defining a pipeline, use ResiliencePipelineProvider<T> to integrate the chaos pipeline using the AddPipeline extension method: services.AddResiliencePipeline(\"my-pipeline-1\", (builder, context) => { var pipelineProvider = context.ServiceProvider.GetRequiredService<ResiliencePipelineProvider<string>>(); var chaosPipeline = pipelineProvider.GetPipeline(\"chaos-pipeline\"); builder .AddRetry(new RetryStrategyOptions()) .AddTimeout(TimeSpan.FromSeconds(5)) .AddPipeline(chaosPipeline); // Inject central chaos pipeline }); ✅ Central management of the chaos pipeline allows for easy integration into other resilience pipelines. ❌ It's challenging to correlate telemetry between the chaos and resilience pipelines. Telemetry from the chaos pipeline is emitted under chaos-pipeline, while the regular resilience pipeline telemetry appears under my-pipeline-1. ❌ Fine-tuning the chaos pipeline's behavior to suit specific resilience pipelines is not straightforward. In certain scenarios, you might want to adjust failure rates for a particular pipeline. Integrating chaos pipelines with extensions In this approach, a helper extension method can be introduced to add a predefined set of chaos strategies to ResiliencePipelineBuilder<T>: // Options that represent the chaos pipeline public class MyChaosOptions { public ChaosFaultStrategyOptions Fault { get; set; } = new() { FaultGenerator = new FaultGenerator() .AddException<TimeoutException>() .AddException<HttpRequestException>() }; public ChaosLatencyStrategyOptions Latency { get; set; } = new() { Latency = TimeSpan.FromSeconds(60) }; } // Extension for easy integration of the chaos pipeline public static void AddMyChaos(this ResiliencePipelineBuilder builder, Action<MyChaosOptions>? configure = null) { var options = new MyChaosOptions(); configure?.Invoke(options); builder .AddChaosFault(options.Fault) .AddChaosLatency(options.Latency); } The example above: Defines MyChaosOptions, which encapsulates options for the chaos pipeline with sensible defaults. Introduces the AddMyChaos extension method for straightforward integration of a custom pipeline into any resilience strategy. It also provides flexibility to modify the pipeline's configuration. Once the chaos extension is in place, it can be utilized in defining your resilience pipelines: services.AddResiliencePipeline(\"my-pipeline-1\", (builder, context) => { builder .AddRetry(new RetryStrategyOptions()) .AddTimeout(TimeSpan.FromSeconds(5)) .AddMyChaos(); // Use the extension }); services.AddResiliencePipeline(\"my-pipeline-2\", (builder, context) => { builder .AddRetry(new RetryStrategyOptions()) .AddTimeout(TimeSpan.FromSeconds(5)) .AddMyChaos(options => { options.Latency.InjectionRate = 0.1; // Override the default injection rate options.Latency.Latency = TimeSpan.FromSeconds(10); // Override the default latency }); }); ✅ Enables configuration and customization of chaos strategies for each pipeline, while maintaining a centralized logic. ✅ Simplifies telemetry correlation as chaos strategies share the same pipeline name. ❌ Increased maintenance due to additional code, with flexibility coming at the expense of complexity. ❌ Monitoring multiple chaos pipelines may be necessary to understand their behavior."
  },
  "chaos/latency.html": {
    "href": "chaos/latency.html",
    "title": "Latency chaos strategy | Polly",
    "keywords": "Latency chaos strategy About Options: ChaosLatencyStrategyOptions Extensions: AddChaosLatency Strategy Type: Proactive The latency chaos strategy is designed to introduce controlled delays into system operations, simulating network latency or slow processing times. This strategy helps in assessing and improving the resilience of applications against increased response times. Usage // Latency using the default options. // See https://www.pollydocs.org/chaos/latency#defaults for defaults. var optionsDefault = new ChaosLatencyStrategyOptions(); // 10% of invocations will be randomly affected var basicOptions = new ChaosLatencyStrategyOptions { Latency = TimeSpan.FromSeconds(30), InjectionRate = 0.1 }; // To use a custom function to generate the latency to inject var optionsWithLatencyGenerator = new ChaosLatencyStrategyOptions { LatencyGenerator = static args => { TimeSpan latency = args.Context.OperationKey switch { \"DataLayer\" => TimeSpan.FromMilliseconds(500), \"ApplicationLayer\" => TimeSpan.FromSeconds(2), // When the latency generator returns Zero, the strategy // won't inject any delay and just invokes the user's callback. _ => TimeSpan.Zero }; return new ValueTask<TimeSpan>(latency); }, InjectionRate = 0.1 }; // To get notifications when a delay is injected var optionsOnLatencyInjected = new ChaosLatencyStrategyOptions { Latency = TimeSpan.FromSeconds(30), InjectionRate = 0.1, OnLatencyInjected = static args => { Console.WriteLine($\"OnLatencyInjected, Latency: {args.Latency}, Operation: {args.Context.OperationKey}.\"); return default; } }; // Add a latency strategy with a ChaosLatencyStrategyOptions instance to the pipeline new ResiliencePipelineBuilder().AddChaosLatency(optionsDefault); new ResiliencePipelineBuilder<HttpStatusCode>().AddChaosLatency(optionsWithLatencyGenerator); // There are also a handy overload to inject the chaos easily new ResiliencePipelineBuilder().AddChaosLatency(0.1, TimeSpan.FromSeconds(30)); Example execution: var pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<TimeoutRejectedException>(), BackoffType = DelayBackoffType.Exponential, UseJitter = true, // Adds a random factor to the delay MaxRetryAttempts = 4, Delay = TimeSpan.FromSeconds(3), }) .AddTimeout(TimeSpan.FromSeconds(5)) .AddChaosLatency(new ChaosLatencyStrategyOptions // Chaos strategies are usually placed as the last ones in the pipeline { Latency = TimeSpan.FromSeconds(10), InjectionRate = 0.1 }) .Build(); Defaults Property Default Value Description Latency 30 seconds A TimeSpan indicating the delay to be injected. LatencyGenerator null Generates the latency to inject for a given execution. OnLatencyInjected null Action executed when latency is injected. Note If both Latency and LatencyGenerator are specified then Latency will be ignored. Diagrams Normal 🐵 sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant L as Latency participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>L: Calls ExecuteCore activate L L->>L: Determines Injection<br/>Decision: 🐵 deactivate L L->>+D: Invokes D->>-L: Returns result L->>P: Returns result P->>C: Returns result Chaos 🙈 sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant L as Latency participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>L: Calls ExecuteCore activate L L->>L: Determines Injection<br/>Decision: 🙈 L-->>L: Injects Latency deactivate L L->>+D: Invokes D->>-L: Returns result L->>P: Returns result P->>C: Returns result"
  },
  "chaos/outcome.html": {
    "href": "chaos/outcome.html",
    "title": "Outcome chaos strategy | Polly",
    "keywords": "Outcome chaos strategy About Options: ChaosOutcomeStrategyOptions<T> Extensions: AddChaosOutcome Strategy Type: Reactive The outcome chaos strategy is designed to inject or substitute fake results into system operations. This allows testing how an application behaves when it receives different types of responses, like successful results, errors, or exceptions. Usage // To use OutcomeGenerator<T> to register the results and exceptions to be injected (equal probability) var optionsWithResultGenerator = new ChaosOutcomeStrategyOptions<HttpResponseMessage> { OutcomeGenerator = new OutcomeGenerator<HttpResponseMessage>() .AddResult(() => new HttpResponseMessage(HttpStatusCode.TooManyRequests)) .AddResult(() => new HttpResponseMessage(HttpStatusCode.InternalServerError)) .AddException(() => new HttpRequestException(\"Chaos request exception.\")), InjectionRate = 0.1 }; // To get notifications when a result is injected var optionsOnBehaviorInjected = new ChaosOutcomeStrategyOptions<HttpResponseMessage> { OutcomeGenerator = new OutcomeGenerator<HttpResponseMessage>() .AddResult(() => new HttpResponseMessage(HttpStatusCode.InternalServerError)), InjectionRate = 0.1, OnOutcomeInjected = static args => { Console.WriteLine($\"OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.\"); return default; } }; // Add a result strategy with a ChaosOutcomeStrategyOptions{<TResult>} instance to the pipeline new ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosOutcome(optionsWithResultGenerator); new ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosOutcome(optionsOnBehaviorInjected); // There are also a couple of handy overloads to inject the chaos easily new ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosOutcome(0.1, () => new HttpResponseMessage(HttpStatusCode.TooManyRequests)); Example execution: var pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRetry(new RetryStrategyOptions<HttpResponseMessage> { ShouldHandle = static args => args.Outcome switch { { Result.StatusCode: HttpStatusCode.InternalServerError } => PredicateResult.True(), _ => PredicateResult.False() }, BackoffType = DelayBackoffType.Exponential, UseJitter = true, MaxRetryAttempts = 4, Delay = TimeSpan.FromSeconds(3), }) .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage> // Chaos strategies are usually placed as the last ones in the pipeline { OutcomeGenerator = static args => { var response = new HttpResponseMessage(HttpStatusCode.InternalServerError); return ValueTask.FromResult<Outcome<HttpResponseMessage>?>(Outcome.FromResult(response)); }, InjectionRate = 0.1 }) .Build(); Defaults Property Default Value Description OutcomeGenerator null Function to generate the outcome for a given execution. OnOutcomeInjected null Action executed when the outcome is injected. Diagrams Normal 🐵 sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant B as Outcome participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>B: Calls ExecuteCore activate B B-->>B: Determines Injection<br/>Decision: 🐵 deactivate B B->>+D: Invokes D->>-B: Returns result B->>P: Returns result P->>C: Returns result Chaos 🙈 sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant B as Outcome participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>B: Calls ExecuteCore activate B B-->>B: Determines Injection<br/>Decision: 🙈 B-->>B: Injects Outcome deactivate B Note over D: The user's Callback is not invoked<br/>when a fake result is injected B->>P: Returns result P->>C: Returns result Generating outcomes To generate a faulted outcome (result or exception), you need to specify a OutcomeGenerator delegate. You have the following options as to how you customize this delegate: Use OutcomeGenerator<T> class to generate outcomes The OutcomeGenerator<T> is a convenience API that allows you to specify what outcomes (results or exceptions) are to be injected. Additionally, it also allows assigning weight to each registered outcome. new ResiliencePipelineBuilder<HttpResponseMessage>() .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage> { // Use OutcomeGenerator<T> to register the results and exceptions to be injected OutcomeGenerator = new OutcomeGenerator<HttpResponseMessage>() .AddResult(() => new HttpResponseMessage(HttpStatusCode.InternalServerError)) // Result generator .AddResult(() => new HttpResponseMessage(HttpStatusCode.TooManyRequests), weight: 50) // Result generator with weight .AddResult(context => new HttpResponseMessage(CreateResultFromContext(context))) // Access the ResilienceContext to create result .AddException<HttpRequestException>(), // You can also register exceptions }); Use delegates to generate outcomes Delegates give you the most flexibility at the expense of slightly more complicated syntax. Delegates also support asynchronous outcome generation, if you ever need that possibility. new ResiliencePipelineBuilder<HttpResponseMessage>() .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage> { // The same behavior can be achieved with delegates OutcomeGenerator = static args => { Outcome<HttpResponseMessage>? outcome = Random.Shared.Next(350) switch { < 100 => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.InternalServerError)), < 150 => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.TooManyRequests)), < 250 => Outcome.FromResult(new HttpResponseMessage(CreateResultFromContext(args.Context))), < 350 => Outcome.FromException<HttpResponseMessage>(new TimeoutException()), _ => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.OK)) }; return ValueTask.FromResult(outcome); } }); Anti-patterns Injecting faults (exceptions) ❌ DON'T Use outcome strategies to inject faults in advanced scenarios which you need to inject outcomes using delegates. This is an opinionated anti-pattern since you can consider an exception as a result/outcome, however, there might be undesired implications when doing so. One of these implications is these is to the telemetry events. Events might end up affecting your metrics as the ChaosOutcomeStrategy reports both result and exceptions in the same way. This could pose a problem for instrumentation purposes since it's clearer looking for fault injected events to be 100% sure where/when exceptions were injected, rather than have them mixed in the same \"bag\". Another problem is that you end up losing control of how/when to inject outcomes vs. faults. This is because the approach does not allow you to separately control when to inject a fault vs. an outcome. var pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage> { InjectionRate = 0.5, // Same injection rate for both fault and outcome OutcomeGenerator = static args => { Outcome<HttpResponseMessage>? outcome = Random.Shared.Next(350) switch { < 100 => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.InternalServerError)), < 150 => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.TooManyRequests)), < 250 => Outcome.FromResult(new HttpResponseMessage(CreateResultFromContext(args.Context))), < 350 => Outcome.FromException<HttpResponseMessage>(new HttpRequestException(\"Chaos request exception.\")), // ⚠️ Avoid this ⚠️ _ => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.OK)) }; return ValueTask.FromResult(outcome); }, OnOutcomeInjected = static args => { // You might have to put some logic here to determine what kind of output was injected. 😕 if (args.Outcome.Exception != null) { Console.WriteLine($\"OnBehaviorInjected, Exception: {args.Outcome.Exception.Message}, Operation: {args.Context.OperationKey}.\"); } else { Console.WriteLine($\"OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.\"); } return default; } }) .Build(); ✅ DO The previous approach is tempting since it looks like less code, but use fault chaos instead as the ChaosFaultStrategy correctly tracks telemetry events as faults, not just as any other outcome. By separating them, you can control the injection rate and enable/disable them separately which gives you more control when it comes to injecting chaos dynamically and in a controlled manner. var pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddChaosFault(new ChaosFaultStrategyOptions { InjectionRate = 0.1, // Different injection rate for faults EnabledGenerator = static args => ShouldEnableFaults(args.Context), // Different settings might apply to inject faults FaultGenerator = static args => { Exception? exception = RandomThreshold switch { >= 250 and < 350 => new HttpRequestException(\"Chaos request exception.\"), _ => null }; return ValueTask.FromResult(exception); }, OnFaultInjected = static args => { Console.WriteLine($\"OnFaultInjected, Exception: {args.Fault.Message}, Operation: {args.Context.OperationKey}.\"); return default; } }) .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage> { InjectionRate = 0.5, // Different injection rate for outcomes EnabledGenerator = static args => ShouldEnableOutcome(args.Context), // Different settings might apply to inject outcomes OutcomeGenerator = static args => { HttpStatusCode statusCode = RandomThreshold switch { < 100 => HttpStatusCode.InternalServerError, < 150 => HttpStatusCode.TooManyRequests, < 250 => CreateResultFromContext(args.Context), _ => HttpStatusCode.OK }; return ValueTask.FromResult<Outcome<HttpResponseMessage>?>(Outcome.FromResult(new HttpResponseMessage(statusCode))); }, OnOutcomeInjected = static args => { Console.WriteLine($\"OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.\"); return default; } }) .Build(); ❌ DON'T Use outcome strategies to inject only faults, use the ChaosFaultStrategy instead. new ResiliencePipelineBuilder<HttpResponseMessage>() .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage> { OutcomeGenerator = new OutcomeGenerator<HttpResponseMessage>() .AddException<HttpRequestException>(), // ⚠️ Avoid this ⚠️ }); ✅ DO Use fault strategies to inject the exception. new ResiliencePipelineBuilder<HttpResponseMessage>() .AddChaosFault(new ChaosFaultStrategyOptions { FaultGenerator = new FaultGenerator() .AddException<HttpRequestException>(), }); Note Even though the outcome strategy is flexible enough to allow you to inject outcomes as well as exceptions without the need to chain a fault strategy in the pipeline, use your judgment when doing so because of the caveats and side effects explained regarding telemetry and injection control."
  },
  "community/cheat-sheets.html": {
    "href": "community/cheat-sheets.html",
    "title": "Cheat Sheets | Polly",
    "keywords": "Cheat Sheets Cheat sheets provide easy to use code snippets for common scenarios. Note The below cheat sheets provide quick samples for the V8 API. Core strategies Strategy PDF Circuit Breaker Download Fallback Download Hedging Download Rate Limiter Download Retry Download Timeout Download Chaos strategies Strategy PDF Fault Download Outcome Download Latency Download Behavior Download"
  },
  "community/git-workflow.html": {
    "href": "community/git-workflow.html",
    "title": "Git Workflow | Polly",
    "keywords": "Git Workflow Our recommended process for working with Polly is: Fork our repository on GitHub Clone your fork locally Configure the upstream (git remote add upstream https://github.com/App-vNext/Polly.git) Switch to the default branch (i.e. main) using git checkout main Create a new local branch for your changes (git checkout -b my-branch). Work on your changes Rebase if required (see below) Check that the solution builds successfully by running dotnet test from the root of the repository There should be no errors or warnings All tests should pass The code coverage level is maintained Bug fixes should include at least one test where practical If adding new functionality, or checking existing behaviour, check whether there is any documentation that should be added or updated Push the branch up to GitHub (git push origin my-branch) Create a Pull Request on GitHub - the PR should target (have as base branch) the default branch (i.e. main). You should not work on a clone of the default branch, and you should not send a pull request from it - please always work from a branch. The reasons for this are detailed below. Learning Git Workflow For an introduction to Git, check out GitHub's Git Guide. For more information about GitHub Flow, please head over to the GitHub Flow documentation. Handling Updates from the default branch While you're working away in your branch, it's possible that one or more new commits have been added to the repository's default branch. If this happens you should: Stash any uncommitted changes you need to git checkout main git pull upstream main git checkout my-branch git rebase main Sync your fork (optional) - this makes sure your remote main branch is up to date This ensures that your history is \"clean\" i.e. you have one branch off from main followed by your changes in a straight line. Failing to do this ends up with several \"messy\" merges in your history, which we don't want. This is the reason why you should always work in a branch and you should never be working in, or sending pull requests from, main. Rebasing public commits is considered to be bad practice, which is why we ask you to rebase any updates from upstream/main. If you're working on a long running feature then you may want to do this quite often, rather than run the risk of potential merge issues further down the line. Sending a Pull Request While working on your feature you may well create several branches, which is fine, but before you send a pull request you should ensure that you have rebased back to a single \"feature branch\" - we care about your commits, and we care about your feature branch; but we don't care about how many or which branches you created while you were working on it. When you're ready to go you should confirm that you are up-to-date and rebased with upstream (see \"Handling Updates from the default branch\" above), and then: git push origin my-branch Send a descriptive Pull Request on GitHub - making sure you have selected the correct branch in the GitHub UI. It is not the end of the world if the commit history in your pull request ends up being messy - we can always squash it down to a single commit before merging. However, if you follow the steps above you should end up with a neater history."
  },
  "community/libraries-and-contributions.html": {
    "href": "community/libraries-and-contributions.html",
    "title": "3rd Party Libraries and Contributions | Polly",
    "keywords": "3rd Party Libraries and Contributions Fluent Assertions - A set of .NET extension methods that allow you to more naturally specify the expected outcome of a TDD or BDD-style test | Apache License 2.0 (Apache) xUnit.net - Free, open source, community-focused unit testing tool for the .NET Framework | Apache License 2.0 (Apache) Ian Griffith's TimedLock Steven van Deursen's ReadOnlyDictionary (until Polly v5.0.6) Stephen Cleary's AsyncEx library for AsyncSemaphore (supports BulkheadAsync policy for .NET 4.0 only) (until Polly v5.9.0) | MIT license @theraot's ExceptionDispatchInfo implementation for .NET 4.0 (supports Timeout policy for .NET4.0 only) (until Polly v5.9.0) including also a contribution by @migueldeicaza | Licensed under and distributed under Creative Commons Attribution Share Alike license per StackExchange Terms of Service Build powered by Cake and MinVer. Developers powered by Resharper, with thanks to JetBrains for OSS licensing. Acknowledgements lokad-shared-libraries - Helper assemblies originally for .NET 3.5 and Silverlight 2.0 which were developed as part of the Open Source effort by Lokad.com (discontinued) | New BSD License @michael-wolfenden - The creator and mastermind of Polly! @ghuntley - Portable Class Library implementation. @mauricedb - Initial async implementation. @robgibbens - Added existing async files to PCL project Hacko - Added extra NotOnCapturedContext call to prevent potential deadlocks when blocking on asynchronous calls @ThomasMentzel - Added ability to capture the results of executing a policy via ExecuteAndCapture @yevhen - Added full control of whether to continue on captured synchronization context or not @reisenberger - Added full async cancellation support @reisenberger - Added async support for ContextualPolicy @reisenberger - Added ContextualPolicy support for circuit-breaker @reisenberger - Extended circuit-breaker for public monitoring and control @reisenberger - Added ExecuteAndCapture support with arbitrary context data @kristianhald and @reisenberger - Added AdvancedCircuitBreaker @reisenberger - Allowed async onRetry delegates to async retry policies @Lumirris - Add new Polly.Net40Async project/package supporting async for .NET 4.0 via Microsoft.Bcl.Async @SteveCote - Added overloads to WaitAndRetry{Async} methods that accept an onRetry delegate which includes the attempt count. @reisenberger - Allowed policies to handle returned results; added strongly-typed policies Policy&lt;TResult&gt;. @christopherbahr - Added optimisation for circuit-breaker hot path. @Finity - Fixed circuit-breaker threshold bug. @reisenberger - Add some missing ExecuteAndCapture{Async} overloads. @brunolauze - Add CancellationToken support to synchronous executions (to support TimeoutPolicy). @reisenberger - Add PolicyWrap. @reisenberger - Add Fallback policy. @reisenberger - Add PolicyKeys and context to all policy executions, as bedrock for policy events and metrics tracking executions. @reisenberger, and contributions from @brunolauze - Add Bulkhead Isolation policy. @reisenberger - Add Timeout policy. @reisenberger - Fix .NET Standard 1.0 targeting. Remove PCL259 target. PCL259 support is provided via .NET Standard 1.0 target, going forward. @reisenberger - Fix CircuitBreaker HalfOpen state and cases when breakDuration is shorter than typical call timeout. Thanks to @vgouw and @kharos for the reports and insightful thinking. @lakario - Tidy CircuitBreaker LastException property. @lakario - Add NoOpPolicy. @Julien-Mialon - Fixes, support and examples for .NET Standard compatibility with Xamarin PCL projects @reisenberger - Add mutable Context and extra overloads taking Context. Allows different parts of a policy execution to exchange data via the mutable Context travelling with each execution. @ankitbko - Add PolicyRegistry for storing and retrieving policies. @reisenberger - Add interfaces by policy type and execution type. @seanfarrow - Add IReadOnlyPolicyRegistry interface. @kesmy - Migrate solution to msbuild15, banish project.json and packages.config @hambudi - Ensure sync TimeoutPolicy with TimeoutStrategy.Pessimistic rethrows delegate exceptions without additional AggregateException. @jiimaho and @Extremo75 - Provide public factory methods for PolicyResult, to support testing. @Extremo75 - Allow fallback delegates to take handled fault as input parameter. @reisenberger and @seanfarrow - Add CachePolicy, with interfaces for pluggable cache providers and serializers. Thanks to the awesome devs at @tretton37 who delivered the following as part of a one-day in-company hackathon led by @reisenberger, sponsored by @tretton37 and convened by @thecodejunkie @matst80 - Allow WaitAndRetry to take handled fault as an input to the sleepDurationProvider, allowing WaitAndRetry to take account of systems which specify a duration to wait as part of a fault response; e.g. Azure CosmosDB may specify this in x-ms-retry-after-ms headers or in a property to an exception thrown by the Azure CosmosDB SDK. @MartinSStewart - Add GetPolicies() extension methods to IPolicyWrap. @jbergens37 - Parallelize test running where possible, to improve overall build speed. @reisenberger - Add new .HandleInner<TException>(...) syntax for handling inner exceptions natively. @rjongeneelen and @reisenberger - Allow PolicyWrap configuration to configure policies via interfaces. @reisenberger - Performance improvements. @awarrenlove - Add ability to calculate cache TTL based on item to cache. @erickhouse - Add a new onBreak overload that provides the prior state on a transition to an open state. @benagain - Bug fix: RelativeTtl in CachePolicy now always returns a ttl relative to time item is cached. @urig - Allow TimeoutPolicy to be configured with Timeout.InfiniteTimeSpan. @reisenberger - Integration with IHttpClientFactory for ASP.NET Core 2.1. @freakazoid182 - WaitAndRetry{Forever} overloads where onRetry takes the retry number as a parameter. @dustyhoppe - Overloads where onTimeout takes thrown exception as a parameter. @flin-zap - Catch missing async continuation control. @reisenberger - Clarify separation of sync and async policies. @reisenberger - Enable extensibility by custom policies hosted external to Polly. @seanfarrow - Enable collection initialization syntax for PolicyRegistry. @moerwald - Code clean-ups, usage of more concise C# members. @cmeeren - Enable cache policies to cache values of default(TResult). @aprooks - Build script tweaks for Mac and Mono. @kesmy - Add SourceLink support, clean up cake build. @simluk - Fix continueOnCaptureContext not being honored in async retry implementation (bug in v7.1.0 only). @jnyrup - Upgrade tests to Fluent Assertions v5.9.0 @SimonCropp - Add netcoreapp3.0 target; code clean-ups. @aerotog and @reisenberger - IConcurrentPolicyRegistry methods on PolicyRegistry @reisenberger and @martincostello - Add RateLimit policy."
  },
  "community/polly-contrib.html": {
    "href": "community/polly-contrib.html",
    "title": "Polly-Contrib | Polly",
    "keywords": "Polly-Contrib Polly now has a Polly-Contrib to allow the community to contribute policies or other enhancements around Polly with a low burden of ceremony. Have a contribution you'd like to publish under Polly-Contrib? Contact us with an issue here or on Polly's Slack, and we can set up a CI-ready Polly.Contrib repository to which you have full rights, to help you manage and deliver your awesomeness to the community! We also provide: a blank starter template for a custom policy (see above for more on custom policies) a template repository for any other contributions Both templates contain a full project structure referencing Polly, Polly's default build targets, and a build to build and test your contrib and make a NuGet package. Available via Polly-Contrib Polly.Contrib.WaitAndRetry: a collection of concise helper methods for common wait-and-retry strategies; and a new jitter formula combining exponential back-off with a very even distribution of randomly-jittered retry intervals. Polly.Contrib.AzureFunctions.CircuitBreaker: a distributed circuit-breaker implemented in Azure Functions; consumable in Azure Functions, or from anywhere over http. Simmy: our chaos engineering project. Polly.Contrib.TimingPolicy: a starter policy to publish execution timings of any call executed through Policy. Polly.Contrib.LoggingPolicy: a policy simply to log handled exceptions/faults, and rethrow or bubble the fault outwards."
  },
  "community/resources.html": {
    "href": "community/resources.html",
    "title": "Resources | Polly",
    "keywords": "Resources This includes Blogs, podcasts, courses, e-books, architecture samples and videos around Polly. When we discover an interesting write-up on Polly, we'll add it to this list. If you have a blog post you'd like to share, please submit a PR! Blog posts Adding a circuit breaker to your ASP.NET 6 application with Polly - by Lachlan Barclay Try .NET Samples of Polly, the .NET Resilience Framework - by Bryan Hogan Create exceptional interactive documentation with Try .NET - The Polly NuGet library did! - by Scott Hanselman (writing about the work of Bryan Hogan) Adding resilience and Transient Fault handling to your .NET Core HttpClient with Polly - by Scott Hanselman Reliable Event Processing in Azure Functions - by Jeff Hollan Optimally configuring ASP.NET Core HttpClientFactory including with Polly policies - by Muhammad Rehan Saeed Integrating HttpClientFactory with Polly for transient fault handling - by Steve Gordon Resilient network connectivity in Xamarin Forms - by Adam Pedley Policy recommendations for Azure Cognitive Services - by Joel Hulen Using Polly with F# async workflows - by Mark Seemann Building resilient applications with Polly (with focus on Azure SQL transient errors) - by Geovanny Alzate Sandoval Azure SQL transient errors - by Mattias Karlsson Polly series on No Dogma blog - by Bryan Hogan Polly 5.0 - a wider resilience framework! - by Dylan Reisenberger Implementing the retry pattern in c sharp using Polly - by Alastair Crabtree NuGet Package of the Week: Polly wanna fluently express transient exception handling policies in .NET? - by Scott Hanselman Exception handling policies with Polly - by Mark Timmings When you use the Polly circuit-breaker, make sure you share your Policy instances! - by Andrew Lock Polly is Repetitive, and I love it! - by Joel Hulen Using the Context to Obtain the Retry Count for Diagnostics - by Steve Gordon Passing an ILogger to Polly Policies - by Steve Gordon Using Polly and Flurl to improve your website - by Jeremy Lindsay. Exploring the Polly.Contrib.WaitAndRetry helpers - by Ben Hyrman, who also wrote most of the Polly.Contrib.WaitAndRetry documentation. Retries - An interactive study of common retry methods - by Sam Rose Building resilient cloud services with .NET 8 by Martin Tomka Resilience and chaos engineering by Martin Tomka Podcasts June 2018: .NET Rocks features Polly as Carl Franklin and Richard Campbell chat with Dylan Reisenberger about policy patterns, and the new ASP NET Core 2.1 integration with IHttpClientFactory. April 2017: Dylan Reisenberger sits down virtually with Bryan Hogan of No Dogma Blog for an Introduction to Polly podcast. Why do I need Polly? History of the Polly project. What do we mean by resilience and transient faults? How retry and circuit-breaker help. Exponential back-off. Stability patterns. Bulkhead isolation. Future directions (as at April 2017). December 2023: .NET Rocks - Polly V8 with Joel Hulen and Martin Costello - as Carl Franklin and Richard Campbell chat with Joel Hulen and Martin Costello about the release of Polly V8. PluralSight course Bryan Hogan of the No Dogma Blog has authored a PluralSight course on Polly. The course takes you through all the major features of Polly, with an additional module added in the fall of 2018 on HttpClientFactory. The course examples are based around using Polly for fault tolerance when calling remote web services, but the principles and techniques are applicable to any context in which Polly may be used. Sample micro-services architecture and e-book Sample micro-services architecture Cesar de la Torre produced the Microsoft eShopOnContainers project, a sample project demonstrating a .NET Micro-services architecture. The project uses Polly retry and circuit-breaker policies for resilience in calls to micro-services, and in establishing connections to transports such as RabbitMQ. e-book Accompanying the project is a .NET Micro-services Architecture e-book with an extensive section (section 8) on using Polly for resilience, to which Dylan Reisenberger contributed. The e-book and code is now (June 2018) updated for using the latest ASP NET Core 2.1 features, Polly with IHttpClientFactory. Videos Robust Applications with Polly, the .NET Resilience Framework, Bryan Hogan introduces Polly and explains how to use it to build a fault tolerant application. From MVP Houssem Dellai, a YouTube video on How to use Polly with Xamarin Apps, covering wait-and-retry and discussing circuit-breaker policy with a demonstration in Xamarin Forms. Here is the source code of the application demonstrated in the video. Draws on the ResilientHttpClient from Microsoft's eShopOnContainers project. In the video, .NET Rocks Live with Jon Skeet and Bill Wagner, Bill Wagner discusses Polly. Scott Allen discusses Polly during his Building for Resiliency and Scale in the Cloud presentation at NDC. ASP.NET Community Stand-up April 24, 2018: Damian Edwards, Jon Galloway and Scott Hanselman discuss Scott Hanselman's blog on Polly with IHttpClientFactory and the Polly team documentation on IHttpClientFactory. Interesting background discussion also on feature richness and the importance of good documentation. Ensuring Resilience with Polly - Visual Studio Toolbox Live - Martin Costello shows how you can use Polly, a .NET resilience and transient fault-handling library."
  },
  "extensibility/index.html": {
    "href": "extensibility/index.html",
    "title": "Extensibility | Polly",
    "keywords": "Extensibility This article explains how to extend Polly with new resilience strategies. Polly identifies two types of resilience strategies: Reactive: These strategies handle specific exceptions that are thrown, or results that are returned, by the callbacks executed through the strategy. Proactive: Unlike reactive strategies, proactive strategies do not focus on handling errors by the callbacks might throw or return. They can make proactive decisions to cancel or reject the execution of callbacks (e.g., using a rate limiter or a timeout resilience strategy). This guide will help you create a new illustrative resilience strategy for each type. Basics of extensibility Regardless of whether the strategy is reactive or proactive, every new resilience strategy should include the following components: The strategy itself which should inherit from ResilienceStrategy Options detailing the strategy's configuration. This should inherit from ResilienceStrategyOptions. Extensions for ResiliencePipelineBuilder or ResiliencePipelineBuilder<T> to register the strategy into the pipeline. Custom argument types for delegates that contain information about a specific event. The strategy options contain properties of following types: Common types: Such as int, bool, TimeSpan, etc. Delegates: For example when a strategy needs to raise an event, or generate a value. In general, the delegates should by asynchronous. Arguments: Used by the delegates to pass the information to their consumers. Component diagram This diagram depicts how the built-in types (hexagon shaped) interact with custom built types (rectangle shaped): flowchart options[XYZStrategyOptions] builder[XYZResilienceStrategyBuilderExtensions] strategy[XYZResilienceStrategy] args[XYZEventArguments] telemetry{{ResilienceStrategyTelemetry}} pipeline{{ResiliencePipeline}} options -- is passed to AddXYZ --> builder builder -- registers a strategy --> pipeline options -- configures behavior --> strategy pipeline -- calls the execution --> strategy strategy -- creates for events --> args strategy -- uses for reporting --> telemetry %% a workaround to add note (currently only sequence diagram supports notes) %% https://github.com/mermaid-js/mermaid/issues/821 args -.- note(The strategy calls<br/>the OnXYZ delegate of<br/> the options with this object.) Delegates Individual resilience strategies make use of several delegate types: Predicates: Vital for determining whether a resilience strategy should handle the given execution result. Events: Triggered when significant actions or states occur within the resilience strategy. Generators: Invoked when the resilience strategy needs specific information or values from the caller. Recommended signatures for these delegates are: Predicates Func<Args<TResult>, ValueTask<bool>> (Reactive) Events Func<Args<TResult>, ValueTask> (Reactive) Func<Args, ValueTask> (Proactive) Generators Func<Args<TResult>, ValueTask<TValue>> (Reactive) Func<Args, ValueTask<TValue>> (Proactive) These delegates accept either Args or Args<TResult> arguments, which encapsulate event information. Note that all these delegates are asynchronous and return a ValueTask. Learn more about arguments in the sections below. Note When setting up delegates, consider using the ResilienceContext.ContinueOnCapturedContext property if your user code interacts with a synchronization context (such as in asynchronous UI applications like Windows Forms or WPF). How to use delegates Below are some examples illustrating the usage of these delegates: new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { // Non-Generic predicate for multiple result types ShouldHandle = args => args.Outcome switch { { Exception: InvalidOperationException } => PredicateResult.True(), { Result: string result } when result == \"Failure\" => PredicateResult.True(), { Result: int result } when result == -1 => PredicateResult.True(), _ => PredicateResult.False() }, }) .Build(); new ResiliencePipelineBuilder<string>() .AddRetry(new RetryStrategyOptions<string> { // Generic predicate for a single result type ShouldHandle = args => args.Outcome switch { { Exception: InvalidOperationException } => PredicateResult.True(), { Result: { } result } when result == \"Failure\" => PredicateResult.True(), _ => PredicateResult.False() }, }) .Build(); Arguments Arguments are used by individual delegate types to flow information to the consumer. Arguments should always have an Arguments suffix and include a Context property. Using arguments boosts the extensibility and maintainability of the API, as adding new members becomes a non-breaking change. For proactive strategies, the arguments structure might resemble the following: // Structs for arguments encapsulate details about specific events within the resilience strategy. // Relevant properties to the event can be exposed. In this event, the actual execution time and the exceeded threshold are included. public readonly struct OnThresholdExceededArguments { public OnThresholdExceededArguments(ResilienceContext context, TimeSpan threshold, TimeSpan duration) { Context = context; Threshold = threshold; Duration = duration; } public TimeSpan Threshold { get; } public TimeSpan Duration { get; } // As per convention, all arguments should provide a \"Context\" property. public ResilienceContext Context { get; } } Implementing a resilience strategy To find out more details about implementing a strategy, follow the links below: Proactive strategy: Explains how to implement a proactive resilience strategy. Reactive strategy: Explains how to implement a reactive resilience strategy."
  },
  "extensibility/proactive-strategy.html": {
    "href": "extensibility/proactive-strategy.html",
    "title": "Proactive resilience strategy | Polly",
    "keywords": "Proactive resilience strategy This document guides you in creating a Timing resilience strategy that tracks the execution times of callbacks and reports when the execution time exceeds the expected duration. This is a prime example of a proactive strategy because we aren't concerned with the individual results produced by the callbacks. Hence, this strategy can be used across various result types. Implementation Proactive resilience strategies are derived from the ResilienceStrategy base class. For this strategy, the implementation is: // Strategies should be internal and not exposed in the library's public API. // Configure the strategy through extension methods and options. internal sealed class TimingResilienceStrategy : ResilienceStrategy { private readonly TimeSpan _threshold; private readonly Func<OnThresholdExceededArguments, ValueTask>? _onThresholdExceeded; private readonly ResilienceStrategyTelemetry _telemetry; public TimingResilienceStrategy( TimeSpan threshold, Func<OnThresholdExceededArguments, ValueTask>? onThresholdExceeded, ResilienceStrategyTelemetry telemetry) { _threshold = threshold; _telemetry = telemetry; _onThresholdExceeded = onThresholdExceeded; } protected override async ValueTask<Outcome<TResult>> ExecuteCore<TResult, TState>( Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) { var stopwatch = Stopwatch.StartNew(); // Execute the given callback and adhere to the ContinueOnCapturedContext property value. Outcome<TResult> outcome = await callback(context, state).ConfigureAwait(context.ContinueOnCapturedContext); if (stopwatch.Elapsed > _threshold) { // Bundle information about the event into arguments. var args = new OnThresholdExceededArguments(context, _threshold, stopwatch.Elapsed); // Report this as a resilience event if the execution took longer than the threshold. _telemetry.Report( new ResilienceEvent(ResilienceEventSeverity.Warning, \"ExecutionThresholdExceeded\"), context, args); if (_onThresholdExceeded is not null) { await _onThresholdExceeded(args).ConfigureAwait(context.ContinueOnCapturedContext); } } // Return the outcome directly. return outcome; } } Review the code and comments to understand the implementation. Take note of the OnThresholdExceededArguments struct: // Structs for arguments encapsulate details about specific events within the resilience strategy. // Relevant properties to the event can be exposed. In this event, the actual execution time and the exceeded threshold are included. public readonly struct OnThresholdExceededArguments { public OnThresholdExceededArguments(ResilienceContext context, TimeSpan threshold, TimeSpan duration) { Context = context; Threshold = threshold; Duration = duration; } public TimeSpan Threshold { get; } public TimeSpan Duration { get; } // As per convention, all arguments should provide a \"Context\" property. public ResilienceContext Context { get; } } Arguments should always have an Arguments suffix and include a Context property. Using arguments boosts the extensibility and maintainability of the API, as adding new members becomes a non-breaking change. The OnThresholdExceededArguments provides details about the actual execution time and threshold, allowing consumers to respond to this event or supply a custom callback for such situations. Options In the previous section, we implemented the TimingResilienceStrategy. Now, it's time to integrate it with Polly and its public API. Let's define the public TimingStrategyOptions to configure our strategy: public class TimingStrategyOptions : ResilienceStrategyOptions { public TimingStrategyOptions() { // Assign a default name to the options for more detailed telemetry insights. Name = \"Timing\"; } // Apply validation attributes to guarantee the options' validity. // The pipeline will handle validation automatically during its construction. [Range(typeof(TimeSpan), \"00:00:00\", \"1.00:00:00\")] [Required] public TimeSpan? Threshold { get; set; } // Provide the delegate to be called when the threshold is surpassed. // Ideally, arguments should share the delegate's name, but with an \"Arguments\" suffix. public Func<OnThresholdExceededArguments, ValueTask>? OnThresholdExceeded { get; set; } } Options represent our public contract with the consumer. By using them, we can easily add new members without breaking changes and perform validation consistently. Extensions So far, we've covered: The public TimingStrategyOptions and its associated arguments. The proactive strategy implementation named TimingResilienceStrategy. The final step is to integrate these components with each other by adding new extensions for both ResiliencePipelineBuilder and ResiliencePipelineBuilder<T>. Since both builders inherit from the same base class, we can introduce a single extension for ResiliencePipelineBuilderBase to serve both. public static class TimingResilienceStrategyBuilderExtensions { // The extensions should return the builder to support a fluent API. // For proactive strategies, we can target both \"ResiliencePipelineBuilderBase\" and \"ResiliencePipelineBuilder<T>\" // using generic constraints. public static TBuilder AddTiming<TBuilder>(this TBuilder builder, TimingStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase { // Add the strategy through the AddStrategy method. This method accepts a factory delegate // and automatically validates the options. return builder.AddStrategy( context => { // The \"context\" provides various properties for the strategy's use. // In this case, we simply use the \"Telemetry\" property and pass it to the strategy. // The Threshold and OnThresholdExceeded values are sourced from the options. var strategy = new TimingResilienceStrategy( options.Threshold!.Value, options.OnThresholdExceeded, context.Telemetry); return strategy; }, options); } } Usage // Add the proactive strategy to the builder var pipeline = new ResiliencePipelineBuilder() // This is custom extension defined in this sample .AddTiming(new TimingStrategyOptions { Threshold = TimeSpan.FromSeconds(1), OnThresholdExceeded = args => { Console.WriteLine(\"Execution threshold exceeded!\"); return default; }, }) .Build(); Resources For further information on proactive resilience strategies, consider exploring these resources: Timing strategy sample: A practical example from this guide. Timeout resilience strategy: Discover the built-in timeout resilience strategy implementation. Rate limiter resilience strategy: Discover how rate limiter strategy is implemented."
  },
  "extensibility/reactive-strategy.html": {
    "href": "extensibility/reactive-strategy.html",
    "title": "Reactive resilience strategy | Polly",
    "keywords": "Reactive resilience strategy This document describes how to set up a Result reporting resilience strategy. This strategy lets you listen for specific results and report them to other components. It serves as a good example of a reactive strategy because it deals with specific results. Implementation Reactive resilience strategies inherit from the ResilienceStrategy<T> base class. The implementation for this specific strategy: // Strategies should be internal and not exposed in the library's public API. // Use extension methods and options to configure the strategy. internal sealed class ResultReportingResilienceStrategy<T> : ResilienceStrategy<T> { private readonly Func<ResultReportingPredicateArguments<T>, ValueTask<bool>> _shouldHandle; private readonly Func<OnReportResultArguments<T>, ValueTask> _onReportResult; private readonly ResilienceStrategyTelemetry _telemetry; public ResultReportingResilienceStrategy( Func<ResultReportingPredicateArguments<T>, ValueTask<bool>> shouldHandle, Func<OnReportResultArguments<T>, ValueTask> onReportResult, ResilienceStrategyTelemetry telemetry) { _shouldHandle = shouldHandle; _onReportResult = onReportResult; _telemetry = telemetry; } protected override async ValueTask<Outcome<T>> ExecuteCore<TState>( Func<ResilienceContext, TState, ValueTask<Outcome<T>>> callback, ResilienceContext context, TState state) { // Execute the given callback and adhere to the ContinueOnCapturedContext property value. Outcome<T> outcome = await callback(context, state).ConfigureAwait(context.ContinueOnCapturedContext); // Check if the outcome should be reported using the \"ShouldHandle\" predicate. if (await _shouldHandle(new ResultReportingPredicateArguments<T>(context, outcome)).ConfigureAwait(context.ContinueOnCapturedContext)) { // Bundle information about the event into arguments. var args = new OnReportResultArguments<T>(context, outcome); // Report this as a resilience event with information severity level to the telemetry infrastructure. _telemetry.Report( new ResilienceEvent(ResilienceEventSeverity.Information, \"ResultReported\"), context, outcome, args); // Call the \"OnReportResult\" callback. await _onReportResult(args).ConfigureAwait(context.ContinueOnCapturedContext); } return outcome; } } Reactive strategies use the ShouldHandle predicate to decide whether to handle the outcome of a user callback. The convention is to name the predicate's arguments using the {StrategyName}PredicateArguments pattern and return a ValueTask<bool>. Here, we use ResultReportingPredicateArguments<TResult>: public readonly struct ResultReportingPredicateArguments<TResult> { public ResultReportingPredicateArguments(ResilienceContext context, Outcome<TResult> outcome) { Context = context; Outcome = outcome; } // Always include the \"Context\" property in the arguments. public ResilienceContext Context { get; } // Always have the \"Outcome\" property in reactive arguments. public Outcome<TResult> Outcome { get; } } Reactive arguments should always contain the Context and Outcome properties. Additionally, to report the outcome, the strategy uses OnReportResultArguments<TResult>: public readonly struct OnReportResultArguments<TResult> { public OnReportResultArguments(ResilienceContext context, Outcome<TResult> outcome) { Context = context; Outcome = outcome; } // Always include the \"Context\" property in the arguments. public ResilienceContext Context { get; } // Always have the \"Outcome\" property in reactive arguments. public Outcome<TResult> Outcome { get; } } Using arguments in callbacks supports a more maintainable and extensible API. Options In the previous section, we implemented the ResultReportingResilienceStrategy<T>. Now, we need to integrate it with Polly and its public API. Define the public ResultReportingStrategyOptions<TResult> class to configure our strategy: public class ResultReportingStrategyOptions<TResult> : ResilienceStrategyOptions { public ResultReportingStrategyOptions() { // Assign a default name to the options for more detailed telemetry insights. Name = \"ResultReporting\"; } // Options for reactive strategies should always include a \"ShouldHandle\" delegate. // Set a sensible default when possible. Here, we handle all exceptions. public Func<ResultReportingPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } = args => { return new ValueTask<bool>(args.Outcome.Exception is not null); }; // This illustrates an event delegate. Note that the arguments struct carries the same name as the delegate but with an \"Arguments\" suffix. // The event follows the async convention and must be set by the user. // // The [Required] attribute enforces the consumer to specify this property, used when some properties do not have sensible defaults and are required. [Required] public Func<OnReportResultArguments<TResult>, ValueTask>? OnReportResult { get; set; } } If you want to support non-generic options for the ResiliencePipelineBuilder, you can expose them as well: // Simply derive from the generic options, using 'object' as the result type. // This allows the strategy to manage all results. public class ResultReportingStrategyOptions : ResultReportingStrategyOptions<object> { } Using options as a public contract helps us ensure flexibility with consumers. By adopting this method, you can introduce new members with ease without introducing breaking changes and maintain consistent validation. Extensions Up until now, we've discussed: The public ResultReportingStrategyOptions<TResult> and the related arguments. The proactive strategy implementation called ResultReportingResilienceStrategy<TResult>. The next step is to combine these elements by introducing new extensions for ResiliencePipelineBuilder<T> and, optionally, ResiliencePipelineBuilder. public static class ResultReportingResilienceStrategyBuilderExtensions { // Add extensions for the generic builder. // Extensions should return the builder to support a fluent API. public static ResiliencePipelineBuilder<TResult> AddResultReporting<TResult>( this ResiliencePipelineBuilder<TResult> builder, ResultReportingStrategyOptions<TResult> options) { // Add the strategy through the AddStrategy method. This method accepts a factory delegate // and automatically validates the options. return builder.AddStrategy( context => { // The \"context\" provides various properties for the strategy's use. // In this case, we simply use the \"Telemetry\" property and pass it to the strategy. // The ShouldHandle and OnReportResult values are sourced from the options. var strategy = new ResultReportingResilienceStrategy<TResult>( options.ShouldHandle, options.OnReportResult!, context.Telemetry); return strategy; }, options); } // Optionally, if suitable for the strategy, add support for non-generic builders. // Observe the use of the non-generic ResultReportingStrategyOptions. public static ResiliencePipelineBuilder AddResultReporting( this ResiliencePipelineBuilder builder, ResultReportingStrategyOptions options) { return builder.AddStrategy( context => { var strategy = new ResultReportingResilienceStrategy<object>( options.ShouldHandle, options.OnReportResult!, context.Telemetry); return strategy; }, options); } } Usage // Add reactive strategy to the builder new ResiliencePipelineBuilder<HttpResponseMessage>() .AddResultReporting(new ResultReportingStrategyOptions<HttpResponseMessage> { // Define what outcomes to handle ShouldHandle = args => args.Outcome switch { { Exception: { } } => PredicateResult.True(), { Result.StatusCode: HttpStatusCode.InternalServerError } => PredicateResult.True(), _ => PredicateResult.False() }, OnReportResult = args => { Console.WriteLine($\"Result: {args.Outcome}\"); return default; } }); // You can also use the non-generic ResiliencePipelineBuilder to handle any kind of result. new ResiliencePipelineBuilder() .AddResultReporting(new ResultReportingStrategyOptions { // Define what outcomes to handle ShouldHandle = args => args.Outcome switch { { Exception: { } } => PredicateResult.True(), { Result: HttpResponseMessage message } when message.StatusCode == HttpStatusCode.InternalServerError => PredicateResult.True(), _ => PredicateResult.False() }, OnReportResult = args => { Console.WriteLine($\"Result: {args.Outcome}\"); return default; } }); Resources For further information about reactive resilience strategies, consider exploring these resources: Result reporting strategy sample: A practical example from this guide. Retry resilience strategy: Discover the built-in retry resilience strategy implementation. Fallback resilience strategy: Discover the built-in fallback resilience strategy implementation."
  },
  "general.html": {
    "href": "general.html",
    "title": "General | Polly",
    "keywords": "General Supported targets Polly targets .NET Standard 2.0+ (coverage: .NET Core 2.0+, .NET Core 3.0, .NET 6.0+ and later Mono, Xamarin and UWP targets). The NuGet package also includes direct targets for .NET Framework 4.6.1 and 4.7.2. For details of supported compilation targets by version, see the supported targets grid. Asynchronous support Polly provides native support for asynchronous operations through all its resilience strategies by offering the ExecuteAsync methods on the ResiliencePipeline class. SynchronizationContext By default, asynchronous continuations and retries do not execute on a captured synchronization context. To modify this behavior, you can use the ResilienceContext class and set its ContinueOnCapturedContext property to true. The following example illustrates this: // Retrieve an instance of ResilienceContext from the pool // with the ContinueOnCapturedContext property set to true ResilienceContext context = ResilienceContextPool.Shared.Get(continueOnCapturedContext: true); await pipeline.ExecuteAsync( static async context => { // Execute your code, honoring the ContinueOnCapturedContext setting await MyMethodAsync(context.CancellationToken).ConfigureAwait(context.ContinueOnCapturedContext); }, context); // Optionally, return the ResilienceContext instance back to the pool // to minimize allocations and enhance performance ResilienceContextPool.Shared.Return(context); Cancellation support Asynchronous pipeline execution in Polly supports cancellation. This is facilitated through the ExecuteAsync(...) method overloads that accept a CancellationToken, or by initializing the ResilienceContext class with the CancellationToken property. The CancellationToken you pass to the ExecuteAsync(...) method serves multiple functions: It cancels resilience actions such as retries, wait times between retries, or rate-limiter leases. It is passed to any delegate executed by the strategy as a CancellationToken parameter, enabling cancellation during the delegate's execution. Is consistent with the .NET Base Class Library's (BCL) behavior in Task.Run(...), if the cancellation token is cancelled before execution begins, the user-defined delegate will not execute at all. // Execute your code with cancellation support await pipeline.ExecuteAsync( static async token => await MyMethodAsync(token), cancellationToken); // Use ResilienceContext for more advanced scenarios ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken: cancellationToken); await pipeline.ExecuteAsync( static async context => await MyMethodAsync(context.CancellationToken), context); Thread safety All Polly resilience strategies are fully thread-safe. You can safely re-use strategies at multiple call sites, and execute through strategies concurrently on different threads. Important While the internal operation of the strategy is thread-safe, this does not automatically make delegates you execute through the strategy thread-safe: if delegates you execute through the strategy are not thread-safe, they remain not thread-safe."
  },
  "getting-started.html": {
    "href": "getting-started.html",
    "title": "Getting started | Polly",
    "keywords": "Getting started To use Polly, you must provide a callback and execute it using a resilience pipeline. A resilience pipeline is a combination of one or more resilience strategies such as retry, timeout, and rate limiter. Polly uses builders to integrate these strategies into a pipeline. To get started, first add the Polly.Core package to your project by running the following command: dotnet add package Polly.Core You can create a ResiliencePipeline using the ResiliencePipelineBuilder class as shown below: // Create an instance of builder that exposes various extensions for adding resilience strategies ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions()) // Add retry using the default options .AddTimeout(TimeSpan.FromSeconds(10)) // Add 10 seconds timeout .Build(); // Builds the resilience pipeline // Execute the pipeline asynchronously await pipeline.ExecuteAsync(static async token => { /* Your custom logic goes here */ }, cancellationToken); Dependency injection If you prefer to define resilience pipelines using IServiceCollection, you'll need to install the Polly.Extensions package: dotnet add package Polly.Extensions then you can define your resilience pipeline using the AddResiliencePipeline(...) extension method as shown: var services = new ServiceCollection(); // Define a resilience pipeline with the name \"my-pipeline\" services.AddResiliencePipeline(\"my-pipeline\", builder => { builder .AddRetry(new RetryStrategyOptions()) .AddTimeout(TimeSpan.FromSeconds(10)); }); // Build the service provider var serviceProvider = services.BuildServiceProvider(); // Retrieve a ResiliencePipelineProvider that dynamically creates and caches the resilience pipelines var pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>(); // Retrieve your resilience pipeline using the name it was registered with ResiliencePipeline pipeline = pipelineProvider.GetPipeline(\"my-pipeline\"); // Alternatively, you can use keyed services to retrieve the resilience pipeline pipeline = serviceProvider.GetRequiredKeyedService<ResiliencePipeline>(\"my-pipeline\"); // Execute the pipeline await pipeline.ExecuteAsync(static async token => { // Your custom logic goes here }); Note You don't need to call the Build method on the builder parameter inside the AddResiliencePipeline."
  },
  "index.html": {
    "href": "index.html",
    "title": "Meet Polly: The .NET resilience library | Polly",
    "keywords": "Meet Polly: The .NET resilience library Polly is a powerful library for .NET that helps you handle transient faults and improve the resilience of your applications. With Polly, you can easily define and apply strategies such as Retry, Circuit Breaker, Hedging, Timeout, Rate Limiter and Fallback to handle failures and slowdowns in a fluent and thread-safe way. Polly is part of the .NET Foundation! What can Polly do for you? Polly lets you use and combine different resilience strategies to cope with various scenarios, such as: Retry: Try again if something fails. This can be useful when the problem is temporary and might go away. Circuit Breaker: Stop trying if something is broken or busy. This can benefit you by avoiding wasting time and making things worse. It can also support the system to recover. Timeout: Give up if something takes too long. This can improve your performance by freeing up space and resources. Rate Limiter: Limit how many requests you make or accept. This can enable you to control the load and prevent problems or penalties. Fallback: Do something else if something fails. This can improve your user experience and keep the program working. Hedging: Do more than one thing at the same time and take the fastest one. This can make your program faster and more responsive. You can learn more about each strategy and how to use them resilience strategies section. How to get started with Polly? Polly is easy to install and use. You can follow the getting started guide to add and start using Polly in your projects. Where to find more information? Polly has a rich documentation that covers various topics, such as: Resilience strategies: A collection of strategies for improving the resilience of your system. Resilience pipelines: How to combine and reuse strategies in a flexible and modular way. Telemetry and monitoring: How to access and analyze the data generated by Polly strategies and pipelines. Dependency injection: How to integrate Polly with dependency injection frameworks and containers. Performance: Tips on optimizing and getting the best performance from Polly. Testing: How to test the composition and configuration of resilience pipelines. Chaos engineering: How to use Polly to inject faults and test the resilience of your system. Extensibility: How to create and use custom strategies and extensions for Polly. You can also find many resources and community contributions, such as: Samples: Samples in this repository that serve as an introduction to Polly. Practical Samples: Practical examples for using various implementations of Polly. Please feel free to contribute to the Polly-Samples repository in order to assist others who are either learning Polly for the first time, or are seeking advanced examples and novel approaches provided by our generous community. Polly-Contrib: Community projects and libraries that extend and enhance Polly's functionality and ecosystem. Libraries and contributions: Dependencies and contributors that make Polly possible and awesome. Microsoft's eShopOnContainers project: Sample project demonstrating a .NET Micro-services architecture and using Polly for resilience. Git Workflow: Our suggested Git workflow for contributing to Polly. You can browse the documentation using the sidebar or visit the API section for the reference documentation."
  },
  "migration-v8.html": {
    "href": "migration-v8.html",
    "title": "Migration guide from v7 to v8 | Polly",
    "keywords": "Migration guide from v7 to v8 Welcome to the migration guide for Polly's v8 release. Version 8 of Polly brings major new enhancements and supports all of the same scenarios as previous versions. In the following sections, we'll detail the differences between the v7 and v8 APIs, and provide steps on how to transition smoothly. Note The v7 API is still available and fully supported even when using the v8 version by referencing the Polly package. Major differences The term Policy is now replaced with Strategy: In previous versions, Polly used the term policy for retries, timeouts, etc. In v8, these are referred to as resilience strategies. Introduction of Resilience Pipelines: A resilience pipeline combines one or more resilience strategies. This is the foundational API for Polly v8, similar to the Policy Wrap in previous versions but integrated into the core API. Unified sync and async flows: Interfaces such as IAsyncPolicy, IAsyncPolicy<T>, ISyncPolicy, ISyncPolicy<T>, and IPolicy are now unified under ResiliencePipeline and ResiliencePipeline<T>. The resilience pipeline supports both synchronous and asynchronous execution flows. Native async support: Polly v8 was designed with asynchronous support from the start. No static APIs: Unlike previous versions, v8 doesn't use static APIs. This improves testability and extensibility while maintaining ease of use. Options-based configuration: Configuring individual resilience strategies is now options-based, offering more flexibility and improving maintainability and extensibility. Built-in telemetry: Polly v8 now has built-in telemetry support. Improved performance and low-allocation APIs: Polly v8 brings significant performance enhancements and provides zero-allocation APIs for advanced use cases. Note Please read the comments in the code carefully for additional context and explanations. Polly or Polly.Core package When you do your migration process it is recommended to follow these steps: Upgrade the Polly package version from 7.x to 8.x Your previous policies should run smoothly without any change Migrate your V7 policies to V8 strategies gradually, such as one at a time Test your migrated code thoroughly After you have successfully migrated all your legacy Polly code then change your package reference from Polly to Polly.Core Migrating execution policies This section describes how to migrate from execution policies (i.e. IAsyncPolicy, ISyncPolicy) to resilience pipelines (i.e. ResiliencePipeline, ResiliencePipeline<T>). Configuring policies in v7 In earlier versions, Polly exposed various interfaces to execute user code: IAsyncPolicy IAsyncPolicy<T> ISyncPolicy ISyncPolicy<T> These interfaces were created and used as shown below: // Create and use the ISyncPolicy. ISyncPolicy syncPolicy = Policy .Handle<Exception>() .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1)); syncPolicy.Execute(() => { // Your code goes here }); // Create and use the IAsyncPolicy IAsyncPolicy asyncPolicy = Policy .Handle<Exception>() .WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1)); await asyncPolicy.ExecuteAsync(async token => { // Your code goes here }, cancellationToken); // Create and use the ISyncPolicy<T> ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy<HttpResponseMessage> .HandleResult(result => !result.IsSuccessStatusCode) .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1)); syncPolicyT.Execute(() => { // Your code goes here return GetResponse(); }); // Create and use the IAsyncPolicy<T> IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy<HttpResponseMessage> .HandleResult(result => !result.IsSuccessStatusCode) .WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1)); await asyncPolicyT.ExecuteAsync(async token => { // Your code goes here return await GetResponseAsync(token); }, cancellationToken); Configuring strategies in v8 In Polly v8, there are no such interfaces. The previous samples become: // Create and use the ResiliencePipeline. // // Use the ResiliencePipelineBuilder to start building the resilience pipeline ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<Exception>(), Delay = TimeSpan.FromSeconds(1), MaxRetryAttempts = 3, BackoffType = DelayBackoffType.Constant }) .Build(); // After all necessary strategies are added, call Build() to create the pipeline. // Synchronous execution pipeline.Execute(static () => { // Your code goes here }); // Asynchronous execution is also supported with the same pipeline instance await pipeline.ExecuteAsync(static async token => { // Your code goes here }, cancellationToken); // Create and use the ResiliencePipeline<T>. // // Building of generic resilience pipeline is very similar to non-generic one. // Notice the use of generic RetryStrategyOptions<HttpResponseMessage> to configure the strategy. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRetry(new RetryStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<Exception>() .HandleResult(static result => !result.IsSuccessStatusCode), Delay = TimeSpan.FromSeconds(1), MaxRetryAttempts = 3, BackoffType = DelayBackoffType.Constant }) .Build(); // Synchronous execution pipelineT.Execute(static () => { // Your code goes here return GetResponse(); }); // Asynchronous execution await pipelineT.ExecuteAsync(static async token => { // Your code goes here return await GetResponseAsync(token); }, cancellationToken); Tip Things to remember: Use ResiliencePipelineBuilder{<TResult>} to build a resiliency pipeline Use one of the Add* builder methods to add a new strategy to the pipeline Use either Execute or ExecuteAsync depending on the execution context For further information please check out the Resilience pipelines documentation. Migrating policy wrap Policy wrap in v7 Policy wrap is used to combine multiple policies into one: IAsyncPolicy retryPolicy = Policy.Handle<Exception>().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1)); IAsyncPolicy timeoutPolicy = Policy.TimeoutAsync(TimeSpan.FromSeconds(3)); // Wrap the policies. The policies are executed in the following order: // 1. Retry <== outer // 2. Timeout <== inner IAsyncPolicy wrappedPolicy = Policy.WrapAsync(retryPolicy, timeoutPolicy); Policy wrap in v8 In v8, there's no need to use policy wrap explicitly. Instead, policy wrapping is integrated into ResiliencePipelineBuilder: // The \"PolicyWrap\" is integrated directly. The strategies are executed in the following order: // 1. Retry <== outer // 2. Timeout <== inner ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new() { MaxRetryAttempts = 3, Delay = TimeSpan.FromSeconds(1), BackoffType = DelayBackoffType.Constant, ShouldHandle = new PredicateBuilder().Handle<Exception>() }) .AddTimeout(TimeSpan.FromSeconds(3)) .Build(); See fallback after retries for an example on how the strategies are executed. Tip Things to remember: Use ResiliencePipelineBuilder{<TResult>} to build a resiliency pipeline Use multiple Add* builder methods to add new strategies to your pipeline For further information please check out the Resilience pipelines documentation. Migrating retry policies This section describes how to migrate v7 retry policies to V8 retry strategies. Retry in v7 In v7 the retry policy is configured as: // Retry once Policy .Handle<SomeExceptionType>() .Retry(); // Retry multiple times Policy .Handle<SomeExceptionType>() .Retry(3); // Retry multiple times with callback Policy .Handle<SomeExceptionType>() .Retry(3, onRetry: (exception, retryCount) => { // Add logic to be executed before each retry, such as logging }); // Retry forever Policy .Handle<SomeExceptionType>() .RetryForever(); Retry in v8 In v8 the retry strategy is configured as: // Retry once // // Because we are adding retries to a non-generic pipeline, // we use the non-generic RetryStrategyOptions. new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { // PredicateBuilder is used to simplify the initialization of predicates. // Its API should be familiar to the v7 way of configuring what exceptions to handle. ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 1, // To disable waiting between retries, set the Delay property to TimeSpan.Zero. Delay = TimeSpan.Zero, }) .Build(); // Retry multiple times new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 3, Delay = TimeSpan.Zero, }) .Build(); // Retry multiple times with callback new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 3, Delay = TimeSpan.Zero, OnRetry = static args => { // Add logic to be executed before each retry, such as logging return default; } }) .Build(); // Retry forever new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), // To retry forever, set the MaxRetryAttempts property to int.MaxValue. MaxRetryAttempts = int.MaxValue, Delay = TimeSpan.Zero, }) .Build(); Retry and wait in v7 // Wait and retry multiple times Policy .Handle<SomeExceptionType>() .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1)); // Wait and retry multiple times with callback Policy .Handle<SomeExceptionType>() .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1), onRetry: (exception, retryCount) => { // Add logic to be executed before each retry, such as logging }); // Wait and retry forever Policy .Handle<SomeExceptionType>() .WaitAndRetryForever(_ => TimeSpan.FromSeconds(1)); Retry and wait in v8 // Wait and retry multiple times new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 3, Delay = TimeSpan.FromSeconds(1), BackoffType = DelayBackoffType.Constant }) .Build(); // Wait and retry multiple times with callback new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 3, Delay = TimeSpan.FromSeconds(1), BackoffType = DelayBackoffType.Constant, OnRetry = static args => { // Add logic to be executed before each retry, such as logging return default; } }) .Build(); // Wait and retry forever new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = int.MaxValue, Delay = TimeSpan.FromSeconds(1), BackoffType = DelayBackoffType.Constant }) .Build(); Retry results in v7 // Wait and retry with result handling Policy .Handle<SomeExceptionType>() .OrResult<HttpResponseMessage>(result => result.StatusCode == HttpStatusCode.InternalServerError) .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1)); Retry results in v8 // Shows how to add a retry strategy that also retries particular results. new ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new RetryStrategyOptions<HttpResponseMessage> { // PredicateBuilder is a convenience API that can used to configure the ShouldHandle predicate. ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<SomeExceptionType>() .HandleResult(static result => result.StatusCode == HttpStatusCode.InternalServerError), MaxRetryAttempts = 3, }) .Build(); // The same as above, but using the switch expressions for best performance. new ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new RetryStrategyOptions<HttpResponseMessage> { // Determine what results to retry using switch expressions. // Note that PredicateResult.True() is just a shortcut for \"new ValueTask<bool>(true)\". ShouldHandle = static args => args.Outcome switch { { Exception: SomeExceptionType } => PredicateResult.True(), { Result: { StatusCode: HttpStatusCode.InternalServerError } } => PredicateResult.True(), _ => PredicateResult.False() }, MaxRetryAttempts = 3, }) .Build(); Tip Things to remember: Use AddRetry to add a retry strategy to your resiliency pipeline Use the RetryStrategyOptions{<TResult>} to customize your retry behavior to meet your requirements For further information please check out the Retry resilience strategy documentation. Migrating rate limit policies The rate limit policy is now replaced by the rate limiter strategy which uses the System.Threading.RateLimiting package. Polly does not implement its own rate limiter anymore. Rate limit in v7 // Create sync rate limiter ISyncPolicy syncPolicy = Policy.RateLimit( numberOfExecutions: 100, perTimeSpan: TimeSpan.FromMinutes(1)); // Create async rate limiter IAsyncPolicy asyncPolicy = Policy.RateLimitAsync( numberOfExecutions: 100, perTimeSpan: TimeSpan.FromMinutes(1)); // Create generic sync rate limiter ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.RateLimit<HttpResponseMessage>( numberOfExecutions: 100, perTimeSpan: TimeSpan.FromMinutes(1)); // Create generic async rate limiter IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.RateLimitAsync<HttpResponseMessage>( numberOfExecutions: 100, perTimeSpan: TimeSpan.FromMinutes(1)); Rate limit in v8 Note In v8, you have to add the Polly.RateLimiting package to your application otherwise you won't see the AddRateLimiter extension. // The equivalent to Polly v7's RateLimit is the SlidingWindowRateLimiter. // // Polly exposes just a simple wrapper to the APIs exposed by the System.Threading.RateLimiting APIs. // There is no need to create separate instances for sync and async flows as ResiliencePipeline handles both scenarios. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions { PermitLimit = 100, Window = TimeSpan.FromMinutes(1), })) .Build(); // The creation of generic pipeline is almost identical. // // Polly exposes the same set of rate-limiter extensions for both ResiliencePipeline<HttpResponseMessage> and ResiliencePipeline. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions { PermitLimit = 100, Window = TimeSpan.FromMinutes(1), })) .Build(); Tip Things to remember: Use AddRateLimiter to add a rate limiter strategy to your resiliency pipeline Use one of the derived classes of ReplenishingRateLimiter to customize your rate limiter behavior to meet your requirements For further information please check out the Rate limiter resilience strategy documentation. Migrating bulkhead policies The bulkhead policy is now replaced by the rate limiter strategy which uses the System.Threading.RateLimiting package. The new counterpart to bulkhead is ConcurrencyLimiter. Note In v7, the bulkhead was presented as an individual strategy. In v8, it's not separately exposed because it's essentially a specialized type of rate limiter: the ConcurrencyLimiter. Bulkhead in v7 // Create sync bulkhead ISyncPolicy syncPolicy = Policy.Bulkhead( maxParallelization: 100, maxQueuingActions: 50); // Create async bulkhead IAsyncPolicy asyncPolicy = Policy.BulkheadAsync( maxParallelization: 100, maxQueuingActions: 50); // Create generic sync bulkhead ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.Bulkhead<HttpResponseMessage>( maxParallelization: 100, maxQueuingActions: 50); // Create generic async bulkhead IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.BulkheadAsync<HttpResponseMessage>( maxParallelization: 100, maxQueuingActions: 50); Bulkhead in v8 Note In v8, you have to add the Polly.RateLimiting package to your application otherwise you won't see the AddConcurrencyLimiter extension. // Create pipeline with concurrency limiter. Because ResiliencePipeline supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddConcurrencyLimiter(permitLimit: 100, queueLimit: 50) .Build(); // Create a generic pipeline with concurrency limiter. Because ResiliencePipeline<T> supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddConcurrencyLimiter(permitLimit: 100, queueLimit: 50) .Build(); Tip Things to remember: Use AddConcurrencyLimiter to add a concurrency limiter strategy to your resiliency pipeline Use the ConcurrencyLimiterOptions to customize your concurrency limiter behavior to meet your requirements For further information please check out the Rate limiter resilience strategy documentation. Migrating timeout policies Note In v8, the timeout resilience strategy does not support pessimistic timeouts because they can cause thread-pool starvation and non-cancellable background tasks. To address this, you can use this workaround to make the action cancellable. Timeout in v7 // Create sync timeout ISyncPolicy syncPolicy = Policy.Timeout(TimeSpan.FromSeconds(10)); // Create async timeout IAsyncPolicy asyncPolicy = Policy.TimeoutAsync(TimeSpan.FromSeconds(10)); // Create generic sync timeout ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.Timeout<HttpResponseMessage>(TimeSpan.FromSeconds(10)); // Create generic async timeout IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10)); Timeout in v8 // Create pipeline with timeout. Because ResiliencePipeline supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(10)) .Build(); // Create a generic pipeline with timeout. Because ResiliencePipeline<T> supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddTimeout(TimeSpan.FromSeconds(10)) .Build(); Tip Things to remember: Use AddTimeout to add a timeout strategy to your resiliency pipeline Use the TimeoutStrategyOptions to customize your timeout behavior to meet your requirements For further information please check out the Timeout resilience strategy documentation. Migrating circuit breaker policies This section describes how to migrate v7 circuit breaker policies to V8 circuit breaker strategies. Circuit breaker in v7 V7's \"Standard\" Circuit Breaker policy could be defined like below: // Create sync circuit breaker ISyncPolicy syncPolicy = Policy .Handle<SomeExceptionType>() .CircuitBreaker( exceptionsAllowedBeforeBreaking: 2, durationOfBreak: TimeSpan.FromSeconds(1)); // Create async circuit breaker IAsyncPolicy asyncPolicy = Policy .Handle<SomeExceptionType>() .CircuitBreakerAsync( exceptionsAllowedBeforeBreaking: 2, durationOfBreak: TimeSpan.FromSeconds(1)); // Create generic sync circuit breaker ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy<HttpResponseMessage> .Handle<SomeExceptionType>() .CircuitBreaker( handledEventsAllowedBeforeBreaking: 2, durationOfBreak: TimeSpan.FromSeconds(1)); // Create generic async circuit breaker IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy<HttpResponseMessage> .Handle<SomeExceptionType>() .CircuitBreakerAsync( handledEventsAllowedBeforeBreaking: 2, durationOfBreak: TimeSpan.FromSeconds(1)); V7's Advanced Circuit Breaker policy could be defined like below: // Create sync advanced circuit breaker ISyncPolicy syncPolicy = Policy .Handle<SomeExceptionType>() .AdvancedCircuitBreaker( failureThreshold: 0.5d, samplingDuration: TimeSpan.FromSeconds(5), minimumThroughput: 2, durationOfBreak: TimeSpan.FromSeconds(1)); // Create async advanced circuit breaker IAsyncPolicy asyncPolicy = Policy .Handle<SomeExceptionType>() .AdvancedCircuitBreakerAsync( failureThreshold: 0.5d, samplingDuration: TimeSpan.FromSeconds(5), minimumThroughput: 2, durationOfBreak: TimeSpan.FromSeconds(1)); // Create generic sync advanced circuit breaker ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy<HttpResponseMessage> .Handle<SomeExceptionType>() .AdvancedCircuitBreaker( failureThreshold: 0.5d, samplingDuration: TimeSpan.FromSeconds(5), minimumThroughput: 2, durationOfBreak: TimeSpan.FromSeconds(1)); // Create generic async advanced circuit breaker IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy<HttpResponseMessage> .Handle<SomeExceptionType>() .AdvancedCircuitBreakerAsync( failureThreshold: 0.5d, samplingDuration: TimeSpan.FromSeconds(5), minimumThroughput: 2, durationOfBreak: TimeSpan.FromSeconds(1)); // Check circuit state ICircuitBreakerPolicy cbPolicy = (ICircuitBreakerPolicy)asyncPolicy; bool isOpen = cbPolicy.CircuitState == CircuitState.Open || cbPolicy.CircuitState == CircuitState.Isolated; // Manually control state cbPolicy.Isolate(); // Transitions into the Isolated state cbPolicy.Reset(); // Transitions into the Closed state Circuit breaker in v8 Note Polly V8 does not support the standard (\"classic\") circuit breaker with consecutive failure counting. In case of V8 you can define a Circuit Breaker strategy which works like the advanced circuit breaker in V7. // Create pipeline with circuit breaker. Because ResiliencePipeline supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddCircuitBreaker(new CircuitBreakerStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), FailureRatio = 0.5d, SamplingDuration = TimeSpan.FromSeconds(5), MinimumThroughput = 2, BreakDuration = TimeSpan.FromSeconds(1) }) .Build(); // Create a generic pipeline with circuit breaker. Because ResiliencePipeline<T> supports both sync and async // callbacks, there is also no need to define it twice. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddCircuitBreaker(new CircuitBreakerStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>().Handle<SomeExceptionType>(), FailureRatio = 0.5d, SamplingDuration = TimeSpan.FromSeconds(5), MinimumThroughput = 2, BreakDuration = TimeSpan.FromSeconds(1) }) .Build(); // Check circuit state CircuitBreakerStateProvider stateProvider = new(); // Manually control state CircuitBreakerManualControl manualControl = new(); ResiliencePipeline pipelineState = new ResiliencePipelineBuilder() .AddCircuitBreaker(new CircuitBreakerStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), FailureRatio = 0.5d, SamplingDuration = TimeSpan.FromSeconds(5), MinimumThroughput = 2, BreakDuration = TimeSpan.FromSeconds(1), StateProvider = stateProvider, ManualControl = manualControl }) .Build(); // Check circuit state bool isOpen = stateProvider.CircuitState == CircuitState.Open || stateProvider.CircuitState == CircuitState.Isolated; // Manually control state await manualControl.IsolateAsync(); // Transitions into the Isolated state await manualControl.CloseAsync(); // Transitions into the Closed state Note In case of V7 you could do an optimization to reduce the thrown exceptions. You could guard the Execute{Async} call with a condition that the circuit is not broken. This technique does not work with V8. Under the circuit breaker's anti-patterns you can find the suggested way for V8. Tip Things to remember: Use AddCircuitBreaker to add a circuit breaker strategy to your resiliency pipeline Use the CircuitBreakerStrategyOptions{<TResult>} to customize your circuit breaker behavior to meet your requirements For further information please check out the Circuit Breaker resilience strategy documentation. Migrating Polly.Context The successor of the Polly.Context is the ResilienceContext. The major differences: ResilienceContext is pooled for enhanced performance and cannot be directly created. Instead, use the ResilienceContextPool class to get an instance. Context allowed directly custom data attachment, whereas ResilienceContext employs the ResilienceContext.Properties for the same purpose. In order to set or get a custom data you need to utilize the generic ResiliencePropertyKey structure. Predefined keys In V7 In V8 OperationKey It can be used in the same way PolicyKey It's been relocated to ResiliencePipelineBuilder and used for telemetry PolicyWrapKey It's been relocated to ResiliencePipelineBuilder and used for telemetry CorrelationId It's been removed. For similar functionality, you can either use System.Diagnostics.Activity.Current.Id or attach your custom Id using ResilienceContext.Properties. Additionally, ResilienceContext introduces a new property for CancellationToken. Context in v7 // Create context Context context = new Context(); // Create context with operation key context = new Context(\"my-operation-key\"); // Attach custom properties context[Key1] = \"value-1\"; context[Key2] = 100; // Retrieve custom properties string value1 = (string)context[Key1]; int value2 = (int)context[Key2]; // Bulk attach context = new Context(\"my-operation-key\", new Dictionary<string, object> { { Key1 , \"value-1\" }, { Key2 , 100 } }); ResilienceContext in v8 // Create context ResilienceContext context = ResilienceContextPool.Shared.Get(); // Create context with operation key context = ResilienceContextPool.Shared.Get(\"my-operation-key\"); // Attach custom properties ResiliencePropertyKey<string> propertyKey1 = new(Key1); context.Properties.Set(propertyKey1, \"value-1\"); ResiliencePropertyKey<int> propertyKey2 = new(Key2); context.Properties.Set(propertyKey2, 100); // Bulk attach context.Properties.SetProperties(new Dictionary<string, object?> { { Key1 , \"value-1\" }, { Key2 , 100 } }, out var oldProperties); // Retrieve custom properties string value1 = context.Properties.GetValue(propertyKey1, \"default\"); int value2 = context.Properties.GetValue(propertyKey2, 0); // Return the context to the pool ResilienceContextPool.Shared.Return(context); Tip Things to remember: Use ResilienceContextPool.Shared to get a context and return it back to the pool Use the ResiliencePropertyKey<TValue> to define type-safe keys for your custom data For further information please check out the Resilience Context documentation. Migrating safe execution In v7, the ExecuteAndCapture{Async} methods are considered the safe counterpart of the Execute{Async}. The former does not throw an exception in case of failure rather than wrap the outcome in a result object. In v8, the ExecuteOutcomeAsync method should be used to execute the to-be-decorated method in a safe way. ExecuteAndCapture{Async} in V7 // Synchronous execution ISyncPolicy<int> syncPolicy = Policy.Timeout<int>(TimeSpan.FromSeconds(1)); PolicyResult<int> policyResult = syncPolicy.ExecuteAndCapture(Method); // Asynchronous execution IAsyncPolicy<int> asyncPolicy = Policy.TimeoutAsync<int>(TimeSpan.FromSeconds(1)); PolicyResult<int> asyncPolicyResult = await asyncPolicy.ExecuteAndCaptureAsync(MethodAsync, CancellationToken.None); // Assess policy result if (policyResult.Outcome == OutcomeType.Successful) { int result = policyResult.Result; // Process result } else { Exception exception = policyResult.FinalException; FaultType faultType = policyResult.FaultType!.Value; ExceptionType exceptionType = policyResult.ExceptionType!.Value; // Process failure } // Access context const string Key = \"context_key\"; IAsyncPolicy<int> asyncPolicyWithContext = Policy.TimeoutAsync<int>(TimeSpan.FromSeconds(10), onTimeoutAsync: (ctx, ts, task) => { ctx[Key] = \"context_value\"; return Task.CompletedTask; }); asyncPolicyResult = await asyncPolicyWithContext.ExecuteAndCaptureAsync((ctx, token) => MethodAsync(token), new Context(), CancellationToken.None); string? ctxValue = asyncPolicyResult.Context.GetValueOrDefault(Key) as string; ExecuteOutcomeAsync in V8 Note Polly V8 does not provide an API to synchronously execute and capture the outcome of a pipeline. ResiliencePipeline<int> pipeline = new ResiliencePipelineBuilder<int>() .AddTimeout(TimeSpan.FromSeconds(1)) .Build(); // Synchronous execution // Polly v8 does not support // Asynchronous execution var context = ResilienceContextPool.Shared.Get(); Outcome<int> pipelineResult = await pipeline.ExecuteOutcomeAsync( static async (ctx, state) => Outcome.FromResult(await MethodAsync(ctx.CancellationToken)), context, \"state\"); ResilienceContextPool.Shared.Return(context); // Assess policy result if (pipelineResult.Exception is null) { int result = pipelineResult.Result; // Process result } else { Exception exception = pipelineResult.Exception; // Process failure // If needed you can rethrow the exception pipelineResult.ThrowIfException(); } // Access context ResiliencePropertyKey<string> contextKey = new(\"context_key\"); ResiliencePipeline<int> pipelineWithContext = new ResiliencePipelineBuilder<int>() .AddTimeout(new TimeoutStrategyOptions { Timeout = TimeSpan.FromSeconds(1), OnTimeout = args => { args.Context.Properties.Set(contextKey, \"context_value\"); return default; } }) .Build(); context = ResilienceContextPool.Shared.Get(); pipelineResult = await pipelineWithContext.ExecuteOutcomeAsync( static async (ctx, state) => Outcome.FromResult(await MethodAsync(ctx.CancellationToken)), context, \"state\"); context.Properties.TryGetValue(contextKey, out var ctxValue); ResilienceContextPool.Shared.Return(context); Tip Things to remember: Use ExecuteOutcomeAsync to execute your callback in a safe way Migrating no-op policies In V7 In V8 Policy.NoOp ResiliencePipeline.Empty Policy.NoOpAsync ResiliencePipeline.Empty Policy.NoOp<TResult> ResiliencePipeline<TResult>.Empty Policy.NoOpAsync<TResult> ResiliencePipeline<TResult>.Empty Migrating policy registries In v7, the following registry APIs are exposed: IConcurrentPolicyRegistry<TKey> IPolicyRegistry<TKey> IReadOnlyPolicyRegistry<TKey> PolicyRegistry<TKey> In v8, these have been replaced by: ResiliencePipelineProvider<TKey>: Allows adding and accessing resilience pipelines. ResiliencePipelineRegistry<TKey>: Read-only access to resilience pipelines. The main updates: It's append-only, which means removal of items is not supported to avoid race conditions. It's thread-safe and supports features like dynamic reloading and resource disposal. It allows dynamic creation and caching of resilience pipelines using pre-registered delegates. Type safety is enhanced, eliminating the need for casting between policy types. Registry in v7 // Create a registry var registry = new PolicyRegistry(); // Add a policy registry.Add(PolicyKey, Policy.Timeout(TimeSpan.FromSeconds(10))); // Try get a policy registry.TryGet<IAsyncPolicy>(PolicyKey, out IAsyncPolicy? policy); // Try get a generic policy registry.TryGet<IAsyncPolicy<string>>(PolicyKey, out IAsyncPolicy<string>? genericPolicy); // Update a policy registry.AddOrUpdate( PolicyKey, Policy.Timeout(TimeSpan.FromSeconds(10)), (key, previous) => Policy.Timeout(TimeSpan.FromSeconds(10))); Registry in v8 Note Polly V8 does not provide an explicit API to directly update a strategy in the registry. On the other hand it does provide a mechanism to reload pipelines. // Create a registry var registry = new ResiliencePipelineRegistry<string>(); // Add a pipeline using a builder, when the pipeline is retrieved it will be dynamically built and cached registry.TryAddBuilder(PipelineKey, (builder, context) => builder.AddTimeout(TimeSpan.FromSeconds(10))); // Try get a pipeline registry.TryGetPipeline(PipelineKey, out ResiliencePipeline? pipeline); // Try get a generic pipeline registry.TryGetPipeline<string>(PipelineKey, out ResiliencePipeline<string>? genericPipeline); // Get or add pipeline registry.GetOrAddPipeline(PipelineKey, builder => builder.AddTimeout(TimeSpan.FromSeconds(10))); Tip Things to remember: Use ResiliencePipelineRegistry<TResult> to add or get a pipelines to the registry Prefer the safer methods (for example: TryGetPipeline{<TResult>}) over their counterpart (for example: GetPipeline{<TResult>}) For further information please check out the Resilience pipeline registry documentation. Interoperability between policies and resilience pipelines In certain scenarios, you might not able to migrate all your code to the v8 API. In the name of interoperability you can define V8 strategies use them with your v7 policies. V8 provides a set of extension methods to support easy conversion from v8 to v7 APIs, as shown in the example below: Note In v8, you have to add the Polly.RateLimiting package to your application otherwise you won't see the AddRateLimiter extension. // First, create a resilience pipeline. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRateLimiter(new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions { Window = TimeSpan.FromSeconds(10), PermitLimit = 100 })) .Build(); // Now, convert it to a v7 policy. Note that it can be converted to both sync and async policies. ISyncPolicy syncPolicy = pipeline.AsSyncPolicy(); IAsyncPolicy asyncPolicy = pipeline.AsAsyncPolicy(); // Finally, use it in a policy wrap. ISyncPolicy wrappedPolicy = Policy.Wrap( syncPolicy, Policy.Handle<SomeExceptionType>().Retry(3));"
  },
  "pipelines/index.html": {
    "href": "pipelines/index.html",
    "title": "Resilience pipelines | Polly",
    "keywords": "Resilience pipelines The ResiliencePipeline allows executing arbitrary user-provided callbacks. It is a combination of one or more resilience strategies. Usage The ResiliencePipeline allow executing various synchronous and asynchronous user-provided callbacks as seen in the examples below: // Creating a new resilience pipeline ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddConcurrencyLimiter(100) .Build(); // Executing an asynchronous void callback await pipeline.ExecuteAsync( async token => await MyMethodAsync(token), cancellationToken); // Executing a synchronous void callback pipeline.Execute(() => MyMethod()); // Executing an asynchronous callback that returns a value await pipeline.ExecuteAsync( async token => await httpClient.GetAsync(endpoint, token), cancellationToken); // Executing an asynchronous callback without allocating a lambda await pipeline.ExecuteAsync( static async (state, token) => await state.httpClient.GetAsync(state.endpoint, token), (httpClient, endpoint), // State provided here cancellationToken); // Executing an asynchronous callback and passing custom data // 1. Retrieve a context from the shared pool ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken); // 2. Add custom data to the context context.Properties.Set(new ResiliencePropertyKey<string>(\"my-custom-data\"), \"my-custom-data\"); // 3. Execute the callback await pipeline.ExecuteAsync(static async context => { // Retrieve custom data from the context var customData = context.Properties.GetValue( new ResiliencePropertyKey<string>(\"my-custom-data\"), \"default-value\"); Console.WriteLine(\"Custom Data: {0}\", customData); await MyMethodAsync(context.CancellationToken); }, context); // 4. Optionally, return the context to the shared pool ResilienceContextPool.Shared.Return(context); The above samples demonstrate how to use the resilience pipeline within the same scope. Additionally, consider the following: Separate the resilience pipeline's definition from its usage. Inject pipelines into the code that will consume them. This facilitates various unit-testing scenarios. If your application uses Polly in multiple locations, define all pipelines at startup using ResiliencePipelineRegistry or using the AddResiliencePipeline extension. This is a common approach in .NET Core applications. For example, you could create your own extension method on IServiceCollection to configure pipelines consumed elsewhere in your application. public static void ConfigureMyPipelines(IServiceCollection services) { services.AddResiliencePipeline(\"pipeline-A\", builder => builder.AddConcurrencyLimiter(100)); services.AddResiliencePipeline(\"pipeline-B\", builder => builder.AddRetry(new())); // Later, resolve the pipeline by name using ResiliencePipelineProvider<string> or ResiliencePipelineRegistry<string> var pipelineProvider = services.BuildServiceProvider().GetRequiredService<ResiliencePipelineProvider<string>>(); pipelineProvider.GetPipeline(\"pipeline-A\").Execute(() => { }); } Empty resilience pipeline The empty resilience pipeline is a special construct that lacks any resilience strategies. You can access it through the following ways: ResiliencePipeline.Empty ResiliencePipeline<T>.Empty This is particularly useful in test scenarios where implementing resilience strategies could slow down the test execution or over-complicate test setup. Retrieving execution results with Outcome<T> The ResiliencePipeline class provides the ExecuteOutcomeAsync(...) method, which is designed to never throw exceptions. Instead, it stores either the result or the exception within an Outcome<T> struct. // Acquire a ResilienceContext from the pool ResilienceContext context = ResilienceContextPool.Shared.Get(); // Execute the pipeline and store the result in an Outcome<bool> Outcome<bool> outcome = await pipeline.ExecuteOutcomeAsync( static async (context, state) => { Console.WriteLine(\"State: {0}\", state); try { await MyMethodAsync(context.CancellationToken); // Use static utility methods from Outcome to easily create an Outcome<T> instance return Outcome.FromResult(true); } catch (Exception e) { // Create an Outcome<T> instance that holds the exception return Outcome.FromException<bool>(e); } }, context, \"my-state\"); // Return the acquired ResilienceContext to the pool ResilienceContextPool.Shared.Return(context); // Evaluate the outcome if (outcome.Exception is not null) { Console.WriteLine(\"Execution Failed: {0}\", outcome.Exception.Message); } else { Console.WriteLine(\"Execution Result: {0}\", outcome.Result); } Use ExecuteOutcomeAsync(...) in high-performance scenarios where you wish to avoid re-throwing exceptions. Keep in mind that Polly's resilience strategies also make use of the Outcome struct to prevent unnecessary exception throwing. Context vs State In the previous example the ExecuteOutcomeAsync was called with \"my-state\" state object. You might wonder what's the point of the state, or can't we just use the context? The state object was introduced to be able to pass a parameter to the user callback without using a closure. It allows you to access any object of the ExecuteOutcomeAsync's caller method without any extra memory allocation It also enables you to use static anonymous methods So, it is a performance optimization tool. Of course you can pass more complex object than just a simple string like (instance: this, request). While the state object is accessible only inside the user callback, you can use the context in many places. For example in case of Retry the context is accessible: inside the ShouldHandle delegate; inside the OnRetry delegate; inside the DelayGenerator delegate; through the Outcome property. As a rule of thumb: Use the state object to pass a parameter to your decorated method; Use the context object to exchange information between delegates of an instance of XYZOptions or between invocation attempts (in the case of retry or hedging strategies). Diagrams Sequence diagram for a pipeline with retry and timeout Let's create the following pipeline: the inner strategy is a timeout, the outer is a retry which is timeout-aware. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder().Handle<TimeoutRejectedException>() }) // outer .AddTimeout(TimeSpan.FromSeconds(1)) // inner .Build(); Let's suppose that the first request takes too long but the second is fast enough. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant R as Retry participant T as Timeout participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>R: Calls ExecuteCore R->>T: Calls ExecuteCore Note over R, D: Initial attempt Note over T: Wait start activate T T->>D: Invokes activate D D-->>D: Performs <br/>long-running <br/>operation Note over T: Wait end deactivate T T-->>T: Times out T->>D: Propagates cancellation D-->>D: Cancellation of callback D->>T: Cancellation finished deactivate D T->>R: Throws <br/>TimeoutRejectedException R-->>R: Sleeps Note over R, D: First retry attempt R->>T: Calls ExecuteCore Note over T: Wait start activate T T->>D: Invokes activate D D-->>D: Performs <br/>long-running <br/>operation D->>T: Returns result deactivate D deactivate T Note over T: Wait end T->>R: Returns result R->>P: Returns result P->>C: Returns result Sequence diagram for a pipeline with timeout and retry Let's create the following pipeline: the inner strategy is a retry, the outer is a timeout which is overarching all retry attempts. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(10)) // outer .AddRetry(new()) // inner .Build(); Let's suppose that the first and the second requests are failing. The third request is not awaited since the overarching timeout elapsed. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant T as Timeout participant R as Retry participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>T: Calls ExecuteCore Note over T: Wait start activate T T->>R: Calls ExecuteCore Note over R, D: Initial attempt R->>D: Invokes activate D D-->>D: Performs <br/>operation D->>R: Fails deactivate D R-->>R: Sleeps Note over R, D: First retry attempt R->>D: Invokes activate D D-->>D: Performs <br/>operation D->>R: Fails deactivate D R-->>R: Sleeps Note over R, D: Second retry attempt R->>D: Invokes activate D D-->>D: Performs <br/>operation deactivate T Note over T: Wait end T-->>T: Times out T->>R: Propagates cancellation R->>D: Propagates cancellation D-->>D: Cancellation of callback D->>T: Cancellation finished deactivate D T->>P: Throws <br/>TimeoutRejectedException P->>C: Propagates exception Sequence diagram for a pipeline with timeout, retry and timeout Let's create the following pipeline: the inner most strategy is a timeout (per attempt), the middle one is a retry which is timeout-aware, the outer most is a timeout which is overarching all retry attempts. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(10)) // outer most .AddRetry(new() { ShouldHandle = new PredicateBuilder().Handle<TimeoutRejectedException>() }) .AddTimeout(TimeSpan.FromSeconds(1)) // inner most .Build(); Let's suppose that the first request fails and the second takes too long. The third request is not awaited since the overarching timeout elapsed. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant TO as TimeoutOuter participant R as Retry participant TI as TimeoutInner participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>TO: Calls ExecuteCore Note over TO: Wait start activate TO TO->>R: Calls ExecuteCore Note over R, D: Initial attempt R->>TI: Calls ExecuteCore Note over TI: Wait start activate TI TI->>D: Invokes activate D D-->>D: Performs <br/>operation D->>TI: Fails deactivate D deactivate TI Note over TI: Wait end TI->>R: Propagate failure R-->>R: Sleeps Note over R, D: First retry attempt R->>TI: Calls ExecuteCore Note over TI: Wait start activate TI TI->>D: Invokes activate D D-->>D: Performs <br/>operation TI-->>TI: Times-out deactivate TI Note over TI: Wait end TI->>D: Propagates cancellation D-->>D: Cancellation of callback D->>TI: Cancellation finished deactivate D TI->>R: Throws <br/>TimeoutRejectedException R->>R: Sleeps Note over R, D: Second retry attempt R->>TI: Calls ExecuteCore Note over TI: Wait start activate TI TI->>D: Invokes activate D D-->>D: Performs <br/>operation TO-->>TO: Times-out deactivate TO Note over TO: Wait end TO->>R: Propagates cancellation R->>TI: Propagates cancellation TI->>D: Propagates cancellation D-->>D: Cancellation of callback D->>TO: Cancellation finished deactivate TI deactivate D TO->>P: Throws <br/>TimeoutRejectedException P->>C: Propagates exception"
  },
  "pipelines/resilience-pipeline-registry.html": {
    "href": "pipelines/resilience-pipeline-registry.html",
    "title": "Resilience pipeline registry | Polly",
    "keywords": "Resilience pipeline registry The ResiliencePipelineRegistry<TKey> is designed to create and cache resilience pipeline instances. The registry also implements the ResiliencePipelineProvider<TKey>, allowing read-only access to pipelines. The registry offers these features: Thread-safe retrieval and dynamic creation for both generic and non-generic resilience pipelines. Dynamic reloading of resilience pipelines when configurations change. Capability to register both generic and non-generic resilience pipeline builders, enabling dynamic pipeline instance creation. Automated resource management, which includes disposing of resources linked to resilience pipelines. Note The generic TKey parameter sets the key type for caching individual resilience pipelines within the registry. Typically, you would use the string-based ResiliencePipelineRegistry<string>. Usage To register pipeline builders, use the TryAddBuilder(...) method. This method accepts a callback argument that configures an instance of ResiliencePipelineBuilder for the pipeline being defined. The registry supports both generic and non-generic resilience pipelines. Note Please note that you do not have to call the Build method after you have set up your pipeline on the builder parameter of the TryAddBuilder. You can call the Build if you want but it is not necessary. Here's an example demonstrating these features: var registry = new ResiliencePipelineRegistry<string>(); // Register builder for pipeline \"A\" registry.TryAddBuilder(\"A\", (builder, context) => { // Define your pipeline builder.AddRetry(new RetryStrategyOptions()); }); // Register generic builder for pipeline \"A\"; you can use the same key // because generic and non-generic pipelines are stored separately registry.TryAddBuilder<HttpResponseMessage>(\"A\", (builder, context) => { // Define your pipeline builder.AddRetry(new RetryStrategyOptions<HttpResponseMessage>()); }); // Fetch pipeline \"A\" ResiliencePipeline pipelineA = registry.GetPipeline(\"A\"); // Fetch generic pipeline \"A\" ResiliencePipeline<HttpResponseMessage> genericPipelineA = registry.GetPipeline<HttpResponseMessage>(\"A\"); // Returns false since pipeline \"unknown\" isn't registered var doesPipelineExist = registry.TryGetPipeline(\"unknown\", out var pipeline); // Throws KeyNotFoundException because pipeline \"unknown\" isn't registered try { registry.GetPipeline(\"unknown\"); } catch (KeyNotFoundException) { // Handle the exception } Additionally, the registry allows you to add pipelines with the GetOrAddPipeline(...) method. In this method, there's no need to register builders. Instead, the caller provides a factory method called when the pipeline isn't cached: var registry = new ResiliencePipelineRegistry<string>(); // Dynamically retrieve or create pipeline \"A\" ResiliencePipeline pipeline = registry.GetOrAddPipeline(\"A\", (builder, context) => { // Define your pipeline builder.AddRetry(new RetryStrategyOptions()); }); // Dynamically retrieve or create generic pipeline \"A\" ResiliencePipeline<HttpResponseMessage> genericPipeline = registry.GetOrAddPipeline<HttpResponseMessage>(\"A\", (builder, context) => { // Define your pipeline builder.AddRetry(new RetryStrategyOptions<HttpResponseMessage>()); }); Registry options The constructor for ResiliencePipelineRegistry<TKey> accepts a parameter of type ResiliencePipelineRegistryOptions<TKey>. This parameter lets you configure the behavior of the registry. Here's a breakdown of the available properties: Property Default Value Description BuilderFactory Function returning a new ResiliencePipelineBuilder each time. Allows consumers to customize builder creation. PipelineComparer EqualityComparer<TKey>.Default Comparer the registry uses to fetch resilience pipelines. BuilderComparer EqualityComparer<TKey>.Default Comparer the registry uses to fetch registered pipeline builders. InstanceNameFormatter null Delegate formatting TKey to instance name. BuilderNameFormatter Function returning the key.ToString() value. Delegate formatting TKey to builder name. Note The BuilderName and InstanceName are used in telemetry. Usage example: var options = new ResiliencePipelineRegistryOptions<string> { BuilderComparer = StringComparer.OrdinalIgnoreCase, PipelineComparer = StringComparer.OrdinalIgnoreCase, BuilderFactory = () => new ResiliencePipelineBuilder { InstanceName = \"lets change the default of InstanceName\", Name = \"lets change the default of Name\", }, BuilderNameFormatter = key => $\"key:{key}\", InstanceNameFormatter = key => $\"instance-key:{key}\", }; var registry = new ResiliencePipelineRegistry<string>(); Even though the example might seem unnecessary, given that the defaults for a registry using the string type are suitable, it showcases the various properties of the registry and how to set them up. This is particularly helpful when you use complex registry keys. Dynamic reloads Dynamic reloading lets you refresh cached pipelines when the reload token, represented as a CancellationToken, is triggered. To enable dynamic reloads: var registry = new ResiliencePipelineRegistry<string>(); registry.TryAddBuilder(\"A\", (builder, context) => { // Add the reload token. Tokens that are already canceled are ignored. context.AddReloadToken(cancellationToken); // Define the pipeline. builder.AddRetry(new RetryStrategyOptions()); }); // This instance remains valid even after a reload. ResiliencePipeline pipeline = registry.GetPipeline(\"A\"); If an error occurs during reloading, the cached pipeline remains, and dynamic reloading stops. You should not reuse the cancellation token when the pipeline is reloaded. Pipelines enabled for reloads remain valid and current post-reload. The registry manages this transparently. How dynamic reloads work Dynamic reloading is a concept anchored in the registry, while the ResiliencePipelineBuilder remains agnostic to it. The registry employs callbacks to configure the builders, and these callbacks are invoked right before the creation of the pipeline. When dynamic reloading is activated, the registry monitors any changes that could affect the pipeline, seamlessly reloading it as needed. The reloading process involves invoking the callback that configures the pipeline; within this callback is also the call to the AddReloadToken method. Thus, each reload also enables dynamic reloads for that particular pipeline. As a consumer, you may opt to stop reloading by simply not invoking the AddReloadToken method. It's crucial to note that if any error occurs during reloading, the previous pipeline is retained, reloading is halted, and Polly emits a ReloadFailed telemetry event. Resource disposal The registry caches and manages all pipelines and resources linked to them. When you dispose of the registry, all pipelines created by it are also disposed of and can't be used anymore. The following example illustrates this: var registry = new ResiliencePipelineRegistry<string>(); // This instance is valid even after reload. ResiliencePipeline pipeline = registry .GetOrAddPipeline(\"A\", (builder, context) => builder.AddTimeout(TimeSpan.FromSeconds(10))); // Dispose the registry registry.Dispose(); try { pipeline.Execute(() => { }); } catch (ObjectDisposedException) { // Using a pipeline that was disposed by the registry } The registry also allows for the registration of dispose callbacks. These are called when a pipeline is discarded, either because of the registry's disposal or after the pipeline has reloaded. The example below works well with dynamic reloads, letting you dispose of the CancellationTokenSource when it's not needed anymore. var registry = new ResiliencePipelineRegistry<string>(); registry.TryAddBuilder(\"A\", (builder, context) => { var cancellation = new CancellationTokenSource(); // Register the source for potential external triggering RegisterCancellationSource(cancellation); // Add the reload token; note that an already cancelled token is disregarded context.AddReloadToken(cancellation.Token); // Configure your pipeline builder.AddRetry(new RetryStrategyOptions()); context.OnPipelineDisposed(() => cancellation.Dispose()); }); Both AddReloadToken(...) and OnPipelineDisposed(...) are used to implement the EnableReloads<TOptions>(...) extension method that is used by the Dependency Injection layer. How resource disposal works Resource disposal occurs when the registry is disposed of or when the pipeline undergoes changes due to dynamic reloads. Upon disposal, all callbacks registered through the OnPipelineDisposed method are invoked. However, actual resource disposal is deferred until the pipeline completes all outgoing executions. It's vital to note that dispose callbacks are associated only with a specific instance of the pipeline. Complex registry keys Though the pipeline registry supports complex keys, we suggest you use them when defining pipelines with the Dependency Injection (DI) containers. For further information, see the section on complex pipeline keys."
  },
  "strategies/circuit-breaker.html": {
    "href": "strategies/circuit-breaker.html",
    "title": "Circuit breaker resilience strategy | Polly",
    "keywords": "Circuit breaker resilience strategy About Options: CircuitBreakerStrategyOptions CircuitBreakerStrategyOptions<T> Extensions: AddCircuitBreaker Strategy Type: Reactive Exceptions: BrokenCircuitException: Thrown when a circuit is broken and the action could not be executed. IsolatedCircuitException: Thrown when a circuit is isolated (held open) by manual override. Note Be aware that the Circuit Breaker strategy rethrows all exceptions, including those that are handled. A Circuit Breaker's role is to monitor faults and break the circuit when a certain threshold is reached; it does not manage retries. Combine the Circuit Breaker with a Retry strategy if needed. Usage // Circuit breaker with default options. // See https://www.pollydocs.org/strategies/circuit-breaker#defaults for defaults. var optionsDefaults = new CircuitBreakerStrategyOptions(); // Circuit breaker with customized options: // The circuit will break if more than 50% of actions result in handled exceptions, // within any 10-second sampling duration, and at least 8 actions are processed. var optionsComplex = new CircuitBreakerStrategyOptions { FailureRatio = 0.5, SamplingDuration = TimeSpan.FromSeconds(10), MinimumThroughput = 8, BreakDuration = TimeSpan.FromSeconds(30), ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>() }; // Circuit breaker using BreakDurationGenerator: // The break duration is dynamically determined based on the properties of BreakDurationGeneratorArguments. var optionsBreakDurationGenerator = new CircuitBreakerStrategyOptions { FailureRatio = 0.5, SamplingDuration = TimeSpan.FromSeconds(10), MinimumThroughput = 8, BreakDurationGenerator = static args => new ValueTask<TimeSpan>(TimeSpan.FromMinutes(args.FailureCount)), }; // Handle specific failed results for HttpResponseMessage: var optionsShouldHandle = new CircuitBreakerStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<SomeExceptionType>() .HandleResult(response => response.StatusCode == HttpStatusCode.InternalServerError) }; // Monitor the circuit state, useful for health reporting: var stateProvider = new CircuitBreakerStateProvider(); var optionsStateProvider = new CircuitBreakerStrategyOptions<HttpResponseMessage> { StateProvider = stateProvider }; var circuitState = stateProvider.CircuitState; /* CircuitState.Closed - Normal operation; actions are executed. CircuitState.Open - Circuit is open; actions are blocked. CircuitState.HalfOpen - Recovery state after break duration expires; actions are permitted. CircuitState.Isolated - Circuit is manually held open; actions are blocked. */ // Manually control the Circuit Breaker state: var manualControl = new CircuitBreakerManualControl(); var optionsManualControl = new CircuitBreakerStrategyOptions { ManualControl = manualControl }; // Manually isolate a circuit, e.g., to isolate a downstream service. await manualControl.IsolateAsync(); // Manually close the circuit to allow actions to be executed again. await manualControl.CloseAsync(); // Add a circuit breaker strategy with a CircuitBreakerStrategyOptions{<TResult>} instance to the pipeline new ResiliencePipelineBuilder().AddCircuitBreaker(optionsDefaults); new ResiliencePipelineBuilder<HttpResponseMessage>().AddCircuitBreaker(optionsStateProvider); Defaults Property Default Value Description ShouldHandle Predicate that handles all exceptions except OperationCanceledException. Specifies which results and exceptions are managed by the circuit breaker strategy. FailureRatio 0.1 The ratio of failures to successes that will cause the circuit to break/open. MinimumThroughput 100 The minimum number of actions that must occur in the circuit within a specific time slice. SamplingDuration 30 seconds The time period over which failure ratios are calculated. BreakDuration 5 seconds The time period for which the circuit will remain broken/open before attempting to reset. BreakDurationGenerator null Enables adaptive adjustment of break duration based on the current state of the circuit. OnClosed null Event triggered when the circuit transitions to the Closed state. OnOpened null Event triggered when the circuit transitions to the Opened state. OnHalfOpened null Event triggered when the circuit transitions to the HalfOpened state. ManualControl null Allows for manual control to isolate or close the circuit. StateProvider null Enables the retrieval of the current state of the circuit. Note If both BreakDuration and BreakDurationGenerator are specified then BreakDuration will be ignored. Diagrams State diagram stateDiagram-v2 direction LR [*] --> Closed Closed --> Open: Exceeds threshold Open --> HalfOpen: Elapses break duration HalfOpen --> Closed: Passes the probe HalfOpen --> Open: Fails the probe Whenever someone says the circuit breaks that means the Circuit Breaker transitions from the Closed state to the Open state. Simple Let's suppose we have a circuit breaker strategy wit the following configuration: SamplingDuration: 2 seconds; MinimumThroughput: 2; FailureRatio : 0.5. Simple: happy path sequence diagram The circuit will not break because the actual failure ratio (0.33) will be below the threshold (0.5) after the 3rd call. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant CB as CircuitBreaker participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore Note over CB: Closed state Note over CB, D: Sampling start activate CB CB->>+D: Invokes D->>-CB: Returns result CB->>P: Returns result P->>C: Returns result C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB->>+D: Invokes D->>-CB: Returns result CB->>P: Returns result P->>C: Returns result C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB->>+D: Invokes D->>-CB: Fails deactivate CB Note over CB, D: Sampling end CB->>P: Propagates failure P->>C: Propagates failure Simple: unhappy path sequence diagram The circuit will break because the actual failure ratio meets the threshold (0.5) after the 2nd call. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant CB as CircuitBreaker participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore Note over CB: Closed state Note over CB, D: Sampling start activate CB CB->>+D: Invokes D->>-CB: Returns result CB->>P: Returns result P->>C: Returns result C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB->>+D: Invokes D->>-CB: Fails Note over CB: Moves to Open state CB->>P: Propagates failure P->>C: Propagates failure C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB-->>CB: Rejects request CB->>P: Throws <br/>BrokenCircuitException P->>C: Propagates exception deactivate CB Note over CB, D: Sampling end Complex Let's suppose we have a circuit breaker strategy with the following configuration: SamplingDuration: 2 seconds; MinimumThroughput: 2; FailureRatio: 0.5; BreakDuration:1 second. Complex: happy path sequence diagram The circuit will break and later it will transition into the HalfOpen state. The probe will then succeed, so the circuit breaker will go back to the normal (Closed) state. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant CB as CircuitBreaker participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore Note over CB: Closed state CB->>+D: Invokes D->>-CB: Fails CB->>P: Propagates failure P->>C: Propagates failure C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB->>+D: Invokes D->>-CB: Fails Note over CB: Moves to Open state Note over CB: Break duration start CB->>P: Propagates failure P->>C: Propagates failure C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB-->>CB: Rejects request CB->>P: Throws <br/>BrokenCircuitException P->>C: Propagates exception C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore Note over CB: Break duration end Note over CB: Moves to HalfOpen state CB->>+D: Invokes D->>-CB: Returns result Note over CB: Moves to Closed state CB->>P: Returns result P->>C: Returns result Complex: unhappy path sequence diagram The circuit will break and later it will transition into the HalfOpen state. The probe will then fail, so the circuit breaker will become broken again (the Open state). sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant CB as CircuitBreaker participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore Note over CB: Closed state CB->>+D: Invokes D->>-CB: Fails CB->>P: Propagates failure P->>C: Propagates failure C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB->>+D: Invokes D->>-CB: Fails Note over CB: Moves to Open state Note over CB: Break duration start CB->>P: Propagates failure P->>C: Propagates failure C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB-->>CB: Rejects request CB->>P: Throws <br/>BrokenCircuitException P->>C: Propagates exception C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore Note over CB: Break duration end Note over CB: Moves to HalfOpen state CB->>+D: Invokes D->>-CB: Fails Note over CB: Moves to Open state CB->>P: Propagates failure P->>C: Propagates failure Complex: dynamic break duration sequence diagram This sequence diagram illustrates the behavior of a circuit breaker using a BreakDurationGenerator. The generator dynamically calculates the break duration based on specific criteria, such as the number of failures: sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant CB as CircuitBreaker participant BDG as BreakDurationGenerator participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore Note over CB: Closed state CB->>+D: Invokes D->>-CB: Fails Note over CB: Moves to Open state CB->>+BDG: Calls Generator BDG->>-CB: Returns calculated <br/> duration Note over CB: Break duration start CB->>P: Propagates failure P->>C: Propagates failure C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore CB-->>CB: Rejects request CB->>P: Throws <br/>BrokenCircuitException P->>C: Propagates exception C->>P: Calls ExecuteAsync P->>CB: Calls ExecuteCore Note over CB: Break duration end Note over CB: Moves to HalfOpen state CB->>+D: Invokes D->>-CB: Returns result Note over CB: Moves to Closed state CB->>P: Returns result P->>C: Returns result Resources Making the Netflix API More Resilient Circuit Breaker by Martin Fowler Circuit Breaker Pattern by Microsoft Original Circuit Breaking Article Anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. The sections below highlight anti-patterns to avoid. Using different sleep duration between retry attempts based on Circuit Breaker state Imagine that we have an inner Circuit Breaker and an outer Retry strategies. We would like to define the retry in a way that the sleep duration calculation is taking into account the Circuit Breaker's state. ❌ DON'T Use a closure to branch based on circuit breaker state: var stateProvider = new CircuitBreakerStateProvider(); var circuitBreaker = new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), BreakDuration = TimeSpan.FromSeconds(5), StateProvider = stateProvider }) .Build(); var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<HttpRequestException>() .Handle<BrokenCircuitException>(), DelayGenerator = args => { TimeSpan? delay = TimeSpan.FromSeconds(1); if (stateProvider.CircuitState == CircuitState.Open) { delay = TimeSpan.FromSeconds(5); } return ValueTask.FromResult(delay); } }) .Build(); Reasoning: By default, each strategy is independent and has no any reference to other strategies. We use the (stateProvider) to access the Circuit Breaker's state. However, this approach is not optimal as the retry strategy's DelayGenerator varies based on state. This solution is delicate because the break duration and the sleep duration aren't linked. If a future code maintainer modifies the circuitBreaker's BreakDuration, they might overlook adjusting the sleep duration. ✅ DO Use Context to pass information between strategies: var circuitBreaker = new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), BreakDuration = TimeSpan.FromSeconds(5), OnOpened = static args => { args.Context.Properties.Set(SleepDurationKey, args.BreakDuration); return ValueTask.CompletedTask; }, OnClosed = args => { args.Context.Properties.Set(SleepDurationKey, null); return ValueTask.CompletedTask; } }) .Build(); var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<HttpRequestException>() .Handle<BrokenCircuitException>(), DelayGenerator = static args => { _ = args.Context.Properties.TryGetValue(SleepDurationKey, out var delay); delay ??= TimeSpan.FromSeconds(1); return ValueTask.FromResult(delay); } }) .Build(); Reasoning: Both strategies are less coupled in this approach since they rely on the context and the sleepDurationKey components. The Circuit Breaker shares the BreakDuration through the context when it breaks. When it transitions back to Closed, the sharing is revoked. The Retry strategy fetches the sleep duration dynamically without knowing any specific knowledge about the Circuit Breaker. If adjustments are needed for the BreakDuration, they can be made in one place. Wrapping each endpoint with a circuit breaker Imagine that you have to call N number of services via HttpClients. You want to decorate all downstream calls with the service-aware Circuit Breaker. ❌ DON'T Use a collection of Circuit Breakers and explicitly call ExecuteAsync(): // Defined in a common place var uriToCbMappings = new Dictionary<Uri, ResiliencePipeline> { [new Uri(\"https://downstream1.com\")] = GetCircuitBreaker(), // ... [new Uri(\"https://downstreamN.com\")] = GetCircuitBreaker() }; // Used in the downstream 1 client var downstream1Uri = new Uri(\"https://downstream1.com\"); await uriToCbMappings[downstream1Uri].ExecuteAsync(CallXYZOnDownstream1, CancellationToken.None); Reasoning: Whenever you use an HttpClient, you must have a reference to the uriToCbMappings dictionary. It's your responsibility to decorate each network call with the corresponding circuit breaker. ✅ DO Use named HttpClients and then call AddResilienceHandler extension that is included in the Microsoft.Extensions.Http.Resilience package. services .AddHttpClient(\"my-client\") .AddResilienceHandler(\"circuit-breaker\", builder => { builder.AddCircuitBreaker(new()); }) .SelectPipelineByAuthority(); // This call ensures that circuit breaker is cached by each URL authority And then use it: HttpClient client = httpClientFactory.CreateClient(\"my-client\"); await client.GetAsync(new Uri(\"https://downstream1.com/some-path\")); Reasoning: The HttpClient integrates with Circuit Breaker during startup by using the AddResilienceHandler extension. There's no need to call ExecuteAsync() directly. The DelegatingHandler handles it automatically. By using the SelectPipelineByAuthority extension method, the resilience handler caches and assigns resilience pipeline to each authority (scheme + host + port) that is extracted from HTTP request message. Reducing thrown exceptions In case of Circuit Breaker when it is either in the Open or Isolated state new requests are rejected immediately. That means the strategy will throw either a BrokenCircuitException or an IsolatedCircuitException respectively. ❌ DON'T Use guard expression to call Execute{Async} only if the circuit is not broken: var stateProvider = new CircuitBreakerStateProvider(); var circuitBreaker = new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), BreakDuration = TimeSpan.FromSeconds(0.5), StateProvider = stateProvider }) .Build(); if (stateProvider.CircuitState is not CircuitState.Open and not CircuitState.Isolated) { var response = await circuitBreaker.ExecuteAsync(static async ct => { return await IssueRequest(); }, CancellationToken.None); // Your code goes here to process response } Reasoning: The problem with this approach is that the circuit breaker will never transition into the HalfOpen state. The circuit breaker does not act as an active object. In other words the state transition does not happen automatically in the background. The circuit transition into the HalfOpen state when the Execute{Async} method is called and the BreakDuration elapsed. ✅ DO Use ExecuteOutcomeAsync to avoid throwing exception: var context = ResilienceContextPool.Shared.Get(); var circuitBreaker = new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), BreakDuration = TimeSpan.FromSeconds(0.5), }) .Build(); Outcome<HttpResponseMessage> outcome = await circuitBreaker.ExecuteOutcomeAsync(static async (ctx, state) => { var response = await IssueRequest(); return Outcome.FromResult(response); }, context, \"state\"); ResilienceContextPool.Shared.Return(context); if (outcome.Exception is BrokenCircuitException) { // The execution was stopped by the circuit breaker } else { HttpResponseMessage response = outcome.Result!; // Your code goes here to process the response } Reasoning: The ExecuteOutcomeAsync is a low-allocation API which does not throw exceptions; rather it captures them inside an Outcome data structure. Since you are calling one of the Execute methods, that's why the circuit breaker can transition into the HalfOpen state."
  },
  "strategies/fallback.html": {
    "href": "strategies/fallback.html",
    "title": "Fallback resilience strategy | Polly",
    "keywords": "Fallback resilience strategy About Options: FallbackStrategyOptions<T> Extensions: AddFallback Strategy Type: Reactive Usage // A fallback/substitute value if an operation fails. var optionsSubstitute = new FallbackStrategyOptions<UserAvatar> { ShouldHandle = new PredicateBuilder<UserAvatar>() .Handle<SomeExceptionType>() .HandleResult(r => r is null), FallbackAction = static args => Outcome.FromResultAsValueTask(UserAvatar.Blank) }; // Use a dynamically generated value if an operation fails. var optionsFallbackAction = new FallbackStrategyOptions<UserAvatar> { ShouldHandle = new PredicateBuilder<UserAvatar>() .Handle<SomeExceptionType>() .HandleResult(r => r is null), FallbackAction = static args => { var avatar = UserAvatar.GetRandomAvatar(); return Outcome.FromResultAsValueTask(avatar); } }; // Use a default or dynamically generated value, and execute an additional action if the fallback is triggered. var optionsOnFallback = new FallbackStrategyOptions<UserAvatar> { ShouldHandle = new PredicateBuilder<UserAvatar>() .Handle<SomeExceptionType>() .HandleResult(r => r is null), FallbackAction = static args => { var avatar = UserAvatar.GetRandomAvatar(); return Outcome.FromResultAsValueTask(UserAvatar.Blank); }, OnFallback = static args => { // Add extra logic to be executed when the fallback is triggered, such as logging. return default; // Returns an empty ValueTask } }; // Add a fallback strategy with a FallbackStrategyOptions<TResult> instance to the pipeline new ResiliencePipelineBuilder<UserAvatar>().AddFallback(optionsOnFallback); Defaults Property Default Value Description ShouldHandle Predicate that handles all exceptions except OperationCanceledException. Predicate that determines what results and exceptions are handled by the fallback strategy. FallbackAction Null, Required Fallback action to be executed. OnFallback null Event that is raised when fallback happens. Diagrams Happy path sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant F as Fallback participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>F: Calls ExecuteCore F->>+D: Invokes D->>-F: Returns result F->>P: Returns result P->>C: Returns result Unhappy path sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant F as Fallback participant FA as FallbackAction participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>F: Calls ExecuteCore F->>+D: Invokes D->>-F: Fails F->>+FA: Invokes FA-->>FA: Calculates substitute result FA->>-F: Returns <br/>substituted result F->>P: Returns <br/>substituted result P->>C: Returns <br/>substituted result Patterns Fallback after retries When designing resilient systems, a common pattern is to use a fallback after multiple failed retry attempts. This approach is especially relevant when a fallback strategy can provide a sensible default value. // Define a common predicates re-used by both fallback and retries var predicateBuilder = new PredicateBuilder<HttpResponseMessage>() .Handle<HttpRequestException>() .HandleResult(r => r.StatusCode == HttpStatusCode.InternalServerError); var pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddFallback(new() { ShouldHandle = predicateBuilder, FallbackAction = args => { // Try to resolve the fallback response HttpResponseMessage fallbackResponse = ResolveFallbackResponse(args.Outcome); return Outcome.FromResultAsValueTask(fallbackResponse); } }) .AddRetry(new() { ShouldHandle = predicateBuilder, MaxRetryAttempts = 3, }) .Build(); // Demonstrative execution that always produces invalid result pipeline.Execute(() => new HttpResponseMessage(HttpStatusCode.InternalServerError)); Here's a breakdown of the behavior when the callback produces either an HttpStatusCode.InternalServerError or an HttpRequestException: The fallback strategy initiates by executing the provided callback, then immediately passes the execution to the retry strategy. The retry strategy starts execution, makes 3 retry attempts and yields the outcome that represents an error. The fallback strategy resumes execution, assesses the outcome generated by the callback, and if necessary, supplies the fallback value. The fallback strategy completes its execution. Note The preceding example also demonstrates how to re-use ResiliencePipelineBuilder<HttpResponseMessage> across multiple strategies. Anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. The sections below highlight anti-patterns to avoid. Using fallback to replace thrown exception ❌ DON'T Throw custom exceptions from the OnFallback delegate: var fallback = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddFallback(new() { ShouldHandle = new PredicateBuilder<HttpResponseMessage>().Handle<HttpRequestException>(), FallbackAction = args => Outcome.FromResultAsValueTask(new HttpResponseMessage()), OnFallback = args => throw new CustomNetworkException(\"Replace thrown exception\", args.Outcome.Exception!) }) .Build(); Reasoning: Throwing an exception from a user-defined delegate can disrupt the normal control flow. ✅ DO Use ExecuteOutcomeAsync and then evaluate the Exception: var outcome = await WhateverPipeline.ExecuteOutcomeAsync(Action, context, \"state\"); if (outcome.Exception is HttpRequestException requestException) { throw new CustomNetworkException(\"Replace thrown exception\", requestException); } Reasoning: This method lets you execute the strategy or pipeline smoothly, without unexpected interruptions. If you repeatedly find yourself writing this exception \"remapping\" logic, consider marking the method you wish to decorate as private and expose the \"remapping\" logic publicly. public static async ValueTask<HttpResponseMessage> Action() { var context = ResilienceContextPool.Shared.Get(); var outcome = await WhateverPipeline.ExecuteOutcomeAsync<HttpResponseMessage, string>( async (ctx, state) => { var result = await ActionCore(); return Outcome.FromResult(result); }, context, \"state\"); if (outcome.Exception is HttpRequestException requestException) { throw new CustomNetworkException(\"Replace thrown exception\", requestException); } ResilienceContextPool.Shared.Return(context); return outcome.Result!; } private static ValueTask<HttpResponseMessage> ActionCore() { // The core logic return ValueTask.FromResult(new HttpResponseMessage()); } Using retry for fallback Suppose you have a primary and a secondary endpoint. If the primary fails, you want to call the secondary. ❌ DON'T Use retry for fallback: var fallback = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRetry(new() { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .HandleResult(res => res.StatusCode == HttpStatusCode.RequestTimeout), MaxRetryAttempts = 1, OnRetry = async args => { args.Context.Properties.Set(fallbackKey, await CallSecondary(args.Context.CancellationToken)); } }) .Build(); var context = ResilienceContextPool.Shared.Get(); var outcome = await fallback.ExecuteOutcomeAsync<HttpResponseMessage, string>( async (ctx, state) => { var result = await CallPrimary(ctx.CancellationToken); return Outcome.FromResult(result); }, context, \"none\"); var result = outcome.Result is not null ? outcome.Result : context.Properties.GetValue(fallbackKey, default); ResilienceContextPool.Shared.Return(context); return result; Reasoning: A retry strategy by default executes the same operation up to N times, where N equals the initial attempt plus MaxRetryAttempts. In this case, that means 2 times. Here, the fallback is introduced as a side effect rather than a replacement. ✅ DO Use fallback to call the secondary: var fallback = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddFallback(new() { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .HandleResult(res => res.StatusCode == HttpStatusCode.RequestTimeout), FallbackAction = async args => Outcome.FromResult(await CallSecondary(args.Context.CancellationToken)) }) .Build(); return await fallback.ExecuteAsync(CallPrimary, CancellationToken.None); Reasoning: The target code is executed only once. The fallback value is returned directly, eliminating the need for additional code like Context or ExecuteOutcomeAsync(). Nesting ExecuteAsync calls Combining multiple strategies can be achieved in various ways. However, deeply nesting ExecuteAsync calls can lead to what's commonly referred to as Execute Hell. Note While this isn't strictly tied to the Fallback mechanism, it's frequently observed when Fallback is the outermost layer. ❌ DON'T Nest ExecuteAsync calls: var result = await fallback.ExecuteAsync(async (CancellationToken outerCT) => { return await timeout.ExecuteAsync(static async (CancellationToken innerCT) => { return await CallExternalSystem(innerCT); }, outerCT); }, CancellationToken.None); return result; Reasoning: This is akin to JavaScript's callback hell or the pyramid of doom. It's easy to mistakenly reference the wrong CancellationToken parameter. ✅ DO Use ResiliencePipelineBuilder to chain strategies: var pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddPipeline(timeout) .AddPipeline(fallback) .Build(); return await pipeline.ExecuteAsync(CallExternalSystem, CancellationToken.None); Reasoning: In this approach, we leverage the escalation mechanism provided by Polly rather than creating our own through nesting. CancellationToken values are automatically propagated between the strategies for you."
  },
  "strategies/hedging.html": {
    "href": "strategies/hedging.html",
    "title": "Hedging resilience strategy | Polly",
    "keywords": "Hedging resilience strategy About Options: HedgingStrategyOptions<T> Extensions: AddHedging Strategy Type: Reactive The hedging strategy enables the re-execution of a user-defined callback if the previous execution takes too long. This approach gives you the option to either run the original callback again or specify a new callback for subsequent hedged attempts. Implementing a hedging strategy can boost the overall responsiveness of the system. However, it's essential to note that this improvement comes at the cost of increased resource utilization. If low latency is not a critical requirement, you may find the retry strategy is more appropriate. This strategy also supports multiple concurrency modes for added flexibility. Note Please do not start any background work when executing actions using the hedging strategy. This strategy can spawn multiple parallel tasks, and as a result multiple background tasks can be started. Usage // Hedging with default options. // See https://www.pollydocs.org/strategies/hedging#defaults for defaults. var optionsDefaults = new HedgingStrategyOptions<HttpResponseMessage>(); // A customized hedging strategy that retries up to 3 times if the execution // takes longer than 1 second or if it fails due to an exception or returns an HTTP 500 Internal Server Error. var optionsComplex = new HedgingStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<SomeExceptionType>() .HandleResult(response => response.StatusCode == HttpStatusCode.InternalServerError), MaxHedgedAttempts = 3, Delay = TimeSpan.FromSeconds(1), ActionGenerator = static args => { Console.WriteLine(\"Preparing to execute hedged action.\"); // Return a delegate function to invoke the original action with the action context. // Optionally, you can also create a completely new action to be executed. return () => args.Callback(args.ActionContext); } }; // Subscribe to hedging events. var optionsOnHedging = new HedgingStrategyOptions<HttpResponseMessage> { OnHedging = static args => { Console.WriteLine($\"OnHedging: Attempt number {args.AttemptNumber}\"); return default; } }; // Add a hedging strategy with a HedgingStrategyOptions<TResult> instance to the pipeline new ResiliencePipelineBuilder<HttpResponseMessage>().AddHedging(optionsDefaults); Defaults Property Default Value Description ShouldHandle Predicate that handles all exceptions except OperationCanceledException. Predicate that determines what results and exceptions are handled by the retry strategy. MaxHedgedAttempts 1 The maximum number of hedged actions to use, in addition to the original action. Delay 2 seconds The maximum waiting time before spawning a new hedged action. ActionGenerator Returns the original callback that was passed to the hedging strategy. Generator that creates hedged actions. DelayGenerator null Used for generating custom delays for hedging. OnHedging null Event that is raised when a hedging is performed. You can use the following special values for Delay or in DelayGenerator: 0 seconds - the hedging strategy immediately creates a total of MaxHedgedAttempts and completes when the fastest acceptable result is available. -1 millisecond - this value indicates that the strategy does not create a new hedged task before the previous one completes. This enables scenarios where having multiple concurrent hedged tasks can cause side effects. Note If both Delay and DelayGenerator are specified then Delay will be ignored. Concurrency modes In the sections below, explore the different concurrency modes available in the hedging strategy. The behavior is primarily controlled by the Delay property value. Latency mode When the Delay property is set to a value greater than zero, the hedging strategy operates in latency mode. In this mode, additional executions are triggered when the initial ones take too long to complete. By default, the Delay is set to 2 seconds. The primary execution is initiated. If the initial execution either fails or takes longer than the Delay to complete, a new execution is initiated. If the first two executions fail or exceed the Delay (calculated from the last initiated execution), another execution is triggered. Happy path: The final result is the result of fastest successful execution. Unhappy path: If all executions fail, the final result will be the primary execution's failure. Latency: happy path sequence diagram The hedging strategy does not trigger because the response arrives faster than the threshold. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant H as Hedging participant HUC as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore Note over H: Wait start activate H H->>+HUC: Invokes HUC-->>HUC: Processes request HUC->>-H: Returns result deactivate H Note over H: Wait end H->>P: Returns result P->>C: Returns result Latency: unhappy path sequence diagram The hedging strategy triggers because the response arrives slower than the threshold. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant H as Hedging participant D as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore Note over H: Wait start activate H activate D H->>D: Invokes (R1) D-->>D: Processes R1<br/> slowly ... Note over H: Wait end H->>D: Invokes (R2) activate D D-->>D: Processes R2<br/> quickly D->>H: Returns result (R2) deactivate D deactivate D H->>D: Propagates cancellation (R1) activate D D-->>D: Cancellation of pending actions (R1) deactivate D D->>H: Cancellation finished (R1) deactivate H H->>P: Returns result (R2) P->>C: Returns result (R2) Note Notice that the hedging waits until all additional pending actions are cancelled before returning the accepted result. Therefore it's important for the hedged actions to respect the cancellation token passed to the execution. If the cancellation token is not correctly respected, the hedging is unnecessarily delayed. Fallback mode In fallback mode, the Delay value should be less than TimeSpan.Zero. This mode allows only a single execution to proceed at a given time. An execution is initiated, and the strategy waits for its completion. If the initial execution fails, new one is initiated. Happy path: The final result will be the first successful execution. Unhappy path: If all executions fail, the final result will be the primary execution's failure. Fallback: happy path sequence diagram The hedging strategy triggers because the first attempt fails. It succeeds because the retry attempts do not exceed the MaxHedgedAttempts. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant H as Hedging participant HUC as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore activate H H->>+HUC: Invokes (R1) HUC-->>HUC: Processes R1 HUC->>-H: Fails (R1) H->>+HUC: Invokes (R2) HUC-->>HUC: Processes R2 HUC->>-H: Returns result (R2) deactivate H H->>P: Returns result (R2) P->>C: Returns result (R2) Fallback: unhappy path sequence diagram The hedging strategy triggers because the first attempt fails. It fails because all retry attempts failed as well. sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant H as Hedging participant HUC as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore activate H H->>+HUC: Invokes (R1) HUC-->>HUC: Processes R1 HUC->>-H: Fails (R1) H->>+HUC: Invokes (R2) HUC-->>HUC: Processes R2 HUC->>-H: Fails (R2) deactivate H H->>P: Propagates failure (R1) P->>C: Propagates failure (R1) Parallel mode The hedging strategy operates in parallel mode when the Delay property is set to TimeSpan.Zero. In this mode, all executions are initiated simultaneously, and the strategy waits for the fastest completion. Important Use this mode only when absolutely necessary, as it consumes the most resources, particularly when the hedging strategy uses remote resources such as remote HTTP services. All executions are initiated simultaneously, adhering to the MaxHedgedAttempts limit. Happy path: The final result will be the fastest successful execution. Unhappy path: If all executions fail, the final result will be the primary execution's failure Parallel: happy path sequence diagram The hedging strategy triggers because the Delay is set to zero. It succeeds because one of the requests succeeds. sequenceDiagram actor C as Caller participant P as Pipeline participant H as Hedging participant HUC as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore activate H par H->>HUC: Invokes (R1) activate HUC and H->>+HUC: Invokes (R2) end HUC-->>HUC: Processes R1<br/> slowly ... HUC-->>HUC: Processes R2<br/> quickly ... HUC->>-H: Returns result (R2) deactivate HUC H->>HUC: Propagates cancellation (R1) activate HUC HUC-->>HUC: Cancellation of pending actions (R1) deactivate HUC HUC->>H: Cancellation finished (R1) deactivate H H->>P: Returns result (R2) P->>C: Returns result (R2) Note Notice that the hedging waits until all additional pending actions are cancelled before returning the accepted result. Therefore it's important for the hedged actions to respect the cancellation token passed to the execution. If the cancellation token is not correctly respected, the hedging is unnecessarily delayed. Parallel: unhappy path sequence diagram The hedging strategy triggers because the Delay is set to zero. It fails because all requests fail. sequenceDiagram actor C as Caller participant P as Pipeline participant H as Hedging participant HUC as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore activate H par H->>HUC: Invokes (R1) activate HUC and H->>+HUC: Invokes (R2) end HUC-->>HUC: Processes R1 HUC-->>HUC: Processes R2 HUC->>-H: Fails (R2) HUC->>-H: Fails (R1) deactivate H H->>P: Propagates failure (R1) P->>C: Propagates failure (R1) Dynamic mode In dynamic mode, you have the flexibility to control how the hedging strategy behaves during each execution. This control is achieved through the DelayGenerator property. Note The Delay property is disregarded when DelayGenerator is set. Example scenario: First, initiate the first two executions in parallel mode. Subsequently, switch to fallback mode for additional executions. To configure hedging according to the above scenario, use the following code: new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new() { MaxHedgedAttempts = 3, DelayGenerator = args => { var delay = args.AttemptNumber switch { 0 or 1 => TimeSpan.Zero, // Parallel mode _ => TimeSpan.FromSeconds(-1) // switch to Fallback mode }; return new ValueTask<TimeSpan>(delay); } }); With this configuration, the hedging strategy: Initiates a maximum of 4 executions. This includes initial action and an additional 3 attempts. Allows the first two executions to proceed in parallel, while the third and fourth executions follow the fallback mode. Dynamic: happy path sequence diagram The hedging strategy triggers and switches between modes due to our DelayGenerator. It succeeds because the last request succeeds. sequenceDiagram actor C as Caller participant P as Pipeline participant H as Hedging participant DG as DelayGenerator participant HUC as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore activate H Note over H: Parallel mode par H->>DG: Gets delay DG->>H: 0 second H->>HUC: Invokes (R1) activate HUC and H ->> DG: Gets delay DG ->> H: 0 second H->>+HUC: Invokes (R2) end HUC-->>HUC: Processes R1 HUC-->>HUC: Processes R2 HUC->>-H: Fails (R2) HUC->>-H: Fails (R1) Note over H: Fallback mode H->>DG: Gets delay DG->>H: -1 second H->>+HUC: Invokes (R3) HUC-->>HUC: Processes R3 HUC->>-H: Fails (R3) H->>DG: Gets delay DG->>H: -1 second H->>+HUC: Invokes (R4) HUC-->>HUC: Processes R4 HUC->>-H: Returns result (R4) deactivate H H->>P: Returns result (R4) P->>C: Returns result (R4) Dynamic: unhappy path sequence diagram The hedging strategy triggers and switches between modes due our DelayGenerator. It fails because all requests fail. sequenceDiagram actor C as Caller participant P as Pipeline participant H as Hedging participant DG as DelayGenerator participant HUC as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore activate H Note over H: Parallel mode par H->>DG: Gets delay DG->>H: 0 second H->>HUC: Invokes (R1) activate HUC and H->>DG: Gets delay DG->>H: 0 second H->>+HUC: Invokes (R2) end HUC-->>HUC: Processes R1 HUC-->>HUC: Processes R2 HUC->>-H: Fails (R2) HUC->>-H: Fails (R1) Note over H: Fallback mode H->>DG: Gets delay DG->>H: -1 second H->>+HUC: Invokes (R3) HUC-->>HUC: Processes R3 HUC->>-H: Fails (R3) H -> DG: Gets delay DG->>H: -1 second H->>+HUC: Invokes (R4) HUC-->>HUC: Processes R4 HUC->>-H: Fails (R4) deactivate H H->>P: Propagates failure (R3) P->>C: Propagates failure (R3) Hedging and resilience context The hedging strategy supports the concurrent execution and cancellation of multiple hedged actions. To safeguard against concurrency issues when these actions access the same ResilienceContext, the hedging strategy ensures that each hedged action has its own unique ResilienceContext. The hedging strategy distinguishes between two types of contexts: Primary context: The original resilience context that the hedging strategy receives. Action context: A deep copy of the primary context with a distinct cancellation token for a single hedged action. Here's the flow: The strategy gets the primary context and preserves it for deep-cloning. After the strategy has an accepted result from a hedged action, the resilience context from the action is merged back into the primary context. All ongoing hedged actions are cancelled and discarded. The hedging strategy awaits the propagation of cancellation. Merging action context into the primary context After merging, the primary context contains: New properties created during the action context's execution. Existing properties updated or soft-deleted (i.e. setting the value to null) during execution. Hedging callbacks Some insights about the hedging callback behavior in relation to hedging contexts: ActionGenerator: This callback provides arguments with PrimaryContext and ActionContext properties. Use PrimaryContext to get values that remain consistent throughout the hedging strategy execution. Use ActionContext to save values specific to a single hedged action execution. OnHedging: This callback, like the previous one, provides arguments with PrimaryContext and ActionContext properties and is invoked after ActionGenerator. Any changes to both PrimaryContext and ActionContext are preserved and visible here. Note The hedging strategy ensures that both ActionGenerator and OnHedging are never executed concurrently. Any modifications to the contexts are thread-safe in these callbacks. Sequence diagram about contexts and callbacks For the sake of conciseness the Caller is not depicted on the diagram. sequenceDiagram autonumber participant P as Pipeline participant H as Hedging participant AG as ActionGenerator participant OH as OnHedging participant UC as UserCallback participant HUC as HedgedUserCallback P->>H: Calls ExecuteCore <br/>with Primary Context H-->>H: Deep clones <br/>Primary Context H->>+UC: Invokes <br/>with Action Context UC-->>UC: Processes <br/>+ Modifies Context UC->>-H: Fails H-->>H: Deep clones <br/>Primary Context H->>+AG: Invokes <br/>with both Contexts AG-->>AG: Executes callback <br/>+ Modifies Primary <br/> and / or Action Context AG->>-H: Returns factory H->>+OH: Invokes <br/>with both Contexts OH-->>OH: Executes callback <br/>+ Modifies Primary <br/> and / or Action Context OH->>-H: Finishes H-->>H: Invokes factory H->>+HUC: Invokes <br/>with Action Context HUC-->>HUC: Processes <br/>+ Modifies Context HUC->>-H: Fails H-->>H: Merges Action Context <br/>onto Primary Context H->>P: Propagates failure <br/>with Primary Context Action generator The hedging options include an ActionGenerator property, allowing you to customize the actions executed during hedging. By default, the ActionGenerator returns the original callback passed to the strategy. The original callback also includes any logic introduced by subsequent resilience strategies. For more advanced scenarios, the ActionGenerator can be used to return entirely new hedged actions, as demonstrated in the example below: new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new() { ActionGenerator = args => { // You can access data from the original (primary) context here var customData = args.PrimaryContext.Properties.GetValue(customDataKey, \"default-custom-data\"); Console.WriteLine($\"Hedging, Attempt: {args.AttemptNumber}, Custom Data: {customData}\"); // Here, we can access the original callback and return it or return a completely new action var callback = args.Callback; // A function that returns a ValueTask<Outcome<HttpResponseMessage>> is required. return async () => { try { // A dedicated ActionContext is provided for each hedged action. // It comes with a separate CancellationToken created specifically for this hedged attempt, // which can be cancelled later if needed. // // Note that the \"MyRemoteCallAsync\" call won't have any additional resilience applied. // You are responsible for wrapping it with any additional resilience pipeline. var response = await MyRemoteCallAsync(args.ActionContext.CancellationToken); return Outcome.FromResult(response); } catch (Exception e) { // Note: All exceptions should be caught and converted to Outcome. return Outcome.FromException<HttpResponseMessage>(e); } }; } }); Action generator: sequence diagram sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant H as Hedging participant AG as ActionGenerator participant UC as UserCallback participant HUC as HedgedUserCallback C->>P: Calls ExecuteAsync P->>H: Calls ExecuteCore activate H H->>+UC: Invokes (R1) UC-->>UC: Processes R1 UC->>-H: Fails (R1) H->>+AG: Invokes AG->>-H: Returns factory H-->>H: Invokes factory H->>+HUC: Invokes (R2) HUC-->>HUC: Processes R2 HUC->>-H: Fails (R2) H-->>H: Invokes factory H->>+HUC: Invokes (R3) HUC-->>HUC: Processes R3 HUC->>-H: Returns result (R3) deactivate H H->>P: Returns result (R3) P->>C: Returns result (R3) Parameterized callbacks and action generator When you have control over the callbacks that the resilience pipeline receives, you can parameterize them. This flexibility allows for reusing the callbacks within an action generator. A common use case is with DelegatingHandler. Here, you can parameterize the HttpRequestMessage: internal class HedgingHandler : DelegatingHandler { private readonly ResiliencePipeline<HttpResponseMessage> _pipeline; public HedgingHandler(ResiliencePipeline<HttpResponseMessage> pipeline) { _pipeline = pipeline; } protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) { var context = ResilienceContextPool.Shared.Get(cancellationToken); // Store the incoming request in the context context.Properties.Set(ResilienceKeys.RequestMessage, request); try { return await _pipeline.ExecuteAsync(async cxt => { // Allow the pipeline to use request message that was stored in the context. // This allows replacing the request message with a new one in the resilience pipeline. request = cxt.Properties.GetValue(ResilienceKeys.RequestMessage, request); return await base.SendAsync(request, cxt.CancellationToken); }, context); } finally { ResilienceContextPool.Shared.Return(context); } } } Where ResilienceKeys is defined as: internal static class ResilienceKeys { public static readonly ResiliencePropertyKey<HttpRequestMessage> RequestMessage = new(\"MyFeature.RequestMessage\"); } In your ActionGenerator, you can easily provide your own HttpRequestMessage to ActionContext, and the original callback will use it: new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new() { ActionGenerator = args => { if (!args.PrimaryContext.Properties.TryGetValue(ResilienceKeys.RequestMessage, out var request)) { throw new InvalidOperationException(\"The request message must be provided.\"); } // Prepare a new request message for the callback, potentially involving: // // - Cloning the request message // - Providing alternate endpoint URLs request = PrepareRequest(request); // Override the request message in the action context args.ActionContext.Properties.Set(ResilienceKeys.RequestMessage, request); // Then, execute the original callback return () => args.Callback(args.ActionContext); } });"
  },
  "strategies/index.html": {
    "href": "strategies/index.html",
    "title": "Resilience strategies | Polly",
    "keywords": "Resilience strategies Resilience strategies are essential components of Polly, designed to execute user-defined callbacks while adding an extra layer of resilience. These strategies can't be executed directly; they must be run through a resilience pipeline. Polly provides an API to construct resilience pipelines by incorporating one or more resilience strategies through the pipeline builders. Polly categorizes resilience strategies into two main groups: Reactive: These strategies handle specific exceptions that are thrown, or results that are returned, by the callbacks executed through the strategy. Proactive: Unlike reactive strategies, proactive strategies do not focus on handling errors by the callbacks might throw or return. They can make proactive decisions to cancel or reject the execution of callbacks (e.g., using a rate limiter or a timeout resilience strategy). Built-in strategies Reactive Strategy Premise AKA How does the strategy mitigate? Retry Many faults are transient and may self-correct after a short delay. Maybe it's just a blip Allows configuring automatic retries. Circuit-breaker When a system is seriously struggling, failing fast is better than making users/callers wait. Protecting a faulting system from overload can help it recover. Stop doing it if it hurts Give that system a break Breaks the circuit (blocks executions) for a period, when faults exceed some pre-configured threshold. Fallback Things will still fail - plan what you will do when that happens. Degrade gracefully Defines an alternative value to be returned (or action to be executed) on failure. Hedging Things can be slow sometimes, plan what you will do when that happens. Hedge your bets Executes parallel actions when things are slow and waits for the fastest one. Proactive Strategy Premise AKA How does the strategy prevent? Timeout Beyond a certain wait, a success result is unlikely. Don't wait forever Guarantees the caller won't have to wait beyond the timeout. Rate Limiter Limiting the rate a system handles requests is another way to control load. This can apply to the way your system accepts incoming calls, and/or to the way you call downstream services. Slow down a bit, will you? Constrains executions to not exceed a certain rate. Usage Extensions for adding resilience strategies to the builders are provided by each strategy. Depending on the type of strategy, these extensions may be available for both ResiliencePipelineBuilder and ResiliencePipelineBuilder<T> or just for the latter one. Adding multiple resilience strategies is supported. Strategy ResiliencePipelineBuilder ResiliencePipelineBuilder<T> Circuit Breaker ✅ ✅ Fallback ❌ ✅ Hedging ❌ ✅ Rate Limiter ✅ ✅ Retry ✅ ✅ Timeout ✅ ✅ Each resilience strategy provides: Extensions for the resilience strategy builders. Configuration options (e.g., RetryStrategyOptions) to specify the strategy's behavior. Here's an simple example: ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddTimeout(new TimeoutStrategyOptions { Timeout = TimeSpan.FromSeconds(5) }) .Build(); Note The configuration options are automatically validated by Polly and come with sensible defaults. Therefore, you don't have to specify all the properties unless needed. Fault handling Each reactive strategy provides access to the ShouldHandle predicate property. This property offers a mechanism to decide whether the resilience strategy should manage the fault or result returned after execution. Setting up the predicate can be accomplished in the following ways: Manually setting the predicate: Directly configure the predicate. The advised approach involves using switch expressions for maximum flexibility, and also allows the incorporation of asynchronous predicates. Employing PredicateBuilder: The PredicateBuilder{<TResult>} classes provide a more straight-forward method to configure the predicates, akin to predicate setups in earlier Polly versions. The examples below illustrate these: Predicates var options = new RetryStrategyOptions<HttpResponseMessage> { // For greater flexibility, you can directly use the ShouldHandle delegate with switch expressions. ShouldHandle = args => args.Outcome switch { { Exception: HttpRequestException } => PredicateResult.True(), { Exception: TimeoutRejectedException } => PredicateResult.True(), // You can handle multiple exceptions { Result: HttpResponseMessage response } when !response.IsSuccessStatusCode => PredicateResult.True(), _ => PredicateResult.False() } }; Notes from the preceding example: Switch expressions are used to determine whether to retry or not. PredicateResult.True() is a shorthand for new ValueTask<bool>(true). ShouldHandle predicates are asynchronous and use the type Func<Args<TResult>, ValueTask<bool>>. The Args<TResult> acts as a placeholder, and each strategy defines its own arguments. Multiple exceptions can be handled using switch expressions. Note The args parameter of the ShouldHandle allows read-only access to strategy specific information. For example in case of retry you can access the AttemptNumber, as well as the Outcome and Context. Asynchronous predicates You can also use asynchronous delegates for more advanced scenarios, such as retrying based on the response body: var options = new RetryStrategyOptions<HttpResponseMessage> { ShouldHandle = async args => { if (args.Outcome.Exception is not null) { return args.Outcome.Exception switch { HttpRequestException => true, TimeoutRejectedException => true, _ => false }; } // Determine whether to retry asynchronously or not based on the result. return await ShouldRetryAsync(args.Outcome.Result!, args.Context.CancellationToken); } }; Predicate builder PredicateBuilder, or PredicateBuilder<TResult>, is a utility class aimed at simplifying the configuration of predicates: // Use PredicateBuilder<HttpResponseMessage> to simplify the setup of the ShouldHandle predicate. var options = new RetryStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .HandleResult(response => !response.IsSuccessStatusCode) // Handle results .Handle<HttpRequestException>() // Or handle exception .Handle<TimeoutRejectedException>() // Chaining is supported }; The preceding sample: Uses HandleResult to register a predicate that determines whether the result should be handled or not. Uses Handle to handle multiple exceptions types. Note When using PredicateBuilder instead of manually configuring the predicate, there is a minor performance impact. Each method call on PredicateBuilder registers a new predicate, which must be invoked when evaluating the outcome."
  },
  "strategies/rate-limiter.html": {
    "href": "strategies/rate-limiter.html",
    "title": "Rate limiter resilience strategy | Polly",
    "keywords": "Rate limiter resilience strategy About Options: RateLimiterStrategyOptions Extensions: AddRateLimiter, AddConcurrencyLimiter Strategy Type: Proactive Exceptions: RateLimiterRejectedException: Thrown when a rate limiter rejects an execution. Package: Polly.RateLimiting The rate limiter resilience strategy controls the number of operations that can pass through it. This strategy is a thin layer over the API provided by the System.Threading.RateLimiting package. Further reading: Announcing rate limiting for .NET Rate limiting API documentation Usage // Add rate limiter with default options. // See https://www.pollydocs.org/strategies/rate-limiter#defaults for defaults. new ResiliencePipelineBuilder() .AddRateLimiter(new RateLimiterStrategyOptions()); // Create a rate limiter to allow a maximum of 100 concurrent executions and a queue of 50. new ResiliencePipelineBuilder() .AddConcurrencyLimiter(100, 50); // Create a rate limiter that allows 100 executions per minute. new ResiliencePipelineBuilder() .AddRateLimiter(new SlidingWindowRateLimiter( new SlidingWindowRateLimiterOptions { PermitLimit = 100, Window = TimeSpan.FromMinutes(1) })); Example execution: var pipeline = new ResiliencePipelineBuilder().AddConcurrencyLimiter(100, 50).Build(); try { // Execute an asynchronous text search operation. var result = await pipeline.ExecuteAsync( token => TextSearchAsync(query, token), cancellationToken); } catch (RateLimiterRejectedException ex) { // Handle RateLimiterRejectedException, // that can optionally contain information about when to retry. if (ex.RetryAfter is TimeSpan retryAfter) { Console.WriteLine($\"Retry After: {retryAfter}\"); } } Failure handling It might not be obvious at the first glance what is the difference between these two techniques: var withOnRejected = new ResiliencePipelineBuilder() .AddRateLimiter(new RateLimiterStrategyOptions { DefaultRateLimiterOptions = new ConcurrencyLimiterOptions { PermitLimit = 10 }, OnRejected = args => { Console.WriteLine(\"Rate limit has been exceeded\"); return default; } }).Build(); var withoutOnRejected = new ResiliencePipelineBuilder() .AddRateLimiter(new RateLimiterStrategyOptions { DefaultRateLimiterOptions = new ConcurrencyLimiterOptions { PermitLimit = 10 } }).Build(); try { await withoutOnRejected.ExecuteAsync(async ct => await TextSearchAsync(query, ct), CancellationToken.None); } catch (RateLimiterRejectedException) { Console.WriteLine(\"Rate limit has been exceeded\"); } The OnRejected user-provided delegate is called just before the strategy throws the RateLimiterRejectedException. This delegate receives a parameter which allows you to access the Context object as well as the Lease: Accessing the Context is also possible via a different Execute{Async} overload. Accessing the rejected Lease can be useful in certain scenarios. So, what is the purpose of the OnRejected? The OnRejected delegate can be useful when you define a resilience pipeline which consists of multiple strategies. For example, you have a rate limiter as the inner strategy and a retry as the outer strategy. If the retry is defined to handle RateLimiterRejectedException, that means the Execute{Async} may or may not throw that exception depending on future attempts. So, if you want to get notification about the fact that the rate limit has been exceeded, you have to provide a delegate to the OnRejected property. Defaults Property Default Value Description RateLimiter null Generator that creates a RateLimitLease for executions. DefaultRateLimiterOptions PermitLimit set to 1000 and QueueLimit set to 0. The options for the default concurrency limiter that will be used when RateLimiter is null. OnRejected null Event that is raised when the execution is rejected by the rate limiter. Diagrams Rate Limiter Let's suppose we have a rate limiter strategy with PermitLimit : 1 and Window : 10 seconds. Rate Limiter: happy path sequence diagram sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant RL as RateLimiter participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>RL: Calls ExecuteCore Note over RL,D: Window start RL->>+D: Invokes D->>-RL: Returns result RL->>P: Returns result P->>C: Returns result Note over C: Several seconds later... Note over RL,D: Window end C->>P: Calls ExecuteAsync P->>RL: Calls ExecuteCore Note over RL,D: Window start RL->>+D: Invokes D->>-RL: Returns result RL->>P: Returns result P->>C: Returns result Note over RL,D: Window end Rate limiter: unhappy path sequence diagram sequenceDiagram autonumber actor C as Caller participant P as Pipeline participant RL as RateLimiter participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>RL: Calls ExecuteCore Note over RL,D: Window start RL->>+D: Invokes D->>-RL: Returns result RL->>P: Returns result P->>C: Returns result Note over C: Few seconds later... C->>P: Calls ExecuteAsync P->>RL: Calls ExecuteCore RL-->>RL: Rejects request RL->>P: Throws <br/>RateLimiterRejectedException P->>C: Propagates exception Note over RL,D: Window end Concurrency Limiter Let's suppose we have a concurrency limiter strategy with PermitLimit : 1 and QueueLimit : 1. Concurrency limiter: happy path sequence diagram sequenceDiagram actor C1 as Caller1 actor C2 as Caller2 participant P as Pipeline participant CL as ConcurrencyLimiter participant D as DecoratedUserCallback par C1->>P: Calls ExecuteAsync and C2->>P: Calls ExecuteAsync end P->>CL: Calls ExecuteCore CL->>+D: Invokes (C1) P->>CL: Calls ExecuteCore CL-->>CL: Queues request D->>-CL: Returns result (C1) CL->>P: Returns result (C1) CL->>+D: Invokes (C2) P->>C1: Returns result D->>-CL: Returns result (C2) CL->>P: Returns result (C2) P->>C2: Returns result Concurrency Limiter: unhappy path sequence diagram sequenceDiagram actor C1 as Caller1 actor C2 as Caller2 actor C3 as Caller3 participant P as Pipeline participant CL as ConcurrencyLimiter participant D as DecoratedUserCallback par C1->>P: Calls ExecuteAsync and C2->>P: Calls ExecuteAsync and C3->>P: Calls ExecuteAsync end P->>CL: Calls ExecuteCore CL->>+D: Invokes (C1) P->>CL: Calls ExecuteCore CL-->>CL: Queues request (C2) P->>CL: Calls ExecuteCore CL-->>CL: Rejects request (C3) CL->>P: Throws <br/>RateLimiterRejectedException P->>C3: Propagates exception D->>-CL: Returns result (C1) CL->>P: Returns result (C1) CL->>+D: Invokes (C2) P->>C1: Returns result D->>-CL: Returns result (C2) CL->>P: Returns result (C2) P->>C2: Returns result Disposal of rate limiters The RateLimiter is a disposable resource. When you explicitly create a RateLimiter instance, it's good practice to dispose of it once it's no longer needed. This is usually not an issue when manually creating resilience pipelines using the ResiliencePipelineBuilder. However, when dynamic reloads are enabled, failing to dispose of discarded rate limiters can lead to excessive resource consumption. Fortunately, Polly provides a way to dispose of discarded rate limiters, as demonstrated in the example below: services .AddResiliencePipeline(\"my-pipeline\", (builder, context) => { var options = context.GetOptions<ConcurrencyLimiterOptions>(\"my-concurrency-options\"); // This call enables dynamic reloading of the pipeline // when the named ConcurrencyLimiterOptions change. context.EnableReloads<ConcurrencyLimiterOptions>(\"my-concurrency-options\"); var limiter = new ConcurrencyLimiter(options); builder.AddRateLimiter(limiter); // Dispose of the limiter when the pipeline is disposed. context.OnPipelineDisposed(() => limiter.Dispose()); }); The above example uses the AddResiliencePipeline(...) extension method to configure the pipeline. However, a similar approach can be taken when directly using the ResiliencePipelineRegistry<T>. Partitioned rate limiter For advanced use-cases, the partitioned rate limiter is also available. The following example illustrates how to retrieve a partition key from ResilienceContext using the GetPartitionKey method: var partitionedLimiter = PartitionedRateLimiter.Create<ResilienceContext, string>(context => { // Extract the partition key. string partitionKey = GetPartitionKey(context); return RateLimitPartition.GetConcurrencyLimiter( partitionKey, key => new ConcurrencyLimiterOptions { PermitLimit = 100 }); }); new ResiliencePipelineBuilder() .AddRateLimiter(new RateLimiterStrategyOptions { // Provide a custom rate limiter delegate. RateLimiter = args => { return partitionedLimiter.AcquireAsync(args.Context, 1, args.Context.CancellationToken); } });"
  },
  "strategies/retry.html": {
    "href": "strategies/retry.html",
    "title": "Retry resilience strategy | Polly",
    "keywords": "Retry resilience strategy About Options: RetryStrategyOptions RetryStrategyOptions<T> Extensions: AddRetry Strategy Type: Reactive Usage // Retry using the default options. // See https://www.pollydocs.org/strategies/retry#defaults for defaults. var optionsDefaults = new RetryStrategyOptions(); // For instant retries with no delay var optionsNoDelay = new RetryStrategyOptions { Delay = TimeSpan.Zero }; // For advanced control over the retry behavior, including the number of attempts, // delay between retries, and the types of exceptions to handle. var optionsComplex = new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), BackoffType = DelayBackoffType.Exponential, UseJitter = true, // Adds a random factor to the delay MaxRetryAttempts = 4, Delay = TimeSpan.FromSeconds(3), }; // To use a custom function to generate the delay for retries var optionsDelayGenerator = new RetryStrategyOptions { MaxRetryAttempts = 2, DelayGenerator = static args => { var delay = args.AttemptNumber switch { 0 => TimeSpan.Zero, 1 => TimeSpan.FromSeconds(1), _ => TimeSpan.FromSeconds(5) }; // This example uses a synchronous delay generator, // but the API also supports asynchronous implementations. return new ValueTask<TimeSpan?>(delay); } }; // To extract the delay from the result object var optionsExtractDelay = new RetryStrategyOptions<HttpResponseMessage> { DelayGenerator = static args => { if (args.Outcome.Result is HttpResponseMessage responseMessage && TryGetDelay(responseMessage, out TimeSpan delay)) { return new ValueTask<TimeSpan?>(delay); } // Returning null means the retry strategy will use its internal delay for this attempt. return new ValueTask<TimeSpan?>((TimeSpan?)null); } }; // To get notifications when a retry is performed var optionsOnRetry = new RetryStrategyOptions { MaxRetryAttempts = 2, OnRetry = static args => { Console.WriteLine(\"OnRetry, Attempt: {0}\", args.AttemptNumber); // Event handlers can be asynchronous; here, we return an empty ValueTask. return default; } }; // To keep retrying indefinitely or until success use int.MaxValue. var optionsIndefiniteRetry = new RetryStrategyOptions { MaxRetryAttempts = int.MaxValue, }; // Add a retry strategy with a RetryStrategyOptions{<TResult>} instance to the pipeline new ResiliencePipelineBuilder().AddRetry(optionsDefaults); new ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(optionsExtractDelay); Defaults Property Default Value Description ShouldHandle Predicate that handles all exceptions except OperationCanceledException. Predicate that determines what results and exceptions are handled by the retry strategy. MaxRetryAttempts 3 The maximum number of retries to use, in addition to the original call. Delay 2 seconds The base delay between retries. BackoffType Constant The type of the back-off used to generate the retry delay. UseJitter False Allows adding jitter to retry delays. DelayGenerator null Used for generating custom delays for retries. OnRetry null Action executed when retry occurs. MaxDelay null Caps the calculated retry delay to a specified maximum duration. Calculation of the next delay If the ShouldHandle predicate returns true and the next attempt number is not greater than MaxRetryAttempts then the retry strategy calculates the next delay. There are many properties that may contribute to this calculation: BackoffType: Specifies which calculation algorithm should run. Delay: If only this property is specified then it will be used as-is. If others are also specified then this will be used as a base delay. DelayGenerator: If specified, overrides other property-based calculations, except if it returns null or a negative TimeSpan, in which case the other property-based calculations are used. MaxDelay: If specified, caps the delay if the calculated delay is greater than this value, except if DelayGenerator is used, where no capping is applied. UseJitter: If enabled, adds a random value between -25% and +25% of the calculated Delay, except if BackoffType is Exponential, where a DecorrelatedJitterBackoffV2 formula is used for jitter calculation. That formula is based on Polly.Contrib.WaitAndRetry. Important The summarized description below is an implementation detail. It may change in the future without notice. The BackoffType property's data type is the DelayBackoffType enumeration. This primarily controls how the calculation is done. Constant stateDiagram-v2 state if_state_step1 <<choice>> state if_state_step2 <<choice>> state if_state_step3 <<choice>> constant: Delay constantWJitter: Delay + Random compare: MaxDelay < BaseDelay setBase: Set BaseDelay setNormalized: Set NormalizedDelay setNext: Set NextDelay UseJitter --> if_state_step1 if_state_step1 --> constantWJitter:true if_state_step1 --> constant: false constantWJitter --> setBase constant --> setBase setBase --> compare compare --> if_state_step2 if_state_step2 --> MaxDelay: true if_state_step2 --> BaseDelay: false MaxDelay --> setNormalized BaseDelay --> setNormalized setNormalized --> DelayGenerator DelayGenerator --> if_state_step3 if_state_step3 --> GeneratedDelay: positive if_state_step3 --> NormalizedDelay: null or negative GeneratedDelay --> setNext NormalizedDelay --> setNext setNext --> [*] Constant examples The delays column contains an example series of five values to depict the patterns. Settings Delays in milliseconds Delay: 1sec [ 1000, 1000, 1000, 1000, 1000 ] Delay: 1sec, UseJitter: true [ 986, 912, 842, 972, 1007 ] Delay: 1sec, UseJitter: true, MaxDelay: 1100ms [ 1100, 978, 1100, 1041, 916 ] Linear stateDiagram-v2 state if_state_step1 <<choice>> state if_state_step2 <<choice>> state if_state_step3 <<choice>> linear: Delay * AttemptNumber linearWJitter: (Delay * AttemptNumber) + Random compare: MaxDelay < BaseDelay setBase: Set BaseDelay setNormalized: Set NormalizedDelay setNext: Set NextDelay UseJitter --> if_state_step1 if_state_step1 --> linearWJitter:true if_state_step1 --> linear: false linearWJitter --> setBase linear --> setBase setBase --> compare compare --> if_state_step2 if_state_step2 --> MaxDelay: true if_state_step2 --> BaseDelay: false MaxDelay --> setNormalized BaseDelay --> setNormalized setNormalized --> DelayGenerator DelayGenerator --> if_state_step3 if_state_step3 --> GeneratedDelay: positive if_state_step3 --> NormalizedDelay: null or negative GeneratedDelay --> setNext NormalizedDelay --> setNext setNext --> [*] Linear examples The delays column contains an example series of five values to depict the patterns. Note Because the jitter calculation is based on the newly calculated delay, the new delay could be less than the previous value. Settings Delays in milliseconds Delay: 1sec [ 1000, 2000, 3000, 4000, 5000 ] Delay: 1sec, UseJitter: true [ 1129, 2147, 2334, 4894, 4102 ] Delay: 1sec, UseJitter: true, MaxDelay: 4500ms [ 907, 2199, 2869, 4500, 4500 ] Exponential stateDiagram-v2 state if_state_step1 <<choice>> state if_state_step2 <<choice>> state if_state_step3 <<choice>> exponential: Delay * 2^AttemptNumber exponentialWJitter: Decorrelated Jitter Backoff V2 compare: MaxDelay < BaseDelay setBase: Set BaseDelay setNormalized: Set NormalizedDelay setNext: Set NextDelay UseJitter --> if_state_step1 if_state_step1 --> exponentialWJitter:true if_state_step1 --> exponential: false exponentialWJitter --> setBase exponential --> setBase setBase --> compare compare --> if_state_step2 if_state_step2 --> MaxDelay: true if_state_step2 --> BaseDelay: false MaxDelay --> setNormalized BaseDelay --> setNormalized setNormalized --> DelayGenerator DelayGenerator --> if_state_step3 if_state_step3 --> GeneratedDelay: positive if_state_step3 --> NormalizedDelay: null or negative GeneratedDelay --> setNext NormalizedDelay --> setNext setNext --> [*] Exponential examples The delays column contains an example series of five values to depict the patterns. Note Because the jitter calculation is based on the newly calculated delay, the new delay could be less than the previous value. Settings Delays in milliseconds Delay: 1sec [ 1000, 2000, 4000, 8000, 16000 ] Delay: 1sec, UseJitter: true [ 393, 1453, 4235, 5369, 16849 ] Delay: 1sec, UseJitter: true, MaxDelay: 15000ms [ 477, 793, 2227, 5651, 15000 ] Tip For more details please check out the RetryHelper and the RetryResilienceStrategy classes. Diagrams Let's suppose we have a retry strategy with MaxRetryAttempts: 2. Happy path sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant R as Retry participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>R: Calls ExecuteCore Note over R,D: Initial attempt R->>+D: Invokes D->>-R: Fails R-->>R: Sleeps Note over R,D: 1st retry attempt R->>+D: Invokes D->>-R: Returns result R->>P: Returns result P->>C: Returns result Unhappy path sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant R as Retry participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>R: Calls ExecuteCore Note over R,D: Initial attempt R->>+D: Invokes D->>-R: Fails R-->>R: Sleeps Note over R,D: 1st retry attempt R->>+D: Invokes D->>-R: Fails R-->>R: Sleeps Note over R,D: 2nd retry attempt R->>+D: Invokes D->>-R: Fails R->>P: Propagates failure P->>C: Propagates failure Patterns Limiting the maximum delay In some cases, you might want to set a limit on the calculated delay. This is beneficial when multiple retries are anticipated, and you wish to prevent excessive wait times between these retries. Consider the following example of a long-running background job: ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new() { Delay = TimeSpan.FromSeconds(2), MaxRetryAttempts = int.MaxValue, BackoffType = DelayBackoffType.Exponential, // Initially, we aim for an exponential backoff, but after a certain number of retries, we set a maximum delay of 15 minutes. MaxDelay = TimeSpan.FromMinutes(15), UseJitter = true }) .Build(); // Background processing while (!cancellationToken.IsCancellationRequested) { await pipeline.ExecuteAsync(async token => { // In the event of a prolonged service outage, we can afford to wait for a successful retry since this is a background task. await SynchronizeDataAsync(token); }, cancellationToken); await Task.Delay(TimeSpan.FromMinutes(30)); // The sync runs every 30 minutes. } Anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. The sections below highlight anti-patterns to avoid. Overusing builder methods ❌ DON'T Overuse Handle/HandleResult: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<HttpRequestException>() .Handle<BrokenCircuitException>() .Handle<TimeoutRejectedException>() .Handle<SocketException>() .Handle<RateLimitRejectedException>(), MaxRetryAttempts = 3, }) .Build(); Reasoning: Using multiple Handle/HandleResult methods is redundant. Instead of specifying to retry if the decorated code throws a certain exception repeatedly, it's more efficient to state that retries should occur if any of the retryable exceptions are thrown. ✅ DO Use collections and simple predicate functions: ImmutableArray<Type> networkExceptions = new[] { typeof(SocketException), typeof(HttpRequestException), }.ToImmutableArray(); ImmutableArray<Type> strategyExceptions = new[] { typeof(TimeoutRejectedException), typeof(BrokenCircuitException), typeof(RateLimitRejectedException), }.ToImmutableArray(); ImmutableArray<Type> retryableExceptions = networkExceptions .Union(strategyExceptions) .ToImmutableArray(); var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = ex => new ValueTask<bool>(retryableExceptions.Contains(ex.GetType())), MaxRetryAttempts = 3, }) .Build(); Reasoning: Grouping exceptions simplifies the configuration and improves reusability. For example, the networkExceptions array can be reused in various strategies such as retry, circuit breaker, and more. Using retry for periodic execution ❌ DON'T Use a retry strategy to run indefinitely at a specified interval: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = _ => ValueTask.FromResult(true), Delay = TimeSpan.FromHours(24), }) .Build(); Reasoning: The waiting period can be either blocking or non-blocking, based on the defined strategy/pipeline. Even when used not used in a blocking manner, it unnecessarily consumes memory that can't be reclaimed by the garbage collector. ✅ DO Use a suitable tool to schedule recurring tasks, such as Quartz.Net, Hangfire, or others. Reasoning: Polly was not designed to support this scenario; its primary purpose is to help manage brief transient failures. Specialized job scheduling tools are more memory-efficient and can be set up to withstand machine failures by using persistent storage. Combining multiple sleep duration strategies ❌ DON'T Mix increasing values with constant ones: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { DelayGenerator = args => { var delay = args.AttemptNumber switch { <= 5 => TimeSpan.FromSeconds(Math.Pow(2, args.AttemptNumber)), _ => TimeSpan.FromMinutes(3) }; return new ValueTask<TimeSpan?>(delay); } }) .Build(); Reasoning: Using this approach essentially turns the logic into a state machine. Although this offers a concise way to express sleep durations, it has several disadvantages: It doesn't support reusability (for instance, you can't use only the quick retries). The sleep duration logic is closely tied to the AttemptNumber. Testing becomes more challenging. ✅ DO Use two distinct retry strategy options and combine them: var slowRetries = new RetryStrategyOptions { MaxRetryAttempts = 5, Delay = TimeSpan.FromMinutes(3), BackoffType = DelayBackoffType.Constant }; var quickRetries = new RetryStrategyOptions { MaxRetryAttempts = 5, Delay = TimeSpan.FromSeconds(1), UseJitter = true, BackoffType = DelayBackoffType.Exponential }; var retry = new ResiliencePipelineBuilder() .AddRetry(slowRetries) .AddRetry(quickRetries) .Build(); Reasoning: While this method may appear more verbose than the first, it offers greater flexibility. Retry strategies can be arranged in any order (either slower first and then quicker, or the other way around). Different triggers can be defined for the retry strategies, allowing for switches between them based on exceptions or results. The order isn't fixed, so quick and slow retries can alternate. Branching retry logic based on request URL Suppose you have an HttpClient and you want to add a retry only for specific endpoints. ❌ DON'T Use ResiliencePipeline.Empty and the ?: operator: var retry = IsRetryable(request.RequestUri) ? new ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new()).Build() : ResiliencePipeline<HttpResponseMessage>.Empty; Reasoning: The triggering conditions and logic are spread across different sections. This design is not ideal for extensibility since adding more conditions can make the code less readable. ✅ DO Use the ShouldHandle clause to define the triggering logic: var retry = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRetry(new() { ShouldHandle = _ => ValueTask.FromResult(IsRetryable(request.RequestUri)) }) .Build(); Reasoning: The conditions for triggering are consolidated in a familiar and easily accessible location. You don't need to specify actions for scenarios when the strategy shouldn't be triggered. Calling a method before/after each retry attempt ❌ DON'T Call a specific method before Execute/ExecuteAsync: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { OnRetry = args => { BeforeEachAttempt(); return ValueTask.CompletedTask; }, }) .Build(); BeforeEachAttempt(); await retry.ExecuteAsync(DoSomething); Reasoning: The OnRetry function is triggered before each retry attempt, but it doesn't activate before the initial attempt since it's not considered a retry. Using this method across various parts can lead to accidentally omitting the BeforeEachAttempt call before every Execute. Even though the naming here is straightforward, in real-world scenarios, your method might not start with 'Before', leading to potential misuse by calling it after the Execute. ✅ DO Group the two method calls: var retry = new ResiliencePipelineBuilder() .AddRetry(new()) .Build(); await retry.ExecuteAsync(ct => { BeforeEachAttempt(); return DoSomething(ct); }); Reasoning: If DoSomething and BeforeEachAttempt are interdependent, group them or declare a simple wrapper to invoke them in the correct sequence. Having a single strategy for multiple failures Suppose we have an HttpClient that issues a request and then we try to parse a large JSON response. ❌ DON'T Use a single strategy for everything: var builder = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), MaxRetryAttempts = 3 }); builder.AddTimeout(TimeSpan.FromMinutes(1)); var pipeline = builder.Build(); await pipeline.ExecuteAsync(static async (httpClient, ct) => { var stream = await httpClient.GetStreamAsync(new Uri(\"endpoint\"), ct); var foo = await JsonSerializer.DeserializeAsync<Foo>(stream, cancellationToken: ct); }, httpClient); Reasoning: Previously, it was suggested that you should combine X and Y only if they are part of the same failure domain. In simpler terms, a pipeline should address only one type of failure. ✅ DO Define a strategy for each failure domain: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), MaxRetryAttempts = 3 }) .Build(); var stream = await retry.ExecuteAsync( static async (httpClient, ct) => await httpClient.GetStreamAsync(new Uri(\"endpoint\"), ct), httpClient); var timeout = new ResiliencePipelineBuilder<Foo>() .AddTimeout(TimeSpan.FromMinutes(1)) .Build(); var foo = await timeout.ExecuteAsync((ct) => JsonSerializer.DeserializeAsync<Foo>(stream, cancellationToken: ct)); Reasoning: The failure domain of a network call is different from that of deserialization. Using dedicated strategies makes the application more resilient to various transient failures. Cancelling retry for specific exceptions If you encounter a TimeoutException, you may not want to retry the operation. ❌ DON'T Embed cancellation logic within OnRetry: var ctsKey = new ResiliencePropertyKey<CancellationTokenSource>(\"cts\"); var retry = new ResiliencePipelineBuilder() .AddRetry(new() { OnRetry = async args => { if (args.Outcome.Exception is TimeoutException) { if (args.Context.Properties.TryGetValue(ctsKey, out var cts)) { await cts.CancelAsync(); } } } }) .Build(); Reasoning: Conditions for triggering retries should be located in ShouldHandle. Bypassing the strategy from within a user-defined delegate—either through an Exception or a CancellationToken—unnecessarily complicates the control flow. ✅ DO Set the condition for retry within ShouldHandle: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = args => ValueTask.FromResult(args.Outcome.Exception is not TimeoutException) }) .Build(); Reasoning: As previously mentioned, always use the designated area to define retry conditions. Re-frame your original exit conditions to specify when a retry should be initiated."
  },
  "strategies/timeout.html": {
    "href": "strategies/timeout.html",
    "title": "Timeout resilience strategy | Polly",
    "keywords": "Timeout resilience strategy About Options: TimeoutStrategyOptions Extensions: AddTimeout Strategy Type: Proactive Exceptions: TimeoutRejectedException: Thrown when a delegate executed through a timeout strategy does not complete before the timeout. The timeout resilience strategy cancels the execution if it does not complete within the specified timeout period. If the execution is canceled by the timeout strategy, it throws a TimeoutRejectedException. The timeout strategy operates by wrapping the incoming cancellation token with a new one. Should the original token be canceled, the timeout strategy will transparently honor the original cancellation token without throwing a TimeoutRejectedException. Important It is crucial that the user's callback respects the cancellation token. If it does not, the callback will continue executing even after a cancellation request, thereby ignoring the cancellation. Usage // To add a timeout with a custom TimeSpan duration new ResiliencePipelineBuilder().AddTimeout(TimeSpan.FromSeconds(3)); // Timeout using the default options. // See https://www.pollydocs.org/strategies/timeout#defaults for defaults. var optionsDefaults = new TimeoutStrategyOptions(); // To add a timeout using a custom timeout generator function var optionsTimeoutGenerator = new TimeoutStrategyOptions { TimeoutGenerator = static args => { // Note: the timeout generator supports asynchronous operations return new ValueTask<TimeSpan>(TimeSpan.FromSeconds(123)); } }; // To add a timeout and listen for timeout events var optionsOnTimeout = new TimeoutStrategyOptions { TimeoutGenerator = static args => { // Note: the timeout generator supports asynchronous operations return new ValueTask<TimeSpan>(TimeSpan.FromSeconds(123)); }, OnTimeout = static args => { Console.WriteLine($\"{args.Context.OperationKey}: Execution timed out after {args.Timeout.TotalSeconds} seconds.\"); return default; } }; // Add a timeout strategy with a TimeoutStrategyOptions instance to the pipeline new ResiliencePipelineBuilder().AddTimeout(optionsDefaults); Example execution: var pipeline = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(3)) .Build(); HttpResponseMessage httpResponse = await pipeline.ExecuteAsync( async ct => { // Execute a delegate that takes a CancellationToken as an input parameter. return await httpClient.GetAsync(endpoint, ct); }, cancellationToken); Failure handling It might not be obvious at the first glance what is the difference between these two techniques: var withOnTimeout = new ResiliencePipelineBuilder() .AddTimeout(new TimeoutStrategyOptions { Timeout = TimeSpan.FromSeconds(2), OnTimeout = args => { Console.WriteLine(\"Timeout limit has been exceeded\"); return default; } }).Build(); var withoutOnTimeout = new ResiliencePipelineBuilder() .AddTimeout(new TimeoutStrategyOptions { Timeout = TimeSpan.FromSeconds(2) }).Build(); try { await withoutOnTimeout.ExecuteAsync(UserDelegate, CancellationToken.None); } catch (TimeoutRejectedException) { Console.WriteLine(\"Timeout limit has been exceeded\"); } The OnTimeout user-provided delegate is called just before the strategy throws the TimeoutRejectedException. This delegate receives a parameter which allows you to access the Context object as well as the Timeout: Accessing the Context is also possible via a different Execute{Async} overload. Accessing the Timeout can be useful if you are using the TimeoutGenerator property rather than the Timeout property. So, what is the purpose of the OnTimeout in case of static timeout settings? The OnTimeout delegate can be useful when you define a resilience pipeline which consists of multiple strategies. For example you have a timeout as the inner strategy and a retry as the outer strategy. If the retry is defined to handle TimeoutRejectedException, that means the Execute{Async} may or may not throw that exception depending on future attempts. So, if you want to get notification about the fact that a timeout has occurred, you have to provide a delegate to the OnTimeout property. Defaults Property Default Value Description Timeout 30 seconds The default timeout used by the strategy. TimeoutGenerator null Generates the timeout for a given execution. OnTimeout null Event that is raised when timeout occurs. Note If both Timeout and TimeoutGenerator are specified then Timeout will be ignored. Diagrams Happy path sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant T as Timeout participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>T: Calls ExecuteCore T->>+D: Invokes D-->>D: Performs <br/>long-running <br/>operation D->>-T: Returns result T->>P: Returns result P->>C: Returns result Unhappy path sequence diagram sequenceDiagram actor C as Caller participant P as Pipeline participant T as Timeout participant D as DecoratedUserCallback C->>P: Calls ExecuteAsync P->>T: Calls ExecuteCore T->>+D: Invokes activate T activate D D-->>D: Performs <br/>long-running <br/>operation T-->>T: Times out deactivate T T->>D: Propagates cancellation D-->>D: Cancellation of callback D->>T: Cancellation finished deactivate D T->>P: Throws <br/>TimeoutRejectedException P->>C: Propagates exception Important Notice that the timeout waits until the callback is cancelled before throwing TimeoutRejectedException. Therefore it's important for the callbacks to respect the cancellation token passed to the execution. If the cancellation token is not correctly respected, the timeout is unnecessarily delayed. Anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. The sections below highlight anti-patterns to avoid. Ignoring Cancellation Token ❌ DON'T Ignore the cancellation token provided by the resilience pipeline: var pipeline = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(1)) .Build(); await pipeline.ExecuteAsync( async innerToken => await Task.Delay(TimeSpan.FromSeconds(3), outerToken), // The delay call should use innerToken outerToken); Reasoning: The provided callback ignores the innerToken passed from the pipeline and instead uses the outerToken. For this reason, the cancelled innerToken is ignored, and the callback is not cancelled within 1 second. ✅ DO Respect the cancellation token provided by the pipeline: var pipeline = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(1)) .Build(); await pipeline.ExecuteAsync( static async innerToken => await Task.Delay(TimeSpan.FromSeconds(3), innerToken), outerToken); Reasoning: The provided callback respects the innerToken provided by the pipeline, and as a result, the callback is correctly cancelled by the timeout strategy after 1 second plus TimeoutRejectedException is thrown."
  },
  "v7/extensibility.html": {
    "href": "v7/extensibility.html",
    "title": "Custom policies | Polly",
    "keywords": "Custom policies From Polly v7.0 it is possible to create your own custom policies outside Polly. These custom policies can integrate in to all the existing goodness from Polly: the Policy.Handle<>() syntax; PolicyWrap; all the execution-dispatch overloads. For more info see our blog series: Part I: Introducing custom Polly policies and the Polly.Contrib Part II: Authoring a non-reactive custom policy (a policy which acts on all executions) Part III: Authoring a reactive custom policy (a policy which react to faults). Part IV: Custom policies for all execution types: sync and async, generic and non-generic. We provide a starter template for a custom policy for developing your own custom policy."
  }
}