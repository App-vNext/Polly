{
  "advanced/dependency-injection.html": {
    "href": "advanced/dependency-injection.html",
    "title": "Dependency injection | Polly",
    "keywords": "Dependency injection Starting with version 8, Polly provides features that make the integration of Polly with the .NET IServiceCollection Dependency Injection (DI) container more streamlined. This is a thin layer atop the resilience pipeline registry which manages resilience pipelines. Usage To use the DI functionality, add the Polly.Extensions package to your project: dotnet add package Polly.Extensions Afterwards, you can use the AddResiliencePipeline(...) extension method to set up your pipeline: var services = new ServiceCollection(); // Define a resilience pipeline services.AddResiliencePipeline(\"my-key\", builder => { // Add strategies to your pipeline here, timeout for example builder.AddTimeout(TimeSpan.FromSeconds(10)); }); // You can also access IServiceProvider by using the alternate overload services.AddResiliencePipeline(\"my-key\", (builder, context) => { // Resolve any service from DI var loggerFactory = context.ServiceProvider.GetRequiredService<ILoggerFactory>(); // Add strategies to your pipeline here builder.AddTimeout(TimeSpan.FromSeconds(10)); }); // Resolve the resilience pipeline ServiceProvider serviceProvider = services.BuildServiceProvider(); ResiliencePipelineProvider<string> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>(); ResiliencePipeline pipeline = pipelineProvider.GetPipeline(\"my-key\"); // Use it await pipeline.ExecuteAsync( static async cancellation => await Task.Delay(100, cancellation)); The AddResiliencePipeline extension method also registers the following services into the DI container: ResiliencePipelineRegistry<string>: Allows adding and retrieving resilience pipelines. ResiliencePipelineProvider<string>: Allows retrieving resilience pipelines. IOptions<ResiliencePipelineRegistryOptions<string>>: Options for ResiliencePipelineRegistry<string>. Note The generic `string`` is inferred since the pipeline was defined using the \"my-key\" value. If you only need the registry without defining a pipeline, use the AddResiliencePipelineRegistry(...) method. Generic resilience pipelines You can also define generic resilience pipelines (ResiliencePipeline<T>), as demonstrated below: var services = new ServiceCollection(); // Define a generic resilience pipeline // First parameter is the type of key, second one is the type of the results the generic pipeline works with services.AddResiliencePipeline<string, HttpResponseMessage>(\"my-pipeline\", builder => { builder.AddRetry(new() { MaxRetryAttempts = 2, ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<HttpRequestException>() .Handle<TimeoutRejectedException>() .HandleResult(response => response.StatusCode == System.Net.HttpStatusCode.InternalServerError) }) .AddTimeout(TimeSpan.FromSeconds(2)); }); // Resolve the resilience pipeline ServiceProvider serviceProvider = services.BuildServiceProvider(); ResiliencePipelineProvider<string> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>(); ResiliencePipeline<HttpResponseMessage> pipeline = pipelineProvider.GetPipeline<HttpResponseMessage>(\"my-key\"); // Use it await pipeline.ExecuteAsync( async cancellation => await client.GetAsync(endpoint, cancellation), cancellationToken); Dynamic reloads Dynamic reloading is a feature of the pipeline registry that is also surfaced when using the AddResiliencePipeline(...) extension method. Use an overload that provides access to AddResiliencePipelineContext: services .Configure<RetryStrategyOptions>(\"my-retry-options\", configurationSection) // Configure the options .AddResiliencePipeline(\"my-pipeline\", (builder, context) => { // Enable the reloads whenever the named options change context.EnableReloads<RetryStrategyOptions>(\"my-retry-options\"); // Utility method to retrieve the named options var retryOptions = context.GetOptions<RetryStrategyOptions>(\"my-retry-options\"); // Add retries using the resolved options builder.AddRetry(retryOptions); }); EnableReloads<T>(...) activates the dynamic reloading of my-pipeline. RetryStrategyOptions are fetched using context.GetOptions(...) utility method. A retry strategy is added. During a reload: The callback re-executes. The previous pipeline is discarded. If an error occurs during reloading, the old pipeline remains, and dynamic reloading stops. Resource disposal Like dynamic reloading, the pipeline registry's resource disposal feature lets you register callbacks. These callbacks run when the pipeline is discarded, reloaded, or the registry is disposed at application shutdown. See the example below: services.AddResiliencePipeline(\"my-pipeline\", (builder, context) => { // Create disposable resource var limiter = new ConcurrencyLimiter(new ConcurrencyLimiterOptions { PermitLimit = 100, QueueLimit = 100 }); // Use it builder.AddRateLimiter(limiter); // Dispose the resource created in the callback when the pipeline is discarded context.OnPipelineDisposed(() => limiter.Dispose()); }); This feature ensures that resources are properly disposed when a pipeline reloads, discarding the old version. Complex pipeline keys The AddResiliencePipeline(...) method supports complex pipeline keys. This capability allows you to define the structure of your pipeline and dynamically resolve and cache multiple instances of the pipeline with different keys. Start by defining your complex key: public record struct MyPipelineKey(string PipelineName, string InstanceName) { } Next, register your pipeline: services.AddResiliencePipeline(new MyPipelineKey(\"my-pipeline\", string.Empty), builder => { // Circuit breaker is a stateful strategy. To isolate the builder across different pipelines, // we must use multiple instances. builder.AddCircuitBreaker(new CircuitBreakerStrategyOptions()); }); The \"my-pipeline\" pipeline is now registered. Note that the InstanceName is an empty string. While we're registering the builder action for a specific pipeline, the InstanceName parameter isn't used during the pipeline's registration. Some further modifications are required for this to function. Introduce the PipelineNameComparer: public sealed class PipelineNameComparer : IEqualityComparer<MyPipelineKey> { public bool Equals(MyPipelineKey x, MyPipelineKey y) => x.PipelineName == y.PipelineName; public int GetHashCode(MyPipelineKey obj) => (obj.PipelineName, obj.InstanceName).GetHashCode(); } Then, configure the registry behavior: services .AddResiliencePipelineRegistry<MyPipelineKey>(options => { options.BuilderComparer = new PipelineNameComparer(); options.InstanceNameFormatter = key => key.InstanceName; options.BuilderNameFormatter = key => key.PipelineName; }); Let's summarize our actions: We assigned the PipelineNameComparer instance to the BuilderComparer property. This action changes the default registry behavior, ensuring that only the PipelineName is used to find the associated builder. We used the InstanceNameFormatter delegate to represent the MyPipelineKey as an instance name for telemetry purposes, keeping the instance name as it is. Likewise, the BuilderNameFormatter delegate represents the MyPipelineKey as a builder name in telemetry. Finally, use the ResiliencePipelineProvider<MyPipelineKey> to dynamically create and cache multiple instances of the same pipeline: ResiliencePipelineProvider<MyPipelineKey> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<MyPipelineKey>>(); // The registry dynamically creates and caches instance-A using the associated builder action ResiliencePipeline instanceA = pipelineProvider.GetPipeline(new MyPipelineKey(\"my-pipeline\", \"instance-A\")); // The registry creates and caches instance-B ResiliencePipeline instanceB = pipelineProvider.GetPipeline(new MyPipelineKey(\"my-pipeline\", \"instance-B\")); Patterns and anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. This section highlights the recommended practices and those to avoid. 1 - Accessing the IServiceCollection instead of IServiceProvider ❌ DON'T Capture IServiceCollection inside AddResiliencePipeline(): var services = new ServiceCollection(); services.AddResiliencePipeline(\"myFavoriteStrategy\", builder => { builder.AddRetry(new() { OnRetry = args => { var serviceProvider = services.BuildServiceProvider(); var logger = serviceProvider.GetService<ILogger>(); // ... return default; } }); }); Reasoning: This approach builds a new ServiceProvider before each retry attempt unnecessarily. ✅ DO Use another overload of AddResiliencePipeline() which allows access to IServiceProvider: var services = new ServiceCollection(); services.AddResiliencePipeline(\"myFavoriteStrategy\", static (builder, context) => { builder.AddRetry(new() { OnRetry = args => { var logger = context.ServiceProvider.GetService<ILogger>(); // ... return default; } }); }); Reasoning: This approach uses the already built ServiceProvider and uses the same instance before every retry attempts."
  },
  "advanced/performance.html": {
    "href": "advanced/performance.html",
    "title": "Performance | Polly",
    "keywords": "Performance Polly is fast and avoids allocations wherever possible. We use a comprehensive set of performance benchmarks to monitor Polly's performance. Here's an example of results from an advanced pipeline composed of the following strategies: Timeout (outer) Rate limiter Retry Circuit breaker Timeout (inner) Method Mean Error StdDev Ratio RatioSD Gen0 Allocated Alloc Ratio Execute policy v7 2.277 μs 0.0133 μs 0.0191 μs 1.00 0.00 0.1106 2824 B 1.00 Execute pipeline v8 2.089 μs 0.0105 μs 0.0157 μs 0.92 0.01 - 40 B 0.01 Compared to older versions, Polly v8 is both faster and more memory efficient. Performance tips If you're aiming for the best performance with Polly, consider these tips: Use static lambdas Lambdas capturing variables from their outer scope will allocate on every execution. Polly provides tools to avoid this overhead, as shown in the example below: // This call allocates for each invocation since the \"userId\" variable is captured from the outer scope. await resiliencePipeline.ExecuteAsync( cancellationToken => GetMemberAsync(userId, cancellationToken), cancellationToken); // This approach uses a static lambda, avoiding allocations. // The \"userId\" is stored as state, and the lambda consumes it. await resiliencePipeline.ExecuteAsync( static (state, cancellationToken) => GetMemberAsync(state, cancellationToken), userId, cancellationToken); Use switch expressions for predicates The PredicateBuilder maintains a list of all registered predicates. To determine whether the results should be processed, it iterates through this list. Using switch expressions can help you bypass this overhead. // Here, PredicateBuilder is used to configure which exceptions the retry strategy should handle. new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<SomeExceptionType>() .Handle<InvalidOperationException>() .Handle<HttpRequestException>() }) .Build(); // For optimal performance, it's recommended to use switch expressions instead of PredicateBuilder. new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = args => args.Outcome.Exception switch { SomeExceptionType => PredicateResult.True(), InvalidOperationException => PredicateResult.True(), HttpRequestException => PredicateResult.True(), _ => PredicateResult.False() } }) .Build(); Execute callbacks without throwing exceptions Polly provides the ExecuteOutcomeAsync API, returning results as Outcome<T>. The Outcome<T> might contain an exception instance, which you can check without it being thrown. This is beneficial when employing exception-heavy resilience strategies, like circuit breakers. // Execute GetMemberAsync and handle exceptions externally. try { await pipeline.ExecuteAsync(cancellationToken => GetMemberAsync(id, cancellationToken), cancellationToken); } catch (Exception e) { // Log the exception here. logger.LogWarning(e, \"Failed to get member with id '{id}'.\", id); } // The example above can be restructured as: // Acquire a context from the pool ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken); // Instead of wrapping pipeline execution with try-catch, use ExecuteOutcomeAsync(...). // Certain strategies are optimized for this method, returning an exception instance without actually throwing it. Outcome<Member> outcome = await pipeline.ExecuteOutcomeAsync( static async (context, state) => { // The callback for ExecuteOutcomeAsync must return an Outcome<T> instance. Hence, some wrapping is needed. try { return Outcome.FromResult(await GetMemberAsync(state, context.CancellationToken)); } catch (Exception e) { return Outcome.FromException<Member>(e); } }, context, id); // Handle exceptions using the Outcome<T> instance instead of try-catch. if (outcome.Exception is not null) { logger.LogWarning(outcome.Exception, \"Failed to get member with id '{id}'.\", id); } // Release the context back to the pool ResilienceContextPool.Shared.Return(context); Reuse resilience pipeline instances Creating a resilience pipeline can be resource-intensive, so it's advisable not to discard the instance after each use. Instead, you can either cache the resilience pipeline or use the GetOrAddPipeline(...) method from ResiliencePipelineRegistry<T> to cache the pipeline dynamically: public class MyApi { private readonly ResiliencePipelineRegistry<string> _registry; // Share a single instance of the registry throughout your application. public MyApi(ResiliencePipelineRegistry<string> registry) { _registry = registry; } public async Task UpdateData(CancellationToken cancellationToken) { // Get or create the pipeline, and then cache it for subsequent use. // Choose a sufficiently unique key to prevent collisions. var pipeline = _registry.GetOrAddPipeline(\"my-app.my-api\", builder => { builder.AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<InvalidOperationException>() .Handle<HttpRequestException>() }); }); await pipeline.ExecuteAsync(async token => { // Place your logic here }, cancellationToken); } } Note You can also define your pipeline on startup using dependency injection and then use ResiliencePipelineProvider<T> to retrieve the instance."
  },
  "advanced/resilience-context.html": {
    "href": "advanced/resilience-context.html",
    "title": "Resilience context | Polly",
    "keywords": "Resilience context The ResilienceContext class in Polly provides an execution-scoped instance that accompanies each execution through a Polly resilience strategy. This class serves to share context and facilitate information exchange between the pre-execution, mid-execution, and post-execution phases. The resilience context exposes several properties: OperationKey: A user-defined identifier for the operation. CancellationToken: The cancellation token linked to the operation. Properties: An instance of ResilienceProperties for attaching custom data to the context. ContinueOnCapturedContext: Specifies whether the asynchronous execution should continue on the captured context. Usage Below is an example demonstrating how to work with ResilienceContext: // Retrieve a context with a cancellation token ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken); // Attach custom data to the context context.Properties.Set(MyResilienceKeys.Key1, \"my-data\"); context.Properties.Set(MyResilienceKeys.Key2, 123); // Utilize the context in a resilience pipeline ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new() { OnRetry = static args => { // Retrieve custom data from the context, if available if (args.Context.Properties.TryGetValue(MyResilienceKeys.Key1, out var data)) { Console.WriteLine(\"OnRetry, Custom Data: {0}\", data); } return default; } }) .Build(); // Execute the resilience pipeline asynchronously await pipeline.ExecuteAsync( static async context => { // Insert your execution logic here }, context); // Return the context to the pool ResilienceContextPool.Shared.Return(context); Where ResilienceKeys is defined as: public static class MyResilienceKeys { public static readonly ResiliencePropertyKey<string> Key1 = new(\"my-key-1\"); public static readonly ResiliencePropertyKey<int> Key2 = new(\"my-key-2\"); } Note We recommend defining a static class to hold the resilience property keys used in your project. This approach makes these keys easier to discover and maintain. For simpler scenarios, you can directly use the creation of ResiliencePropertyKey<string> since it's a cheap, struct-based API. Resilient context pooling The ResilienceContext object is resource-intensive to create, and recreating it for each execution would negatively impact performance. To address this issue, Polly provides a ResilienceContextPool. This pool allows you to obtain and reuse ResilienceContext instances. Once you've finished using a context instance, you can return it to the pool. This action will reset the context to its initial state, making it available for reuse. The ResilienceContextPool offers several Get methods. These methods not only allow you to retrieve a ResilienceContext instance, but also enable you to initialize some of its properties at the time of retrieval. // Retrieve a context with a cancellation token ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken); try { // Retrieve a context with a specific operation key context = ResilienceContextPool.Shared.Get(\"my-operation-key\", cancellationToken); // Retrieve a context with multiple properties context = ResilienceContextPool.Shared.Get( operationKey: \"my-operation-key\", continueOnCapturedContext: true, cancellationToken: cancellationToken); // Use the pool here } finally { // Returning the context back to the pool is recommended, but not required as it reduces the allocations. // It is also OK to not return the context in case of exceptions, if you want to avoid try-catch blocks. ResilienceContextPool.Shared.Return(context); }"
  },
  "advanced/simmy.html": {
    "href": "advanced/simmy.html",
    "title": "Chaos engineering with Simmy | Polly",
    "keywords": "Chaos engineering with Simmy Simmy is a major new companion project adding a chaos-engineering and fault-injection dimension to Polly, through the provision of policies to selectively inject faults or latency. Head over to the Simmy repo to find out more."
  },
  "advanced/telemetry.html": {
    "href": "advanced/telemetry.html",
    "title": "Telemetry | Polly",
    "keywords": "Telemetry Starting with version 8, Polly provides telemetry for all built-in resilience strategies. Usage To enable telemetry in Polly, add the Polly.Extensions package to your project: dotnet add package Polly.Extensions Afterwards, you can use the ConfigureTelemetry(...) extension method on the ResiliencePipelineBuilder: var telemetryOptions = new TelemetryOptions { // Configure logging LoggerFactory = LoggerFactory.Create(builder => builder.AddConsole()) }; // Configure enrichers telemetryOptions.MeteringEnrichers.Add(new MyMeteringEnricher()); // Configure telemetry listeners telemetryOptions.TelemetryListeners.Add(new MyTelemetryListener()); var builder = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(1)) .ConfigureTelemetry(telemetryOptions) // This method enables telemetry in the builder .Build(); The MyTelemetryListener and MyMeteringEnricher is implemented as: internal class MyTelemetryListener : TelemetryListener { public override void Write<TResult, TArgs>(in TelemetryEventArguments<TResult, TArgs> args) { Console.WriteLine($\"Telemetry event occurred: {args.Event.EventName}\"); } } internal class MyMeteringEnricher : MeteringEnricher { public override void Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs> context) { context.Tags.Add(new(\"my-custom-tag\", \"custom-value\")); } } Alternatively, you can use the AddResiliencePipeline(...) extension method which automatically enables telemetry for defined pipeline: var serviceCollection = new ServiceCollection() .AddLogging(builder => builder.AddConsole()) .AddResiliencePipeline(\"my-strategy\", builder => builder.AddTimeout(TimeSpan.FromSeconds(1))) .Configure<TelemetryOptions>(options => { // Configure enrichers options.MeteringEnrichers.Add(new MyMeteringEnricher()); // Configure telemetry listeners options.TelemetryListeners.Add(new MyTelemetryListener()); }); Metrics The metrics are emitted under the Polly meter name. The subsequent sections provide insights into the metrics produced by Polly. Please note that any custom enriched tags are not depicted in the following tables. Every telemetry event has the following tags: pipeline.name: Optional, comes from ResiliencePipelineBuilder.Name. pipeline.instance: Optional, comes from ResiliencePipelineBuilder.InstanceName. strategy.name: Optional, comes from RetryStrategyOptions.Name. The sample below demonstrates how to assign these tags: var builder = new ResiliencePipelineBuilder(); builder.Name = \"my-name\"; builder.Name = \"my-instance-name\"; builder.AddRetry(new RetryStrategyOptions { // The default value is \"Retry\" Name = \"my-retry-name\" }); These values are subsequently reflected in the following metering instruments exposed by Polly: Instrument: resilience.polly.strategy.events Type: Counter Description: Emitted upon the occurrence of a resilience event. Tags: Name Description event.name The name of the emitted event. event.severity The severity of the event (Debug, Information, Warning, Error, Critical). pipeline.name The name of the pipeline corresponding to the resilience pipeline. pipeline.instance The instance name of the pipeline corresponding to the resilience pipeline. strategy.name The name of the strategy generating this event. operation.key The operation key associated with the call site. exception.type The full name of the exception assigned to the execution result (System.InvalidOperationException). Instrument: resilience.polly.strategy.attempt.duration Type: Histogram Unit: milliseconds Description: Tracks the duration of execution attempts, produced by Retry and Hedging resilience strategies. Tags: Name Description event.name The name of the emitted event. event.severity The severity of the event (Debug, Information, Warning, Error, Critical). pipeline.name The name of the pipeline corresponding to the resilience pipeline. pipeline.instance The instance name of the pipeline corresponding to the resilience pipeline. strategy.name The name of the strategy generating this event. operation.key The operation key associated with the call site. exception.type The full name of the exception assigned to the execution result (System.InvalidOperationException). attempt.number The execution attempt number, starting at 0 (0, 1, 2, etc.). attempt.handled Indicates if the execution outcome was handled. A handled outcome indicates execution failure and the need for retry (true, false). Instrument: resilience.polly.pipeline.duration Type: Histogram Unit: milliseconds Description: Measures the duration of resilience pipelines. Tags: Name Description pipeline.name The name of the pipeline corresponding to the resilience pipeline. pipeline.instance The instance name of the pipeline corresponding to the resilience pipeline. operation.key The operation key associated with the call site. exception.type The full name of the exception assigned to the execution result (System.InvalidOperationException). Logs Logs are registered under the Polly logger name. Here are some examples of the logs: // This log is recorded whenever a resilience event occurs. EventId = 0 Resilience event occurred. EventName: '{EventName}', Source: '{PipelineName}/{PipelineInstance}/{StrategyName}', Operation Key: '{OperationKey}', Result: '{Result}' // This log is recorded when a resilience pipeline begins executing. EventId = 1 Resilience pipeline executing. Source: '{PipelineName}/{PipelineInstance}', Operation Key: '{OperationKey}' // This log is recorded when a resilience pipeline finishes execution. EventId = 2 Resilience pipeline executed. Source: '{PipelineName}/{PipelineInstance}', Operation Key: '{OperationKey}', Result: '{Result}', Execution Health: '{ExecutionHealth}', Execution Time: {ExecutionTime}ms // This log is recorded upon the completion of every execution attempt. EventId = 3 Execution attempt. Source: '{PipelineName}/{PipelineInstance}/{StrategyName}', Operation Key: '{OperationKey}', Result: '{Result}', Handled: '{Handled}', Attempt: '{Attempt}', Execution Time: '{ExecutionTimeMs}' Emitting telemetry events Each resilience strategy can generate telemetry data through the ResilienceStrategyTelemetry API. Polly encapsulates event details as TelemetryEventArguments and emits them via TelemetryListener. To leverage this telemetry data, users should assign a TelemetryListener instance to ResiliencePipelineBuilder.TelemetryListener and then consume the TelemetryEventArguments. For common scenarios, it is expected that users would make use of Polly.Extensions. This extension enables telemetry configuration through the ResiliencePipelineBuilder.ConfigureTelemetry(...) method, which processes TelemetryEventArguments to generate logs and metrics."
  },
  "advanced/testing.html": {
    "href": "advanced/testing.html",
    "title": "Testing | Polly",
    "keywords": "Testing This document explains how to test Polly's resilience pipelines. You should not test how the resilience pipelines operate internally, but rather test your own settings or custom delegates. To make the testing process simpler, Polly offers the Polly.Testing package. This package has a range of APIs designed to help you test the setup and combination of resilience pipelines in your user code. Usage Begin by adding the Polly.Testing package to your test project: dotnet add package Polly.Testing Use the GetPipelineDescriptor extension method to get the ResiliencePipelineDescriptor which provides details on the pipeline's composition: // Build your resilience pipeline. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { MaxRetryAttempts = 4 }) .AddTimeout(TimeSpan.FromSeconds(1)) .Build(); // Retrieve the descriptor. ResiliencePipelineDescriptor descriptor = pipeline.GetPipelineDescriptor(); // Check the pipeline's composition with the descriptor. Assert.Equal(2, descriptor.Strategies.Count); // Verify the retry settings. var retryOptions = Assert.IsType<RetryStrategyOptions>(descriptor.Strategies[0].Options); Assert.Equal(4, retryOptions.MaxRetryAttempts); // Confirm the timeout settings. var timeoutOptions = Assert.IsType<TimeoutStrategyOptions>(descriptor.Strategies[1].Options); Assert.Equal(TimeSpan.FromSeconds(1), timeoutOptions.Timeout); The GetPipelineDescriptor extension method is also available for the generic ResiliencePipeline<T>: // Construct your resilience pipeline. ResiliencePipeline<string> pipeline = new ResiliencePipelineBuilder<string>() .AddRetry(new RetryStrategyOptions<string> { MaxRetryAttempts = 4 }) .AddTimeout(TimeSpan.FromSeconds(1)) .Build(); // Obtain the descriptor. ResiliencePipelineDescriptor descriptor = pipeline.GetPipelineDescriptor(); // Check the pipeline's composition with the descriptor. // ... Mocking ResiliencePipelineProvider<TKey> Consider the following code that might resemble a part of your project: // Represents an arbitrary API that needs resilience support public class MyApi { private readonly ResiliencePipeline _pipeline; // The value of pipelineProvider is injected via dependency injection public MyApi(ResiliencePipelineProvider<string> pipelineProvider) { _pipeline = pipelineProvider.GetPipeline(\"my-pipeline\"); } public async Task ExecuteAsync(CancellationToken cancellationToken) { await _pipeline.ExecuteAsync( static async token => { // Add your code here }, cancellationToken); } } // Extensions to incorporate MyApi into dependency injection public static class MyApiExtensions { public static IServiceCollection AddMyApi(this IServiceCollection services) { return services .AddResiliencePipeline(\"my-pipeline\", builder => { builder.AddRetry(new RetryStrategyOptions { MaxRetryAttempts = 4 }); }) .AddSingleton<MyApi>(); } } In the example above: The MyApi class is introduced, representing part of your application that requires resilience support. The AddMyApi extension method is also defined, which integrates MyApi into dependency injection (DI) and sets up the resilience pipeline it uses. For unit tests, if you want to assess the behavior of ExecuteAsync, it might not be practical to rely on the entire pipeline, especially since it could slow down tests during failure scenario evaluations. Instead, it's recommended to mock the ResiliencePipelineProvider<string> and return an empty pipeline: ResiliencePipelineProvider<string> pipelineProvider = Substitute.For<ResiliencePipelineProvider<string>>(); // Mock the pipeline provider to return an empty pipeline for testing pipelineProvider .GetPipeline(\"my-pipeline\") .Returns(ResiliencePipeline.Empty); // Use the mocked pipeline provider in your code var api = new MyApi(pipelineProvider); // You can now test the api This example leverages the NSubstitute library to mock the pipeline provider."
  },
  "api/Polly.CircuitBreaker.BrokenCircuitException.html": {
    "href": "api/Polly.CircuitBreaker.BrokenCircuitException.html",
    "title": "Class BrokenCircuitException | Polly",
    "keywords": "Class BrokenCircuitException Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Exception thrown when a circuit is broken. public class BrokenCircuitException : ExecutionRejectedException, ISerializable Inheritance object Exception ExecutionRejectedException BrokenCircuitException Implements ISerializable Derived IsolatedCircuitException Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors BrokenCircuitException() Initializes a new instance of the BrokenCircuitException class. public BrokenCircuitException() BrokenCircuitException(string) Initializes a new instance of the BrokenCircuitException class. public BrokenCircuitException(string message) Parameters message string The message that describes the error. BrokenCircuitException(string, Exception) Initializes a new instance of the BrokenCircuitException class. public BrokenCircuitException(string message, Exception inner) Parameters message string The message that describes the error. inner Exception The inner exception."
  },
  "api/Polly.CircuitBreaker.CircuitBreakerManualControl.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerManualControl.html",
    "title": "Class CircuitBreakerManualControl | Polly",
    "keywords": "Class CircuitBreakerManualControl Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Allows manual control of the circuit-breaker. public sealed class CircuitBreakerManualControl Inheritance object CircuitBreakerManualControl Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks The instance of this class can be reused across multiple circuit breakers. Constructors CircuitBreakerManualControl() Initializes a new instance of the CircuitBreakerManualControl class. public CircuitBreakerManualControl() CircuitBreakerManualControl(bool) Initializes a new instance of the CircuitBreakerManualControl class. public CircuitBreakerManualControl(bool isIsolated) Parameters isIsolated bool Determines whether the circuit breaker is isolated immediately after construction. Methods CloseAsync(CancellationToken) Closes the circuit, and resets any statistics controlling automated circuit-breaking. public Task CloseAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken The cancellation token. Returns Task The instance of Task that represents the asynchronous execution. Exceptions ObjectDisposedException Thrown when calling this method after this object is disposed. IsolateAsync(CancellationToken) Isolates (opens) the circuit manually, and holds it in this state until a call to CloseAsync(CancellationToken) is made. public Task IsolateAsync(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken The cancellation token. Returns Task The instance of Task that represents the asynchronous execution. Exceptions ObjectDisposedException Thrown when calling this method after this object is disposed."
  },
  "api/Polly.CircuitBreaker.CircuitBreakerPredicateArguments-1.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerPredicateArguments-1.html",
    "title": "Struct CircuitBreakerPredicateArguments<TResult> | Polly",
    "keywords": "Struct CircuitBreakerPredicateArguments<TResult> Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Arguments used by ShouldHandle predicate. public readonly struct CircuitBreakerPredicateArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors CircuitBreakerPredicateArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the CircuitBreakerPredicateArguments<TResult> struct. public CircuitBreakerPredicateArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the user-specified callback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.CircuitBreaker.CircuitBreakerStateProvider.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerStateProvider.html",
    "title": "Class CircuitBreakerStateProvider | Polly",
    "keywords": "Class CircuitBreakerStateProvider Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Allows retrieval of the circuit breaker state. public sealed class CircuitBreakerStateProvider Inheritance object CircuitBreakerStateProvider Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties CircuitState Gets the state of the underlying circuit. public CircuitState CircuitState { get; } Property Value CircuitState"
  },
  "api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions-1.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions-1.html",
    "title": "Class CircuitBreakerStrategyOptions<TResult> | Polly",
    "keywords": "Class CircuitBreakerStrategyOptions<TResult> Namespace Polly.CircuitBreaker Assembly Polly.Core.dll The options for circuit breaker resilience strategy. public class CircuitBreakerStrategyOptions<TResult> : ResilienceStrategyOptions Type Parameters TResult The type of result the circuit breaker strategy handles. Inheritance object ResilienceStrategyOptions CircuitBreakerStrategyOptions<TResult> Derived CircuitBreakerStrategyOptions Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The circuit will break if, within any time-slice of duration SamplingDuration, the proportion of actions resulting in a handled exception exceeds FailureRatio, provided also that the number of actions through the circuit in the time-slice is at least MinimumThroughput. The circuit will stay broken for the BreakDuration. Any attempt to execute this while the circuit is broken, will immediately throw a BrokenCircuitException containing the exception that broke the circuit. If the first action after the break duration period results in a handled exception, the circuit will break again for another BreakDuration; if no exception is thrown, the circuit will reset. Constructors CircuitBreakerStrategyOptions() Initializes a new instance of the CircuitBreakerStrategyOptions<TResult> class. public CircuitBreakerStrategyOptions() Properties BreakDuration Gets or sets the duration of break the circuit will stay open before resetting. [Range(typeof(TimeSpan), \"00:00:00.500\", \"1.00:00:00\")] public TimeSpan BreakDuration { get; set; } Property Value TimeSpan The default value is 5 seconds. Value must be greater than 0.5 seconds. FailureRatio Gets or sets the failure-to-success ratio at which the circuit will break. [Range(0, 1)] public double FailureRatio { get; set; } Property Value double A ratio number higher than 0, up to 1. The default value is 0.1 (i.e. 10%). Remarks A number between zero and one (inclusive) e.g. 0.5 represents breaking if 50% or more of actions result in a handled failure. ManualControl Gets or sets the manual control for the circuit breaker. public CircuitBreakerManualControl? ManualControl { get; set; } Property Value CircuitBreakerManualControl The default value is null. MinimumThroughput Gets or sets the minimum throughput: this many actions or more must pass through the circuit in the time-slice, for statistics to be considered significant and the circuit-breaker to come into action. [Range(2, 2147483647)] public int MinimumThroughput { get; set; } Property Value int The default value is 100. The value must be 2 or greater. OnClosed Gets or sets the event that is raised when the circuit resets to a Closed state. public Func<OnCircuitClosedArguments<TResult>, ValueTask>? OnClosed { get; set; } Property Value Func<OnCircuitClosedArguments<TResult>, ValueTask> The default value is null. Remarks The callbacks registered to this event are invoked with eventual consistency. There is no guarantee that the circuit breaker doesn't change the state before the callbacks finish. If you need to know the up-to-date state of the circuit breaker use the CircuitState property. Note that these events might be executed asynchronously at a later time when the circuit state is no longer the same as at the point of invocation of the event. However, the invocation order of the OnOpened, OnClosed, and OnHalfOpened events is always maintained to ensure the correct sequence of state transitions. OnHalfOpened Gets or sets the event that is raised when when the circuit transitions to an HalfOpen state. public Func<OnCircuitHalfOpenedArguments, ValueTask>? OnHalfOpened { get; set; } Property Value Func<OnCircuitHalfOpenedArguments, ValueTask> The default value is null. Remarks The callbacks registered to this event are invoked with eventual consistency. There is no guarantee that the circuit breaker doesn't change the state before the callbacks finish. If you need to know the up-to-date state of the circuit breaker use the CircuitState property. Note that these events might be executed asynchronously at a later time when the circuit state is no longer the same as at the point of invocation of the event. However, the invocation order of the OnOpened, OnClosed, and OnHalfOpened events is always maintained to ensure the correct sequence of state transitions. OnOpened Gets or sets the event that is raised when the circuit transitions to an Open state. public Func<OnCircuitOpenedArguments<TResult>, ValueTask>? OnOpened { get; set; } Property Value Func<OnCircuitOpenedArguments<TResult>, ValueTask> The default value is null. Remarks The callbacks registered to this event are invoked with eventual consistency. There is no guarantee that the circuit breaker doesn't change the state before the callbacks finish. If you need to know the up-to-date state of the circuit breaker use the CircuitState property. Note that these events might be executed asynchronously at a later time when the circuit state is no longer the same as at the point of invocation of the event. However, the invocation order of the OnOpened, OnClosed, and OnHalfOpened events is always maintained to ensure the correct sequence of state transitions. SamplingDuration Gets or sets the duration of the sampling over which failure ratios are assessed. [Range(typeof(TimeSpan), \"00:00:00.500\", \"1.00:00:00\")] public TimeSpan SamplingDuration { get; set; } Property Value TimeSpan The default value is 30 seconds. Value must be greater than 0.5 seconds. ShouldHandle Gets or sets a predicate that determines whether the outcome should be handled by the circuit breaker. [Required] public Func<CircuitBreakerPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } Property Value Func<CircuitBreakerPredicateArguments<TResult>, ValueTask<bool>> The default value is a predicate that handles circuit breaker on any exception except OperationCanceledException. This property is required. StateProvider Gets or sets the state provider for the circuit breaker. public CircuitBreakerStateProvider? StateProvider { get; set; } Property Value CircuitBreakerStateProvider The default value is null."
  },
  "api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions.html": {
    "href": "api/Polly.CircuitBreaker.CircuitBreakerStrategyOptions.html",
    "title": "Class CircuitBreakerStrategyOptions | Polly",
    "keywords": "Class CircuitBreakerStrategyOptions Namespace Polly.CircuitBreaker Assembly Polly.Core.dll The options for circuit breaker resilience strategy. public class CircuitBreakerStrategyOptions : CircuitBreakerStrategyOptions<object> Inheritance object ResilienceStrategyOptions CircuitBreakerStrategyOptions<object> CircuitBreakerStrategyOptions Inherited Members CircuitBreakerStrategyOptions<object>.FailureRatio CircuitBreakerStrategyOptions<object>.MinimumThroughput CircuitBreakerStrategyOptions<object>.SamplingDuration CircuitBreakerStrategyOptions<object>.BreakDuration CircuitBreakerStrategyOptions<object>.ShouldHandle CircuitBreakerStrategyOptions<object>.OnClosed CircuitBreakerStrategyOptions<object>.OnOpened CircuitBreakerStrategyOptions<object>.OnHalfOpened CircuitBreakerStrategyOptions<object>.ManualControl CircuitBreakerStrategyOptions<object>.StateProvider ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks The circuit will break if, within any time-slice of duration SamplingDuration, the proportion of actions resulting in a handled exception exceeds FailureRatio, provided also that the number of actions through the circuit in the time-slice is at least MinimumThroughput. The circuit will stay broken for the BreakDuration. Any attempt to execute this while the circuit is broken, will immediately throw a BrokenCircuitException containing the exception that broke the circuit. If the first action after the break duration period results in a handled exception, the circuit will break again for another BreakDuration; if no exception is thrown, the circuit will reset."
  },
  "api/Polly.CircuitBreaker.CircuitState.html": {
    "href": "api/Polly.CircuitBreaker.CircuitState.html",
    "title": "Enum CircuitState | Polly",
    "keywords": "Enum CircuitState Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Describes the possible states the circuit of a Circuit Breaker may be in. public enum CircuitState Fields Closed = 0 Closed - When the circuit is closed. Execution of actions is allowed. HalfOpen = 2 Half-open - When the circuit is half-open, it is recovering from an open state. The duration of break of the preceding open state has typically passed. In the half-open state, actions may be executed, but the results of these actions may be treated with criteria different to normal operation, to decide if the circuit has recovered sufficiently to be placed back in to the closed state, or if continuing failures mean the circuit should revert to open perhaps more quickly than in normal operation. Isolated = 3 Isolated - When the circuit has been placed into a fixed open state by the isolate call. This isolates the circuit manually, blocking execution of all actions until a reset call is made. Open = 1 Open - When the automated controller has opened the circuit (typically due to some failure threshold being exceeded by recent actions). Execution of actions is blocked."
  },
  "api/Polly.CircuitBreaker.IsolatedCircuitException.html": {
    "href": "api/Polly.CircuitBreaker.IsolatedCircuitException.html",
    "title": "Class IsolatedCircuitException | Polly",
    "keywords": "Class IsolatedCircuitException Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Exception thrown when a circuit is isolated (held open) by manual override. public class IsolatedCircuitException : BrokenCircuitException, ISerializable Inheritance object Exception ExecutionRejectedException BrokenCircuitException IsolatedCircuitException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors IsolatedCircuitException() Initializes a new instance of the IsolatedCircuitException class. public IsolatedCircuitException() IsolatedCircuitException(string) Initializes a new instance of the IsolatedCircuitException class. public IsolatedCircuitException(string message) Parameters message string The message that describes the error. IsolatedCircuitException(string, Exception) Initializes a new instance of the IsolatedCircuitException class. public IsolatedCircuitException(string message, Exception innerException) Parameters message string The message that describes the error. innerException Exception The inner exception."
  },
  "api/Polly.CircuitBreaker.OnCircuitClosedArguments-1.html": {
    "href": "api/Polly.CircuitBreaker.OnCircuitClosedArguments-1.html",
    "title": "Struct OnCircuitClosedArguments<TResult> | Polly",
    "keywords": "Struct OnCircuitClosedArguments<TResult> Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Arguments used by OnClosed event. public readonly struct OnCircuitClosedArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnCircuitClosedArguments(ResilienceContext, Outcome<TResult>, bool) Initializes a new instance of the OnCircuitClosedArguments<TResult> struct. public OnCircuitClosedArguments(ResilienceContext context, Outcome<TResult> outcome, bool isManual) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. isManual bool Indicates whether the circuit was closed manually by using CircuitBreakerManualControl. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext IsManual Gets a value indicating whether the circuit was closed manually by using CircuitBreakerManualControl. public bool IsManual { get; } Property Value bool Outcome Gets the outcome that caused the circuit breaker to be closed. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.CircuitBreaker.OnCircuitHalfOpenedArguments.html": {
    "href": "api/Polly.CircuitBreaker.OnCircuitHalfOpenedArguments.html",
    "title": "Struct OnCircuitHalfOpenedArguments | Polly",
    "keywords": "Struct OnCircuitHalfOpenedArguments Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Arguments used by OnHalfOpened event. public readonly struct OnCircuitHalfOpenedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnCircuitHalfOpenedArguments(ResilienceContext) Initializes a new instance of the OnCircuitHalfOpenedArguments struct. public OnCircuitHalfOpenedArguments(ResilienceContext context) Parameters context ResilienceContext The context instance. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.CircuitBreaker.OnCircuitOpenedArguments-1.html": {
    "href": "api/Polly.CircuitBreaker.OnCircuitOpenedArguments-1.html",
    "title": "Struct OnCircuitOpenedArguments<TResult> | Polly",
    "keywords": "Struct OnCircuitOpenedArguments<TResult> Namespace Polly.CircuitBreaker Assembly Polly.Core.dll Arguments used by OnOpened event. public readonly struct OnCircuitOpenedArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnCircuitOpenedArguments(ResilienceContext, Outcome<TResult>, TimeSpan, bool) Initializes a new instance of the OnCircuitOpenedArguments<TResult> struct. public OnCircuitOpenedArguments(ResilienceContext context, Outcome<TResult> outcome, TimeSpan breakDuration, bool isManual) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. breakDuration TimeSpan The duration of break. isManual bool Indicates whether the circuit was opened manually by using CircuitBreakerManualControl. Properties BreakDuration Gets the duration of break. public TimeSpan BreakDuration { get; } Property Value TimeSpan Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext IsManual Gets a value indicating whether the circuit was opened manually by using CircuitBreakerManualControl. public bool IsManual { get; } Property Value bool Outcome Gets the outcome that caused the circuit to open. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.CircuitBreaker.html": {
    "href": "api/Polly.CircuitBreaker.html",
    "title": "Namespace Polly.CircuitBreaker | Polly",
    "keywords": "Namespace Polly.CircuitBreaker Classes BrokenCircuitException Exception thrown when a circuit is broken. CircuitBreakerManualControl Allows manual control of the circuit-breaker. CircuitBreakerStateProvider Allows retrieval of the circuit breaker state. CircuitBreakerStrategyOptions The options for circuit breaker resilience strategy. CircuitBreakerStrategyOptions<TResult> The options for circuit breaker resilience strategy. IsolatedCircuitException Exception thrown when a circuit is isolated (held open) by manual override. Structs CircuitBreakerPredicateArguments<TResult> Arguments used by ShouldHandle predicate. OnCircuitClosedArguments<TResult> Arguments used by OnClosed event. OnCircuitHalfOpenedArguments Arguments used by OnHalfOpened event. OnCircuitOpenedArguments<TResult> Arguments used by OnOpened event. Enums CircuitState Describes the possible states the circuit of a Circuit Breaker may be in."
  },
  "api/Polly.CircuitBreakerResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.CircuitBreakerResiliencePipelineBuilderExtensions.html",
    "title": "Class CircuitBreakerResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class CircuitBreakerResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Circuit breaker extensions for ResiliencePipelineBuilder. public static class CircuitBreakerResiliencePipelineBuilderExtensions Inheritance object CircuitBreakerResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddCircuitBreaker(ResiliencePipelineBuilder, CircuitBreakerStrategyOptions) Adds circuit breaker to the builder. public static ResiliencePipelineBuilder AddCircuitBreaker(this ResiliencePipelineBuilder builder, CircuitBreakerStrategyOptions options) Parameters builder ResiliencePipelineBuilder The builder instance. options CircuitBreakerStrategyOptions The options instance. Returns ResiliencePipelineBuilder A builder with the circuit breaker added. Remarks See CircuitBreakerStrategyOptions<TResult> for more details about the circuit breaker. If you are discarding the circuit breaker by this call make sure to use CircuitBreakerManualControl and dispose the manual control instance when the circuit breaker is no longer used. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. AddCircuitBreaker<TResult>(ResiliencePipelineBuilder<TResult>, CircuitBreakerStrategyOptions<TResult>) Adds circuit breaker to the builder. public static ResiliencePipelineBuilder<TResult> AddCircuitBreaker<TResult>(this ResiliencePipelineBuilder<TResult> builder, CircuitBreakerStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. options CircuitBreakerStrategyOptions<TResult> The options instance. Returns ResiliencePipelineBuilder<TResult> A builder with the circuit breaker added. Type Parameters TResult The type of result the circuit breaker handles. Remarks See CircuitBreakerStrategyOptions<TResult> for more details about the circuit breaker. If you are discarding the circuit breaker by this call make sure to use CircuitBreakerManualControl and dispose the manual control instance when the circuit breaker is no longer used. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid."
  },
  "api/Polly.DelayBackoffType.html": {
    "href": "api/Polly.DelayBackoffType.html",
    "title": "Enum DelayBackoffType | Polly",
    "keywords": "Enum DelayBackoffType Namespace Polly Assembly Polly.Core.dll The backoff type used by the strategies. public enum DelayBackoffType Fields Constant = 0 The constant backoff type. Exponential = 2 The exponential backoff type with the power of 2. Linear = 1 The linear backoff type."
  },
  "api/Polly.DependencyInjection.AddResiliencePipelineContext-1.html": {
    "href": "api/Polly.DependencyInjection.AddResiliencePipelineContext-1.html",
    "title": "Class AddResiliencePipelineContext<TKey> | Polly",
    "keywords": "Class AddResiliencePipelineContext<TKey> Namespace Polly.DependencyInjection Assembly Polly.Extensions.dll Represents the context for adding a resilience pipeline with the specified key. public sealed class AddResiliencePipelineContext<TKey> where TKey : notnull Type Parameters TKey The type of the key used to identify the resilience pipeline. Inheritance object AddResiliencePipelineContext<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties PipelineKey Gets the pipeline key for the pipeline being created. public TKey PipelineKey { get; } Property Value TKey ServiceProvider Gets the IServiceProvider that provides access to the dependency injection container. public IServiceProvider ServiceProvider { get; } Property Value IServiceProvider Methods EnableReloads<TOptions>(string?) Enables dynamic reloading of the resilience pipeline whenever the TOptions options are changed. public void EnableReloads<TOptions>(string? name = null) Parameters name string The named options, if any. Type Parameters TOptions The options type to listen to. Remarks You can decide based on the name to listen for changes in global options or named options. If name is null then the global options are listened to. You can listen for changes from multiple options by calling this method with different TOptions types. GetOptions<TOptions>(string?) Gets the options identified by name. public TOptions GetOptions<TOptions>(string? name = null) Parameters name string The options name, if any. Returns TOptions The options instance. Type Parameters TOptions The options type. Remarks If name is null then the global options are returned. OnPipelineDisposed(Action) Registers a callback that is called when the pipeline instance being configured is disposed. public void OnPipelineDisposed(Action callback) Parameters callback Action The callback delegate."
  },
  "api/Polly.DependencyInjection.html": {
    "href": "api/Polly.DependencyInjection.html",
    "title": "Namespace Polly.DependencyInjection | Polly",
    "keywords": "Namespace Polly.DependencyInjection Classes AddResiliencePipelineContext<TKey> Represents the context for adding a resilience pipeline with the specified key."
  },
  "api/Polly.ExecutionRejectedException.html": {
    "href": "api/Polly.ExecutionRejectedException.html",
    "title": "Class ExecutionRejectedException | Polly",
    "keywords": "Class ExecutionRejectedException Namespace Polly Assembly Polly.Core.dll Exception thrown when a policy rejects execution of a delegate. More specific exceptions which derive from this type, are generally thrown. public abstract class ExecutionRejectedException : Exception, ISerializable Inheritance object Exception ExecutionRejectedException Implements ISerializable Derived BrokenCircuitException RateLimiterRejectedException TimeoutRejectedException Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ExecutionRejectedException() Initializes a new instance of the ExecutionRejectedException class. protected ExecutionRejectedException() ExecutionRejectedException(string) Initializes a new instance of the ExecutionRejectedException class. protected ExecutionRejectedException(string message) Parameters message string The message that describes the error. ExecutionRejectedException(string, Exception) Initializes a new instance of the ExecutionRejectedException class. protected ExecutionRejectedException(string message, Exception inner) Parameters message string The message that describes the error. inner Exception The inner exception."
  },
  "api/Polly.Fallback.FallbackActionArguments-1.html": {
    "href": "api/Polly.Fallback.FallbackActionArguments-1.html",
    "title": "Struct FallbackActionArguments<TResult> | Polly",
    "keywords": "Struct FallbackActionArguments<TResult> Namespace Polly.Fallback Assembly Polly.Core.dll Arguments used by FallbackAction. public readonly struct FallbackActionArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors FallbackActionArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the FallbackActionArguments<TResult> struct. public FallbackActionArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome that should be handled by the fallback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Fallback.FallbackPredicateArguments-1.html": {
    "href": "api/Polly.Fallback.FallbackPredicateArguments-1.html",
    "title": "Struct FallbackPredicateArguments<TResult> | Polly",
    "keywords": "Struct FallbackPredicateArguments<TResult> Namespace Polly.Fallback Assembly Polly.Core.dll Represents arguments used in fallback handling scenarios. public readonly struct FallbackPredicateArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors FallbackPredicateArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the FallbackPredicateArguments<TResult> struct. public FallbackPredicateArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the user-specified callback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Fallback.FallbackStrategyOptions-1.html": {
    "href": "api/Polly.Fallback.FallbackStrategyOptions-1.html",
    "title": "Class FallbackStrategyOptions<TResult> | Polly",
    "keywords": "Class FallbackStrategyOptions<TResult> Namespace Polly.Fallback Assembly Polly.Core.dll Represents the options for configuring a fallback resilience strategy with a specific result type. public class FallbackStrategyOptions<TResult> : ResilienceStrategyOptions Type Parameters TResult The result type. Inheritance object ResilienceStrategyOptions FallbackStrategyOptions<TResult> Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FallbackStrategyOptions() Initializes a new instance of the FallbackStrategyOptions<TResult> class. public FallbackStrategyOptions() Properties FallbackAction Gets or sets the fallback action to be executed when the ShouldHandle predicate evaluates as true. [Required] public Func<FallbackActionArguments<TResult>, ValueTask<Outcome<TResult>>>? FallbackAction { get; set; } Property Value Func<FallbackActionArguments<TResult>, ValueTask<Outcome<TResult>>> The default value is null. This property is required. OnFallback Gets or sets event delegate that is raised when fallback happens. public Func<OnFallbackArguments<TResult>, ValueTask>? OnFallback { get; set; } Property Value Func<OnFallbackArguments<TResult>, ValueTask> The default value is null instance. ShouldHandle Gets or sets a predicate that determines whether the fallback should be executed for a given outcome. [Required] public Func<FallbackPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } Property Value Func<FallbackPredicateArguments<TResult>, ValueTask<bool>> The default value is a predicate that fallbacks on any exception except OperationCanceledException. This property is required."
  },
  "api/Polly.Fallback.OnFallbackArguments-1.html": {
    "href": "api/Polly.Fallback.OnFallbackArguments-1.html",
    "title": "Struct OnFallbackArguments<TResult> | Polly",
    "keywords": "Struct OnFallbackArguments<TResult> Namespace Polly.Fallback Assembly Polly.Core.dll Represents arguments used in fallback handling scenarios. public readonly struct OnFallbackArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnFallbackArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the OnFallbackArguments<TResult> struct. public OnFallbackArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome that caused the fallback to be executed. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Fallback.html": {
    "href": "api/Polly.Fallback.html",
    "title": "Namespace Polly.Fallback | Polly",
    "keywords": "Namespace Polly.Fallback Classes FallbackStrategyOptions<TResult> Represents the options for configuring a fallback resilience strategy with a specific result type. Structs FallbackActionArguments<TResult> Arguments used by FallbackAction. FallbackPredicateArguments<TResult> Represents arguments used in fallback handling scenarios. OnFallbackArguments<TResult> Represents arguments used in fallback handling scenarios."
  },
  "api/Polly.FallbackResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.FallbackResiliencePipelineBuilderExtensions.html",
    "title": "Class FallbackResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class FallbackResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for adding fallback to ResiliencePipelineBuilder. public static class FallbackResiliencePipelineBuilderExtensions Inheritance object FallbackResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddFallback<TResult>(ResiliencePipelineBuilder<TResult>, FallbackStrategyOptions<TResult>) Adds a fallback resilience strategy with the provided options to the builder. public static ResiliencePipelineBuilder<TResult> AddFallback<TResult>(this ResiliencePipelineBuilder<TResult> builder, FallbackStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The resilience pipeline builder. options FallbackStrategyOptions<TResult> The options to configure the fallback resilience strategy. Returns ResiliencePipelineBuilder<TResult> The builder instance with the fallback strategy added. Type Parameters TResult The result type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid."
  },
  "api/Polly.Hedging.HedgingActionGeneratorArguments-1.html": {
    "href": "api/Polly.Hedging.HedgingActionGeneratorArguments-1.html",
    "title": "Struct HedgingActionGeneratorArguments<TResult> | Polly",
    "keywords": "Struct HedgingActionGeneratorArguments<TResult> Namespace Polly.Hedging Assembly Polly.Core.dll Represents arguments used in the hedging resilience strategy. public readonly struct HedgingActionGeneratorArguments<TResult> Type Parameters TResult The type of the result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The PrimaryContext represents the context that was received by the hedging strategy and used to execute the primary action. To prevent race conditions, the hedging strategy then clones the primary context into ActionContext and uses it to execute the hedged action. Every hedged action gets its own context that is cloned from the primary. Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors HedgingActionGeneratorArguments(ResilienceContext, ResilienceContext, int, Func<ResilienceContext, ValueTask<Outcome<TResult>>>) Initializes a new instance of the HedgingActionGeneratorArguments<TResult> struct. public HedgingActionGeneratorArguments(ResilienceContext primaryContext, ResilienceContext actionContext, int attemptNumber, Func<ResilienceContext, ValueTask<Outcome<TResult>>> callback) Parameters primaryContext ResilienceContext The primary context received by the hedging strategy. actionContext ResilienceContext The action context cloned from the primary context. attemptNumber int The zero-based hedging attempt number. callback Func<ResilienceContext, ValueTask<Outcome<TResult>>> The callback passed to the hedging strategy. Properties ActionContext Gets the action context that will be used for the hedged action. public ResilienceContext ActionContext { get; } Property Value ResilienceContext Remarks This context is cloned from PrimaryContext. AttemptNumber Gets the zero-based hedging attempt number. public int AttemptNumber { get; } Property Value int Callback Gets the callback passed to the hedging strategy. public Func<ResilienceContext, ValueTask<Outcome<TResult>>> Callback { get; } Property Value Func<ResilienceContext, ValueTask<Outcome<TResult>>> PrimaryContext Gets the primary resilience context as received by the hedging strategy. public ResilienceContext PrimaryContext { get; } Property Value ResilienceContext"
  },
  "api/Polly.Hedging.HedgingDelayGeneratorArguments.html": {
    "href": "api/Polly.Hedging.HedgingDelayGeneratorArguments.html",
    "title": "Struct HedgingDelayGeneratorArguments | Polly",
    "keywords": "Struct HedgingDelayGeneratorArguments Namespace Polly.Hedging Assembly Polly.Core.dll Arguments used by hedging delay generator. public readonly struct HedgingDelayGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors HedgingDelayGeneratorArguments(ResilienceContext, int) Initializes a new instance of the HedgingDelayGeneratorArguments struct. public HedgingDelayGeneratorArguments(ResilienceContext context, int attemptNumber) Parameters context ResilienceContext The context associated with the execution of a user-provided callback. attemptNumber int The zero-based hedging attempt number. Properties AttemptNumber Gets the zero-based hedging attempt number. public int AttemptNumber { get; } Property Value int Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Hedging.HedgingPredicateArguments-1.html": {
    "href": "api/Polly.Hedging.HedgingPredicateArguments-1.html",
    "title": "Struct HedgingPredicateArguments<TResult> | Polly",
    "keywords": "Struct HedgingPredicateArguments<TResult> Namespace Polly.Hedging Assembly Polly.Core.dll Represents arguments used in hedging handling scenarios. public readonly struct HedgingPredicateArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors HedgingPredicateArguments(ResilienceContext, Outcome<TResult>) Initializes a new instance of the HedgingPredicateArguments<TResult> struct. public HedgingPredicateArguments(ResilienceContext context, Outcome<TResult> outcome) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. Properties Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the user-specified callback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Hedging.HedgingStrategyOptions-1.html": {
    "href": "api/Polly.Hedging.HedgingStrategyOptions-1.html",
    "title": "Class HedgingStrategyOptions<TResult> | Polly",
    "keywords": "Class HedgingStrategyOptions<TResult> Namespace Polly.Hedging Assembly Polly.Core.dll Hedging strategy options. public class HedgingStrategyOptions<TResult> : ResilienceStrategyOptions Type Parameters TResult The type of result these hedging options handle. Inheritance object ResilienceStrategyOptions HedgingStrategyOptions<TResult> Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HedgingStrategyOptions() Initializes a new instance of the HedgingStrategyOptions<TResult> class. public HedgingStrategyOptions() Properties ActionGenerator Gets or sets a generator that creates hedged actions. [Required] public Func<HedgingActionGeneratorArguments<TResult>, Func<ValueTask<Outcome<TResult>>>?> ActionGenerator { get; set; } Property Value Func<HedgingActionGeneratorArguments<TResult>, Func<ValueTask<Outcome<TResult>>>> The default generator executes the original callback that was passed to the hedging resilience strategy. This property is required. Delay Gets or sets the maximum waiting time before spawning a new hedged action. public TimeSpan Delay { get; set; } Property Value TimeSpan The default value is 2 seconds. Remarks You can use Zero to create all hedged actions (value of MaxHedgedAttempts) at once or InfiniteTimeSpan to force the hedging strategy to never create new action before the old one is finished. If you want a greater control over hedging delay customization use DelayGenerator. DelayGenerator Gets or sets a generator that generates hedging delays for each hedging action. public Func<HedgingDelayGeneratorArguments, ValueTask<TimeSpan>>? DelayGenerator { get; set; } Property Value Func<HedgingDelayGeneratorArguments, ValueTask<TimeSpan>> The default value is null. Remarks The DelayGenerator takes precedence over Delay. If specified, the Delay is ignored. MaxHedgedAttempts Gets or sets the maximum number of hedged actions to use, in addition to the original action. [Range(1, 10)] public int MaxHedgedAttempts { get; set; } Property Value int The default value is 1. The value must be bigger or equal to 1, and lower or equal to 10. OnHedging Gets or sets the event that is raised when a hedging is performed. public Func<OnHedgingArguments<TResult>, ValueTask>? OnHedging { get; set; } Property Value Func<OnHedgingArguments<TResult>, ValueTask> The default value is null. Remarks The hedging is executed when the current attempt outcome is not successful and the ShouldHandle predicate returns true or when the current attempt did not finish within the Delay. ShouldHandle Gets or sets a predicate that determines whether the hedging should be executed for a given outcome. [Required] public Func<HedgingPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } Property Value Func<HedgingPredicateArguments<TResult>, ValueTask<bool>> The default value is a predicate that hedges on any exception except OperationCanceledException. This property is required."
  },
  "api/Polly.Hedging.OnHedgingArguments-1.html": {
    "href": "api/Polly.Hedging.OnHedgingArguments-1.html",
    "title": "Struct OnHedgingArguments<TResult> | Polly",
    "keywords": "Struct OnHedgingArguments<TResult> Namespace Polly.Hedging Assembly Polly.Core.dll Represents arguments used by the on-hedging event. public readonly struct OnHedgingArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks The PrimaryContext represents the context that was received by the hedging strategy and used to execute the primary action. To prevent race conditions, the hedging strategy then clones the primary context into ActionContext and uses it to execute the hedged action. Every hedged action gets its own context that is cloned from the primary. Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnHedgingArguments(ResilienceContext, ResilienceContext, int) Initializes a new instance of the OnHedgingArguments<TResult> struct. public OnHedgingArguments(ResilienceContext primaryContext, ResilienceContext actionContext, int attemptNumber) Parameters primaryContext ResilienceContext The primary context received by the hedging strategy. actionContext ResilienceContext The action context. cloned from the primary context. attemptNumber int The zero-based hedging attempt number. Properties ActionContext Gets the action context that will be used for the hedged action. public ResilienceContext ActionContext { get; } Property Value ResilienceContext Remarks This context is cloned from PrimaryContext. AttemptNumber Gets the zero-based hedging attempt number. public int AttemptNumber { get; } Property Value int PrimaryContext Gets the primary resilience context as received by the hedging strategy. public ResilienceContext PrimaryContext { get; } Property Value ResilienceContext"
  },
  "api/Polly.Hedging.html": {
    "href": "api/Polly.Hedging.html",
    "title": "Namespace Polly.Hedging | Polly",
    "keywords": "Namespace Polly.Hedging Classes HedgingStrategyOptions<TResult> Hedging strategy options. Structs HedgingActionGeneratorArguments<TResult> Represents arguments used in the hedging resilience strategy. HedgingDelayGeneratorArguments Arguments used by hedging delay generator. HedgingPredicateArguments<TResult> Represents arguments used in hedging handling scenarios. OnHedgingArguments<TResult> Represents arguments used by the on-hedging event."
  },
  "api/Polly.HedgingResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.HedgingResiliencePipelineBuilderExtensions.html",
    "title": "Class HedgingResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class HedgingResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for adding hedging to ResiliencePipelineBuilder. public static class HedgingResiliencePipelineBuilderExtensions Inheritance object HedgingResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddHedging<TResult>(ResiliencePipelineBuilder<TResult>, HedgingStrategyOptions<TResult>) Adds a hedging with the provided options to the builder. public static ResiliencePipelineBuilder<TResult> AddHedging<TResult>(this ResiliencePipelineBuilder<TResult> builder, HedgingStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The resilience pipeline builder. options HedgingStrategyOptions<TResult> The options to configure the hedging. Returns ResiliencePipelineBuilder<TResult> The builder instance with the hedging added. Type Parameters TResult The result type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid."
  },
  "api/Polly.Outcome-1.html": {
    "href": "api/Polly.Outcome-1.html",
    "title": "Struct Outcome<TResult> | Polly",
    "keywords": "Struct Outcome<TResult> Namespace Polly Assembly Polly.Core.dll Represents the outcome of an operation which could be a result of type TResult or an exception. public readonly struct Outcome<TResult> Type Parameters TResult The result type of the operation. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Properties Exception Gets the exception that occurred during the operation, if any. public Exception? Exception { get; } Property Value Exception Result Gets the result of the operation, if any. public TResult? Result { get; } Property Value TResult Methods ThrowIfException() Throws an exception if the operation produced an exception. public void ThrowIfException() Remarks If the operation produced a result, this method does nothing. The thrown exception maintains its original stack trace. ToString() Returns the string representation of the outcome. public override string ToString() Returns string The exception message if the outcome is an exception; otherwise, the string representation of the result."
  },
  "api/Polly.Outcome.html": {
    "href": "api/Polly.Outcome.html",
    "title": "Class Outcome | Polly",
    "keywords": "Class Outcome Namespace Polly Assembly Polly.Core.dll Produces instances of Outcome<TResult>. public static class Outcome Inheritance object Outcome Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods FromExceptionAsValueTask<TResult>(Exception) Returns a Outcome<TResult> with the given exception wrapped as ValueTask<TResult>. public static ValueTask<Outcome<TResult>> FromExceptionAsValueTask<TResult>(Exception exception) Parameters exception Exception The exception. Returns ValueTask<Outcome<TResult>> A completed ValueTask<TResult> that produces Outcome<TResult>. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when exception is null. FromException<TResult>(Exception) Returns a Outcome<TResult> with the given exception. public static Outcome<TResult> FromException<TResult>(Exception exception) Parameters exception Exception The exception. Returns Outcome<TResult> An instance of Outcome<TResult>. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when exception is null. FromResultAsValueTask<TResult>(TResult) Returns a Outcome<TResult> with the given value wrapped as ValueTask<TResult>. public static ValueTask<Outcome<TResult>> FromResultAsValueTask<TResult>(TResult value) Parameters value TResult The result value. Returns ValueTask<Outcome<TResult>> A completed ValueTask<TResult> that produces Outcome<TResult>. Type Parameters TResult The type of the result. FromResult<TResult>(TResult?) Returns a Outcome<TResult> with the given value. public static Outcome<TResult> FromResult<TResult>(TResult? value) Parameters value TResult The result value. Returns Outcome<TResult> An instance of Outcome<TResult>. Type Parameters TResult The type of the result."
  },
  "api/Polly.PollyServiceCollectionExtensions.html": {
    "href": "api/Polly.PollyServiceCollectionExtensions.html",
    "title": "Class PollyServiceCollectionExtensions | Polly",
    "keywords": "Class PollyServiceCollectionExtensions Namespace Polly Assembly Polly.Extensions.dll Provides extension methods for registering resilience pipelines using the IServiceCollection. public static class PollyServiceCollectionExtensions Inheritance object PollyServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddResiliencePipelineRegistry<TKey>(IServiceCollection) Adds ResiliencePipelineRegistry<TKey> and ResiliencePipelineProvider<TKey> to the service collection that allows configuring and retrieving resilience pipelines using the TKey key. public static IServiceCollection AddResiliencePipelineRegistry<TKey>(this IServiceCollection services) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. Returns IServiceCollection The updated IServiceCollection with additional services added. Type Parameters TKey The type of the key used to identify the resilience pipeline. Remarks This call enables telemetry for all resilience pipelines created using ResiliencePipelineRegistry<TKey>. Exceptions ArgumentNullException Thrown when services is null. AddResiliencePipelineRegistry<TKey>(IServiceCollection, Action<ResiliencePipelineRegistryOptions<TKey>>) Adds ResiliencePipelineRegistry<TKey> and ResiliencePipelineProvider<TKey> to the service collection that allows configuring and retrieving resilience pipelines using the TKey key. public static IServiceCollection AddResiliencePipelineRegistry<TKey>(this IServiceCollection services, Action<ResiliencePipelineRegistryOptions<TKey>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. configure Action<ResiliencePipelineRegistryOptions<TKey>> The action that configures the ResiliencePipelineRegistryOptions<TKey> that are used by the registry. Returns IServiceCollection The updated IServiceCollection with additional services added. Type Parameters TKey The type of the key used to identify the resilience pipeline. Remarks This call enables telemetry for all resilience pipelines created using ResiliencePipelineRegistry<TKey>. Exceptions ArgumentNullException Thrown when services is null. AddResiliencePipeline<TKey>(IServiceCollection, TKey, Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>>) Adds a resilience pipeline to service collection. public static IServiceCollection AddResiliencePipeline<TKey>(this IServiceCollection services, TKey key, Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder, AddResiliencePipelineContext<TKey>> An action that configures the resilience pipeline. Returns IServiceCollection The updated IServiceCollection with the registered resilience pipeline. Type Parameters TKey The type of the key used to identify the resilience pipeline. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables the telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null. AddResiliencePipeline<TKey>(IServiceCollection, TKey, Action<ResiliencePipelineBuilder>) Adds a resilience pipeline to service collection. public static IServiceCollection AddResiliencePipeline<TKey>(this IServiceCollection services, TKey key, Action<ResiliencePipelineBuilder> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder> An action that configures the resilience pipeline. Returns IServiceCollection The updated IServiceCollection with the registered resilience pipeline. Type Parameters TKey The type of the key used to identify the resilience pipeline. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables the telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null. AddResiliencePipeline<TKey, TResult>(IServiceCollection, TKey, Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>>) Adds a resilience pipeline that handles TResult to service collection. public static IServiceCollection AddResiliencePipeline<TKey, TResult>(this IServiceCollection services, TKey key, Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>, AddResiliencePipelineContext<TKey>> An action that configures the resilience pipeline. Returns IServiceCollection The updated IServiceCollection with the registered resilience pipeline. Type Parameters TKey The type of the key used to identify the resilience pipeline. TResult The type of result that the resilience pipeline handles. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables the telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null. AddResiliencePipeline<TKey, TResult>(IServiceCollection, TKey, Action<ResiliencePipelineBuilder<TResult>>) Adds a resilience pipeline that handles TResult to service collection. public static IServiceCollection AddResiliencePipeline<TKey, TResult>(this IServiceCollection services, TKey key, Action<ResiliencePipelineBuilder<TResult>> configure) where TKey : notnull Parameters services IServiceCollection The IServiceCollection to add the resilience pipeline to. key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>> An action that configures the resilience pipeline. Returns IServiceCollection The updated IServiceCollection with the registered resilience pipeline. Type Parameters TKey The type of the key used to identify the resilience pipeline. TResult The type of result that the resilience pipeline handles. Remarks You can retrieve the registered pipeline by resolving the ResiliencePipelineProvider<TKey> class from the dependency injection container. This call enables the telemetry for the registered resilience pipeline. Exceptions ArgumentNullException Thrown when services or configure is null."
  },
  "api/Polly.PredicateBuilder-1.html": {
    "href": "api/Polly.PredicateBuilder-1.html",
    "title": "Class PredicateBuilder<TResult> | Polly",
    "keywords": "Class PredicateBuilder<TResult> Namespace Polly Assembly Polly.Core.dll Defines a builder for creating predicates for TResult and Exception combinations. public class PredicateBuilder<TResult> Type Parameters TResult The type of the result. Inheritance object PredicateBuilder<TResult> Derived PredicateBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Build() Builds the predicate. public Predicate<Outcome<TResult>> Build() Returns Predicate<Outcome<TResult>> An instance of predicate delegate. Remarks The returned predicate will return true if any of the configured predicates return true. Please be aware of the performance penalty if you register too many predicates with this builder. In such case, it's better to create your own predicate manually as a delegate. Exceptions InvalidOperationException Thrown when no predicates were configured using this builder. HandleInner<TException>() Adds a predicate for handling inner exceptions of the specified type. public PredicateBuilder<TResult> HandleInner<TException>() where TException : Exception Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Type Parameters TException The type of the inner exception to handle. HandleInner<TException>(Func<TException, bool>) Adds a predicate for handling inner exceptions of the specified type. public PredicateBuilder<TResult> HandleInner<TException>(Func<TException, bool> predicate) where TException : Exception Parameters predicate Func<TException, bool> The predicate function to use for handling the inner exception. Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Type Parameters TException The type of the inner exception to handle. Exceptions ArgumentNullException Thrown when the predicate is null. HandleResult(Func<TResult, bool>) Adds a predicate for handling results. public PredicateBuilder<TResult> HandleResult(Func<TResult, bool> predicate) Parameters predicate Func<TResult, bool> The predicate function to use for handling the result. Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. HandleResult(TResult, IEqualityComparer<TResult>?) Adds a predicate for handling results with a specific value. public PredicateBuilder<TResult> HandleResult(TResult result, IEqualityComparer<TResult>? comparer = null) Parameters result TResult The result value to handle. comparer IEqualityComparer<TResult> The comparer to use for comparing results. If null , the default comparer is used. Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Handle<TException>() Adds a predicate for handling exceptions of the specified type. public PredicateBuilder<TResult> Handle<TException>() where TException : Exception Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Type Parameters TException The type of the exception to handle. Handle<TException>(Func<TException, bool>) Adds a predicate for handling exceptions of the specified type. public PredicateBuilder<TResult> Handle<TException>(Func<TException, bool> predicate) where TException : Exception Parameters predicate Func<TException, bool> The predicate function to use for handling the exception. Returns PredicateBuilder<TResult> The same instance of the PredicateBuilder<TResult> for chaining. Type Parameters TException The type of the exception to handle. Exceptions ArgumentNullException Thrown when the predicate is null."
  },
  "api/Polly.PredicateBuilder.html": {
    "href": "api/Polly.PredicateBuilder.html",
    "title": "Class PredicateBuilder | Polly",
    "keywords": "Class PredicateBuilder Namespace Polly Assembly Polly.Core.dll Defines a builder for creating exception predicates. public sealed class PredicateBuilder : PredicateBuilder<object> Inheritance object PredicateBuilder<object> PredicateBuilder Inherited Members PredicateBuilder<object>.Handle<TException>() PredicateBuilder<object>.Handle<TException>(Func<TException, bool>) PredicateBuilder<object>.HandleInner<TException>() PredicateBuilder<object>.HandleInner<TException>(Func<TException, bool>) PredicateBuilder<object>.HandleResult(Func<object, bool>) PredicateBuilder<object>.HandleResult(object, IEqualityComparer<object>) PredicateBuilder<object>.Build() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Polly.PredicateResult.html": {
    "href": "api/Polly.PredicateResult.html",
    "title": "Class PredicateResult | Polly",
    "keywords": "Class PredicateResult Namespace Polly Assembly Polly.Core.dll Class that represents the results that can be used in predicates. public static class PredicateResult Inheritance object PredicateResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods False() Returns a finished ValueTask<TResult> that returns false value. public static ValueTask<bool> False() Returns ValueTask<bool> A new instance of finished ValueTask<TResult>. True() Returns a finished ValueTask<TResult> that returns true value. public static ValueTask<bool> True() Returns ValueTask<bool> A new instance of finished ValueTask<TResult>."
  },
  "api/Polly.RateLimiterResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.RateLimiterResiliencePipelineBuilderExtensions.html",
    "title": "Class RateLimiterResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class RateLimiterResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.RateLimiting.dll Extensions for adding rate limiting to ResiliencePipelineBuilder. public static class RateLimiterResiliencePipelineBuilderExtensions Inheritance object RateLimiterResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddConcurrencyLimiter<TBuilder>(TBuilder, int, int) Adds the concurrency limiter. public static TBuilder AddConcurrencyLimiter<TBuilder>(this TBuilder builder, int permitLimit, int queueLimit = 0) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. permitLimit int Maximum number of permits that can be leased concurrently. queueLimit int Maximum number of permits that can be queued concurrently. Returns TBuilder The builder instance with the concurrency limiter added. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder is null. ValidationException Thrown when the options constructed from the arguments are invalid. ArgumentException Thrown when permitLimit or queueLimit is invalid. AddConcurrencyLimiter<TBuilder>(TBuilder, ConcurrencyLimiterOptions) Adds the concurrency limiter. public static TBuilder AddConcurrencyLimiter<TBuilder>(this TBuilder builder, ConcurrencyLimiterOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options ConcurrencyLimiterOptions The concurrency limiter options. Returns TBuilder The builder instance with the concurrency limiter added. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when the options constructed from the arguments are invalid. ArgumentException Thrown when options are invalid. AddRateLimiter<TBuilder>(TBuilder, RateLimiterStrategyOptions) Adds the rate limiter. public static TBuilder AddRateLimiter<TBuilder>(this TBuilder builder, RateLimiterStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options RateLimiterStrategyOptions The rate limiter options. Returns TBuilder The builder instance with the rate limiter added. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. ArgumentException Thrown when DefaultRateLimiterOptions for options are invalid. AddRateLimiter<TBuilder>(TBuilder, RateLimiter) Adds the rate limiter. public static TBuilder AddRateLimiter<TBuilder>(this TBuilder builder, RateLimiter limiter) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. limiter RateLimiter The rate limiter to use. Returns TBuilder The builder instance with the rate limiter added. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or limiter is null. ValidationException Thrown when the options constructed from the arguments are invalid."
  },
  "api/Polly.RateLimiting.OnRateLimiterRejectedArguments.html": {
    "href": "api/Polly.RateLimiting.OnRateLimiterRejectedArguments.html",
    "title": "Struct OnRateLimiterRejectedArguments | Polly",
    "keywords": "Struct OnRateLimiterRejectedArguments Namespace Polly.RateLimiting Assembly Polly.RateLimiting.dll The arguments used by the OnRejected. public readonly struct OnRateLimiterRejectedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnRateLimiterRejectedArguments(ResilienceContext, RateLimitLease) Initializes a new instance of the OnRateLimiterRejectedArguments struct. public OnRateLimiterRejectedArguments(ResilienceContext context, RateLimitLease lease) Parameters context ResilienceContext The context associated with the execution of a user-provided callback. lease RateLimitLease The lease that has no permits and was rejected by the rate limiter. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext Lease Gets the lease that has no permits and was rejected by the rate limiter. public RateLimitLease Lease { get; } Property Value RateLimitLease"
  },
  "api/Polly.RateLimiting.RateLimiterArguments.html": {
    "href": "api/Polly.RateLimiting.RateLimiterArguments.html",
    "title": "Struct RateLimiterArguments | Polly",
    "keywords": "Struct RateLimiterArguments Namespace Polly.RateLimiting Assembly Polly.RateLimiting.dll The arguments used by the RateLimiter delegate. public readonly struct RateLimiterArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors RateLimiterArguments(ResilienceContext) Initializes a new instance of the RateLimiterArguments struct. public RateLimiterArguments(ResilienceContext context) Parameters context ResilienceContext Context associated with the execution of a user-provided callback. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.RateLimiting.RateLimiterRejectedException.html": {
    "href": "api/Polly.RateLimiting.RateLimiterRejectedException.html",
    "title": "Class RateLimiterRejectedException | Polly",
    "keywords": "Class RateLimiterRejectedException Namespace Polly.RateLimiting Assembly Polly.RateLimiting.dll Exception thrown when a rate limiter rejects an execution. public sealed class RateLimiterRejectedException : ExecutionRejectedException, ISerializable Inheritance object Exception ExecutionRejectedException RateLimiterRejectedException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite object.Equals(object) object.Equals(object, object) object.GetHashCode() object.ReferenceEquals(object, object) Constructors RateLimiterRejectedException() Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException() RateLimiterRejectedException(string) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(string message) Parameters message string The message that describes the error. RateLimiterRejectedException(string, Exception) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(string message, Exception inner) Parameters message string The message that describes the error. inner Exception The inner exception. RateLimiterRejectedException(string, TimeSpan) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(string message, TimeSpan retryAfter) Parameters message string The message that describes the error. retryAfter TimeSpan The retry after value. RateLimiterRejectedException(string, TimeSpan, Exception) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(string message, TimeSpan retryAfter, Exception inner) Parameters message string The message that describes the error. retryAfter TimeSpan The retry after value. inner Exception The inner exception. RateLimiterRejectedException(TimeSpan) Initializes a new instance of the RateLimiterRejectedException class. public RateLimiterRejectedException(TimeSpan retryAfter) Parameters retryAfter TimeSpan The retry after value. Properties RetryAfter Gets the amount of time to wait before retrying again. public TimeSpan? RetryAfter { get; } Property Value TimeSpan? Remarks This value was retrieved from the RateLimitLease by reading the RetryAfter. Defaults to null."
  },
  "api/Polly.RateLimiting.RateLimiterStrategyOptions.html": {
    "href": "api/Polly.RateLimiting.RateLimiterStrategyOptions.html",
    "title": "Class RateLimiterStrategyOptions | Polly",
    "keywords": "Class RateLimiterStrategyOptions Namespace Polly.RateLimiting Assembly Polly.RateLimiting.dll Options for the rate limiter strategy. public class RateLimiterStrategyOptions : ResilienceStrategyOptions Inheritance object ResilienceStrategyOptions RateLimiterStrategyOptions Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RateLimiterStrategyOptions() Initializes a new instance of the RateLimiterStrategyOptions class. public RateLimiterStrategyOptions() Properties DefaultRateLimiterOptions Gets or sets the default rate limiter options. [Required] public ConcurrencyLimiterOptions DefaultRateLimiterOptions { get; set; } Property Value ConcurrencyLimiterOptions Remarks The options for the default limiter that will be used when RateLimiter is null. PermitLimit defaults to 1000. QueueLimit defaults to 0. OnRejected Gets or sets an event that is raised when the execution of user-provided callback is rejected by the rate limiter. public Func<OnRateLimiterRejectedArguments, ValueTask>? OnRejected { get; set; } Property Value Func<OnRateLimiterRejectedArguments, ValueTask> The default value is null. RateLimiter Gets or sets a rate limiter delegate that produces RateLimitLease. public Func<RateLimiterArguments, ValueTask<RateLimitLease>>? RateLimiter { get; set; } Property Value Func<RateLimiterArguments, ValueTask<RateLimitLease>> The default value is null. If this property is null, then the strategy will use a ConcurrencyLimiter created using DefaultRateLimiterOptions."
  },
  "api/Polly.RateLimiting.html": {
    "href": "api/Polly.RateLimiting.html",
    "title": "Namespace Polly.RateLimiting | Polly",
    "keywords": "Namespace Polly.RateLimiting Classes RateLimiterRejectedException Exception thrown when a rate limiter rejects an execution. RateLimiterStrategyOptions Options for the rate limiter strategy. Structs OnRateLimiterRejectedArguments The arguments used by the OnRejected. RateLimiterArguments The arguments used by the RateLimiter delegate."
  },
  "api/Polly.Registry.ConfigureBuilderContext-1.html": {
    "href": "api/Polly.Registry.ConfigureBuilderContext-1.html",
    "title": "Class ConfigureBuilderContext<TKey> | Polly",
    "keywords": "Class ConfigureBuilderContext<TKey> Namespace Polly.Registry Assembly Polly.Core.dll The context used by ResiliencePipelineRegistry<TKey>. public class ConfigureBuilderContext<TKey> where TKey : notnull Type Parameters TKey The type of the key. Inheritance object ConfigureBuilderContext<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties PipelineKey Gets the pipeline key for the pipeline being created. public TKey PipelineKey { get; } Property Value TKey Methods AddReloadToken(CancellationToken) Reloads the pipeline when cancellationToken is canceled. public void AddReloadToken(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken The cancellation token that triggers the pipeline reload when cancelled. Remarks You can add multiple reload tokens to the context. Non-cancelable or already canceled tokens are ignored. OnPipelineDisposed(Action) Registers a callback that is called when the pipeline instance being configured is disposed. public void OnPipelineDisposed(Action callback) Parameters callback Action The callback delegate."
  },
  "api/Polly.Registry.ConfigureBuilderContextExtensions.html": {
    "href": "api/Polly.Registry.ConfigureBuilderContextExtensions.html",
    "title": "Class ConfigureBuilderContextExtensions | Polly",
    "keywords": "Class ConfigureBuilderContextExtensions Namespace Polly.Registry Assembly Polly.Extensions.dll Extensions for ConfigureBuilderContext<TKey>. public static class ConfigureBuilderContextExtensions Inheritance object ConfigureBuilderContextExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods EnableReloads<TKey, TOptions>(ConfigureBuilderContext<TKey>, IOptionsMonitor<TOptions>, string?) Enables dynamic reloading of the resilience pipeline whenever the TOptions options are changed. public static void EnableReloads<TKey, TOptions>(this ConfigureBuilderContext<TKey> context, IOptionsMonitor<TOptions> optionsMonitor, string? name = null) where TKey : notnull Parameters context ConfigureBuilderContext<TKey> The builder context. optionsMonitor IOptionsMonitor<TOptions> The options monitor. name string The named options, if any. Type Parameters TKey The type of the key used to identify the resilience pipeline. TOptions The options type to listen to. Remarks You can decide based on the name to listen for changes in global options or named options. If name is null then the global options are listened to. You can listen for changes from multiple options by calling this method with different TOptions types."
  },
  "api/Polly.Registry.ResiliencePipelineProvider-1.html": {
    "href": "api/Polly.Registry.ResiliencePipelineProvider-1.html",
    "title": "Class ResiliencePipelineProvider<TKey> | Polly",
    "keywords": "Class ResiliencePipelineProvider<TKey> Namespace Polly.Registry Assembly Polly.Core.dll Represents a provider for resilience pipelines that are accessible by TKey. public abstract class ResiliencePipelineProvider<TKey> where TKey : notnull Type Parameters TKey The type of the key. Inheritance object ResiliencePipelineProvider<TKey> Derived ResiliencePipelineRegistry<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetPipeline(TKey) Retrieves a resilience pipeline from the provider using the specified key. public virtual ResiliencePipeline GetPipeline(TKey key) Parameters key TKey The key used to identify the resilience pipeline. Returns ResiliencePipeline The resilience pipeline associated with the specified key. Exceptions KeyNotFoundException Thrown when no resilience pipeline is found for the specified key. GetPipeline<TResult>(TKey) Retrieves a generic resilience pipeline from the provider using the specified key. public virtual ResiliencePipeline<TResult> GetPipeline<TResult>(TKey key) Parameters key TKey The key used to identify the resilience pipeline. Returns ResiliencePipeline<TResult> The resilience pipeline associated with the specified key. Type Parameters TResult The type of result that the resilience pipeline handles. Exceptions KeyNotFoundException Thrown when no resilience pipeline is found for the specified key. TryGetPipeline(TKey, out ResiliencePipeline?) Tries to get a resilience pipeline from the provider using the specified key. public abstract bool TryGetPipeline(TKey key, out ResiliencePipeline? pipeline) Parameters key TKey The key used to identify the resilience pipeline. pipeline ResiliencePipeline The output resilience pipeline if found, null otherwise. Returns bool true if the pipeline was found, false otherwise. TryGetPipeline<TResult>(TKey, out ResiliencePipeline<TResult>?) Tries to get a generic resilience pipeline from the provider using the specified key. public abstract bool TryGetPipeline<TResult>(TKey key, out ResiliencePipeline<TResult>? pipeline) Parameters key TKey The key used to identify the resilience pipeline. pipeline ResiliencePipeline<TResult> The output resilience pipeline if found, null otherwise. Returns bool true if the pipeline was found, false otherwise. Type Parameters TResult The type of result that the resilience pipeline handles."
  },
  "api/Polly.Registry.ResiliencePipelineRegistry-1.html": {
    "href": "api/Polly.Registry.ResiliencePipelineRegistry-1.html",
    "title": "Class ResiliencePipelineRegistry<TKey> | Polly",
    "keywords": "Class ResiliencePipelineRegistry<TKey> Namespace Polly.Registry Assembly Polly.Core.dll Represents a registry of resilience pipelines and builders that are accessible by TKey. public sealed class ResiliencePipelineRegistry<TKey> : ResiliencePipelineProvider<TKey>, IDisposable, IAsyncDisposable where TKey : notnull Type Parameters TKey The type of the key. Inheritance object ResiliencePipelineProvider<TKey> ResiliencePipelineRegistry<TKey> Implements IDisposable IAsyncDisposable Inherited Members ResiliencePipelineProvider<TKey>.GetPipeline(TKey) ResiliencePipelineProvider<TKey>.GetPipeline<TResult>(TKey) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks This class provides a way to organize and manage multiple resilience pipelines using keys of type TKey. Additionally, it allows registration of callbacks that configure the pipeline using ResiliencePipelineBuilder. These callbacks are called when the resilience pipeline is not yet cached and it's retrieved for the first time. Constructors ResiliencePipelineRegistry() Initializes a new instance of the ResiliencePipelineRegistry<TKey> class with the default comparer. public ResiliencePipelineRegistry() ResiliencePipelineRegistry(ResiliencePipelineRegistryOptions<TKey>) Initializes a new instance of the ResiliencePipelineRegistry<TKey> class with a custom builder factory and comparer. public ResiliencePipelineRegistry(ResiliencePipelineRegistryOptions<TKey> options) Parameters options ResiliencePipelineRegistryOptions<TKey> The registry options. Exceptions ValidationException Thrown when options are invalid. ArgumentNullException Thrown when options are null. Methods Dispose() Disposes all resources that are held by the resilience pipelines created by this builder. public void Dispose() Remarks After the disposal, all resilience pipelines still used outside of the builder are disposed and cannot be used anymore. DisposeAsync() Disposes all resources that are held by the resilience pipelines created by this builder. public ValueTask DisposeAsync() Returns ValueTask Returns a task that represents the asynchronous dispose operation. Remarks After the disposal, all resilience pipelines still used outside of the builder are disposed and cannot be used anymore. GetOrAddPipeline(TKey, Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>>) Gets existing pipeline or creates a new one using the configure callback. public ResiliencePipeline GetOrAddPipeline(TKey key, Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>> The callback that configures the pipeline builder. Returns ResiliencePipeline An instance of pipeline. Exceptions ObjectDisposedException Thrown when the registry is already disposed. GetOrAddPipeline(TKey, Action<ResiliencePipelineBuilder>) Gets existing pipeline or creates a new one using the configure callback. public ResiliencePipeline GetOrAddPipeline(TKey key, Action<ResiliencePipelineBuilder> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder> The callback that configures the pipeline builder. Returns ResiliencePipeline An instance of pipeline. Exceptions ObjectDisposedException Thrown when the registry is already disposed. GetOrAddPipeline<TResult>(TKey, Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>>) Gets existing pipeline or creates a new one using the configure callback. public ResiliencePipeline<TResult> GetOrAddPipeline<TResult>(TKey key, Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>> The callback that configures the pipeline builder. Returns ResiliencePipeline<TResult> An instance of pipeline. Type Parameters TResult The type of result that the resilience pipeline handles. Exceptions ObjectDisposedException Thrown when the registry is already disposed. GetOrAddPipeline<TResult>(TKey, Action<ResiliencePipelineBuilder<TResult>>) Gets existing pipeline or creates a new one using the configure callback. public ResiliencePipeline<TResult> GetOrAddPipeline<TResult>(TKey key, Action<ResiliencePipelineBuilder<TResult>> configure) Parameters key TKey The key used to identify the resilience pipeline. configure Action<ResiliencePipelineBuilder<TResult>> The callback that configures the pipeline builder. Returns ResiliencePipeline<TResult> An instance of pipeline. Type Parameters TResult The type of result that the resilience pipeline handles. Exceptions ObjectDisposedException Thrown when the registry is already disposed. TryAddBuilder(TKey, Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>>) Tries to add a resilience pipeline builder to the registry. public bool TryAddBuilder(TKey key, Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>> configure) Parameters key TKey The key used to identify the pipeline builder. configure Action<ResiliencePipelineBuilder, ConfigureBuilderContext<TKey>> The action that configures the resilience pipeline builder. Returns bool true if the builder was added successfully, false otherwise. Remarks Use this method when you want to create the pipeline on-demand when it's first accessed. Exceptions ArgumentNullException Thrown when configure is null. ObjectDisposedException Thrown when the registry is already disposed. TryAddBuilder<TResult>(TKey, Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>>) Tries to add a generic resilience pipeline builder to the registry. public bool TryAddBuilder<TResult>(TKey key, Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>> configure) Parameters key TKey The key used to identify the pipeline builder. configure Action<ResiliencePipelineBuilder<TResult>, ConfigureBuilderContext<TKey>> The action that configures the resilience pipeline builder. Returns bool true if the builder was added successfully, false otherwise. Type Parameters TResult The type of result that the resilience pipeline handles. Remarks Use this method when you want to create the pipeline on-demand when it's first accessed. Exceptions ArgumentNullException Thrown when configure is null. ObjectDisposedException Thrown when the registry is already disposed. TryGetPipeline(TKey, out ResiliencePipeline?) Tries to get a resilience pipeline from the provider using the specified key. public override bool TryGetPipeline(TKey key, out ResiliencePipeline? pipeline) Parameters key TKey The key used to identify the resilience pipeline. pipeline ResiliencePipeline The output resilience pipeline if found, null otherwise. Returns bool true if the pipeline was found, false otherwise. TryGetPipeline<TResult>(TKey, out ResiliencePipeline<TResult>?) Tries to get a generic resilience pipeline from the provider using the specified key. public override bool TryGetPipeline<TResult>(TKey key, out ResiliencePipeline<TResult>? pipeline) Parameters key TKey The key used to identify the resilience pipeline. pipeline ResiliencePipeline<TResult> The output resilience pipeline if found, null otherwise. Returns bool true if the pipeline was found, false otherwise. Type Parameters TResult The type of result that the resilience pipeline handles."
  },
  "api/Polly.Registry.ResiliencePipelineRegistryOptions-1.html": {
    "href": "api/Polly.Registry.ResiliencePipelineRegistryOptions-1.html",
    "title": "Class ResiliencePipelineRegistryOptions<TKey> | Polly",
    "keywords": "Class ResiliencePipelineRegistryOptions<TKey> Namespace Polly.Registry Assembly Polly.Core.dll An options class used by ResiliencePipelineRegistry<TKey>. public class ResiliencePipelineRegistryOptions<TKey> Type Parameters TKey The type of the key used by the registry. Inheritance object ResiliencePipelineRegistryOptions<TKey> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties BuilderComparer Gets or sets the comparer that is used by the registry to retrieve the resilience pipeline builders. [Required] public IEqualityComparer<TKey> BuilderComparer { get; set; } Property Value IEqualityComparer<TKey> The default value is Default. BuilderFactory Gets or sets the factory method that creates instances of ResiliencePipelineBuilder. [Required] public Func<ResiliencePipelineBuilder> BuilderFactory { get; set; } Property Value Func<ResiliencePipelineBuilder> The default value is a function that creates a new instance of ResiliencePipelineBuilder using the default constructor. BuilderNameFormatter Gets or sets the formatter that is used by the registry to format the TKey to a string that represents the builder name. [Required] public Func<TKey, string> BuilderNameFormatter { get; set; } Property Value Func<TKey, string> The default value is a formatter that formats the keys using the ToString() method. Remarks Use custom formatter for composite keys in case you want to have different metric values for a builder and strategy key. In general, pipelines can have the same builder name and different pipeline keys. InstanceNameFormatter Gets or sets the formatter that is used by the registry to format the TKey to a string that represents the instance name of the builder. public Func<TKey, string>? InstanceNameFormatter { get; set; } Property Value Func<TKey, string> The default value is null. Remarks Use custom formatter for composite keys in case you want to have different metric values for a builder and instance key. In general, pipelines can have the same builder name and different instance names. PipelineComparer Gets or sets the comparer that is used by the registry to retrieve the resilience pipelines. [Required] public IEqualityComparer<TKey> PipelineComparer { get; set; } Property Value IEqualityComparer<TKey> The default value is Default."
  },
  "api/Polly.Registry.html": {
    "href": "api/Polly.Registry.html",
    "title": "Namespace Polly.Registry | Polly",
    "keywords": "Namespace Polly.Registry Classes ConfigureBuilderContextExtensions Extensions for ConfigureBuilderContext<TKey>. ConfigureBuilderContext<TKey> The context used by ResiliencePipelineRegistry<TKey>. ResiliencePipelineProvider<TKey> Represents a provider for resilience pipelines that are accessible by TKey. ResiliencePipelineRegistryOptions<TKey> An options class used by ResiliencePipelineRegistry<TKey>. ResiliencePipelineRegistry<TKey> Represents a registry of resilience pipelines and builders that are accessible by TKey."
  },
  "api/Polly.ResilienceContext.html": {
    "href": "api/Polly.ResilienceContext.html",
    "title": "Class ResilienceContext | Polly",
    "keywords": "Class ResilienceContext Namespace Polly Assembly Polly.Core.dll A context assigned to a single execution of ResiliencePipeline. It is created manually or automatically when the user calls the various extensions on top of ResiliencePipeline. After every execution the context should be discarded and returned to the pool. public sealed class ResilienceContext Inheritance object ResilienceContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Do not re-use an instance of ResilienceContext across more than one execution. The ResilienceContext is retrieved from the pool by calling the Get(CancellationToken) method. After you are done with it you should return it to the pool by calling the Return(ResilienceContext) method. Properties CancellationToken Gets the CancellationToken associated with the execution. public CancellationToken CancellationToken { get; } Property Value CancellationToken ContinueOnCapturedContext Gets a value indicating whether the execution should continue on the captured context. public bool ContinueOnCapturedContext { get; } Property Value bool OperationKey Gets a key unique to the call site of the current execution. public string? OperationKey { get; } Property Value string The default value is null. Remarks Resilience context instances are commonly reused across multiple call sites. Set an OperationKey so that logging and metrics can distinguish usages of policy instances at different call sites. The operation key value should have a low cardinality (i.e. do not assign values such as Guid to this property). Properties Gets the custom properties attached to the context. public ResilienceProperties Properties { get; } Property Value ResilienceProperties"
  },
  "api/Polly.ResilienceContextCreationArguments.html": {
    "href": "api/Polly.ResilienceContextCreationArguments.html",
    "title": "Struct ResilienceContextCreationArguments | Polly",
    "keywords": "Struct ResilienceContextCreationArguments Namespace Polly Assembly Polly.Core.dll Arguments used by the ResilienceContextPool when creating ResilienceContext. public readonly struct ResilienceContextCreationArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ResilienceContextCreationArguments(string?, bool?, CancellationToken) Initializes a new instance of the ResilienceContextCreationArguments struct. public ResilienceContextCreationArguments(string? operationKey, bool? continueOnCapturedContext, CancellationToken cancellationToken) Parameters operationKey string The operation key, if any. continueOnCapturedContext bool? Value indicating whether to continue on captured context. cancellationToken CancellationToken The cancellation token. Properties CancellationToken Gets the cancellation token. public CancellationToken CancellationToken { get; } Property Value CancellationToken ContinueOnCapturedContext Gets the value indicating whether to continue on captured context, if any. public bool? ContinueOnCapturedContext { get; } Property Value bool? OperationKey Gets the operation key, if any. public string? OperationKey { get; } Property Value string"
  },
  "api/Polly.ResilienceContextPool.html": {
    "href": "api/Polly.ResilienceContextPool.html",
    "title": "Class ResilienceContextPool | Polly",
    "keywords": "Class ResilienceContextPool Namespace Polly Assembly Polly.Core.dll The pool of ResilienceContext instances. public abstract class ResilienceContextPool Inheritance object ResilienceContextPool Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Shared Gets the shared pool instance. public static ResilienceContextPool Shared { get; } Property Value ResilienceContextPool Methods Get(ResilienceContextCreationArguments) Gets a ResilienceContext instance from the pool. public abstract ResilienceContext Get(ResilienceContextCreationArguments arguments) Parameters arguments ResilienceContextCreationArguments The creation arguments. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Get(bool, CancellationToken) Gets a ResilienceContext instance from the pool. public ResilienceContext Get(bool continueOnCapturedContext, CancellationToken cancellationToken = default) Parameters continueOnCapturedContext bool Value indicating whether to continue on captured context. cancellationToken CancellationToken The cancellation token. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Get(string?, bool?, CancellationToken) Gets a ResilienceContext instance from the pool. public ResilienceContext Get(string? operationKey, bool? continueOnCapturedContext, CancellationToken cancellationToken = default) Parameters operationKey string An operation key associated with the context. continueOnCapturedContext bool? Value indicating whether to continue on captured context. cancellationToken CancellationToken The cancellation token. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Get(string?, CancellationToken) Gets a ResilienceContext instance from the pool. public ResilienceContext Get(string? operationKey, CancellationToken cancellationToken = default) Parameters operationKey string An operation key associated with the context. cancellationToken CancellationToken The cancellation token. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Get(CancellationToken) Gets a ResilienceContext instance from the pool. public ResilienceContext Get(CancellationToken cancellationToken = default) Parameters cancellationToken CancellationToken The cancellation token. Returns ResilienceContext An instance of ResilienceContext. Remarks After the execution is finished you should return the ResilienceContext back to the pool by calling Return(ResilienceContext) method. Return(ResilienceContext) Returns a context back to the pool. public abstract void Return(ResilienceContext context) Parameters context ResilienceContext The context instance. Exceptions ArgumentNullException Thrown when context is null."
  },
  "api/Polly.ResiliencePipeline-1.html": {
    "href": "api/Polly.ResiliencePipeline-1.html",
    "title": "Class ResiliencePipeline<T> | Polly",
    "keywords": "Class ResiliencePipeline<T> Namespace Polly Assembly Polly.Core.dll Resilience pipeline is used to execute the user-provided callbacks. public sealed class ResiliencePipeline<T> Type Parameters T The type of result this pipeline supports. Inheritance object ResiliencePipeline<T> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Resilience pipeline supports various types of callbacks of T result type and provides a unified way to execute them. This includes overloads for synchronous and asynchronous callbacks. Fields Empty Resilience pipeline that executes the user-provided callback without any additional logic. public static readonly ResiliencePipeline<T> Empty Field Value ResiliencePipeline<T> Methods ExecuteAsync<TResult>(Func<ResilienceContext, ValueTask<TResult>>, ResilienceContext) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult>(Func<ResilienceContext, ValueTask<TResult>> callback, ResilienceContext context) where TResult : T Parameters callback Func<ResilienceContext, ValueTask<TResult>> The user-provided callback. context ResilienceContext The context associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TResult>(Func<CancellationToken, ValueTask<TResult>>, CancellationToken) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult>(Func<CancellationToken, ValueTask<TResult>> callback, CancellationToken cancellationToken = default) where TResult : T Parameters callback Func<CancellationToken, ValueTask<TResult>> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<TResult>>, ResilienceContext, TState) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<TResult>> callback, ResilienceContext context, TState state) where TResult : T Parameters callback Func<ResilienceContext, TState, ValueTask<TResult>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TResult, TState>(Func<TState, CancellationToken, ValueTask<TResult>>, TState, CancellationToken) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult, TState>(Func<TState, CancellationToken, ValueTask<TResult>> callback, TState state, CancellationToken cancellationToken = default) where TResult : T Parameters callback Func<TState, CancellationToken, ValueTask<TResult>> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteOutcomeAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) Executes the specified outcome-based callback. public ValueTask<Outcome<TResult>> ExecuteOutcomeAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) where TResult : T Parameters callback Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<Outcome<TResult>> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Remarks This method is for advanced and high performance scenarios. The caller must make sure that the callback does not throw any exceptions. Instead, it converts them to Outcome<TResult>. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult>(Func<ResilienceContext, TResult>, ResilienceContext) Executes the specified callback. public TResult Execute<TResult>(Func<ResilienceContext, TResult> callback, ResilienceContext context) where TResult : T Parameters callback Func<ResilienceContext, TResult> The user-provided callback. context ResilienceContext The context associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult>(Func<CancellationToken, TResult>, CancellationToken) Executes the specified callback. public TResult Execute<TResult>(Func<CancellationToken, TResult> callback, CancellationToken cancellationToken = default) where TResult : T Parameters callback Func<CancellationToken, TResult> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult>(Func<TResult>) Executes the specified callback. public TResult Execute<TResult>(Func<TResult> callback) where TResult : T Parameters callback Func<TResult> The user-provided callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult, TState>(Func<ResilienceContext, TState, TResult>, ResilienceContext, TState) Executes the specified callback. public TResult Execute<TResult, TState>(Func<ResilienceContext, TState, TResult> callback, ResilienceContext context, TState state) where TResult : T Parameters callback Func<ResilienceContext, TState, TResult> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult, TState>(Func<TState, CancellationToken, TResult>, TState, CancellationToken) Executes the specified callback. public TResult Execute<TResult, TState>(Func<TState, CancellationToken, TResult> callback, TState state, CancellationToken cancellationToken = default) where TResult : T Parameters callback Func<TState, CancellationToken, TResult> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult, TState>(Func<TState, TResult>, TState) Executes the specified callback. public TResult Execute<TResult, TState>(Func<TState, TResult> callback, TState state) where TResult : T Parameters callback Func<TState, TResult> The user-provided callback. state TState The state associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of the result. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null."
  },
  "api/Polly.ResiliencePipeline.html": {
    "href": "api/Polly.ResiliencePipeline.html",
    "title": "Class ResiliencePipeline | Polly",
    "keywords": "Class ResiliencePipeline Namespace Polly Assembly Polly.Core.dll Resilience pipeline is used to execute the user-provided callbacks. public sealed class ResiliencePipeline Inheritance object ResiliencePipeline Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks Resilience pipeline supports various types of callbacks and provides a unified way to execute them. This includes overloads for synchronous and asynchronous callbacks, generic and non-generic callbacks. Fields Empty Resilience pipeline that executes the user-provided callback without any additional logic. public static readonly ResiliencePipeline Empty Field Value ResiliencePipeline Methods Execute(Action) Executes the specified callback. public void Execute(Action callback) Parameters callback Action The user-provided callback. Exceptions ArgumentNullException Thrown when callback is null. Execute(Action<ResilienceContext>, ResilienceContext) Executes the specified callback. public void Execute(Action<ResilienceContext> callback, ResilienceContext context) Parameters callback Action<ResilienceContext> The user-provided callback. context ResilienceContext The context associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute(Action<CancellationToken>, CancellationToken) Executes the specified callback. public void Execute(Action<CancellationToken> callback, CancellationToken cancellationToken = default) Parameters callback Action<CancellationToken> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync(Func<ResilienceContext, ValueTask>, ResilienceContext) Executes the specified callback. public ValueTask ExecuteAsync(Func<ResilienceContext, ValueTask> callback, ResilienceContext context) Parameters callback Func<ResilienceContext, ValueTask> The user-provided callback. context ResilienceContext The context associated with the callback. Returns ValueTask The instance of ValueTask that represents the asynchronous execution. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync(Func<CancellationToken, ValueTask>, CancellationToken) Executes the specified callback. public ValueTask ExecuteAsync(Func<CancellationToken, ValueTask> callback, CancellationToken cancellationToken = default) Parameters callback Func<CancellationToken, ValueTask> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask The instance of ValueTask that represents an asynchronous callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync<TResult>(Func<ResilienceContext, ValueTask<TResult>>, ResilienceContext) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult>(Func<ResilienceContext, ValueTask<TResult>> callback, ResilienceContext context) Parameters callback Func<ResilienceContext, ValueTask<TResult>> The user-provided callback. context ResilienceContext The context associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TState>(Func<ResilienceContext, TState, ValueTask>, ResilienceContext, TState) Executes the specified callback. public ValueTask ExecuteAsync<TState>(Func<ResilienceContext, TState, ValueTask> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask The instance of ValueTask that represents the asynchronous execution. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TResult>(Func<CancellationToken, ValueTask<TResult>>, CancellationToken) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult>(Func<CancellationToken, ValueTask<TResult>> callback, CancellationToken cancellationToken = default) Parameters callback Func<CancellationToken, ValueTask<TResult>> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync<TState>(Func<TState, CancellationToken, ValueTask>, TState, CancellationToken) Executes the specified callback. public ValueTask ExecuteAsync<TState>(Func<TState, CancellationToken, ValueTask> callback, TState state, CancellationToken cancellationToken = default) Parameters callback Func<TState, CancellationToken, ValueTask> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask The instance of ValueTask that represents an asynchronous callback. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<TResult>>, ResilienceContext, TState) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<TResult>> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask<TResult>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. ExecuteAsync<TResult, TState>(Func<TState, CancellationToken, ValueTask<TResult>>, TState, CancellationToken) Executes the specified callback. public ValueTask<TResult> ExecuteAsync<TResult, TState>(Func<TState, CancellationToken, ValueTask<TResult>> callback, TState state, CancellationToken cancellationToken = default) Parameters callback Func<TState, CancellationToken, ValueTask<TResult>> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns ValueTask<TResult> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. ExecuteOutcomeAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) Executes the specified outcome-based callback. public ValueTask<Outcome<TResult>> ExecuteOutcomeAsync<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<Outcome<TResult>> The instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Remarks This method is for advanced and high performance scenarios. The caller must make sure that the callback does not throw any exceptions. Instead, it converts them to Outcome<TResult>. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TState>(Action<ResilienceContext, TState>, ResilienceContext, TState) Executes the specified callback. public void Execute<TState>(Action<ResilienceContext, TState> callback, ResilienceContext context, TState state) Parameters callback Action<ResilienceContext, TState> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TState>(Action<TState, CancellationToken>, TState, CancellationToken) Executes the specified callback. public void Execute<TState>(Action<TState, CancellationToken> callback, TState state, CancellationToken cancellationToken = default) Parameters callback Action<TState, CancellationToken> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TState>(Action<TState>, TState) Executes the specified callback. public void Execute<TState>(Action<TState> callback, TState state) Parameters callback Action<TState> The user-provided callback. state TState The state associated with the callback. Type Parameters TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult>(Func<ResilienceContext, TResult>, ResilienceContext) Executes the specified callback. public TResult Execute<TResult>(Func<ResilienceContext, TResult> callback, ResilienceContext context) Parameters callback Func<ResilienceContext, TResult> The user-provided callback. context ResilienceContext The context associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult>(Func<CancellationToken, TResult>, CancellationToken) Executes the specified callback. public TResult Execute<TResult>(Func<CancellationToken, TResult> callback, CancellationToken cancellationToken = default) Parameters callback Func<CancellationToken, TResult> The user-provided callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult>(Func<TResult>) Executes the specified callback. public TResult Execute<TResult>(Func<TResult> callback) Parameters callback Func<TResult> The user-provided callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult, TState>(Func<ResilienceContext, TState, TResult>, ResilienceContext, TState) Executes the specified callback. public TResult Execute<TResult, TState>(Func<ResilienceContext, TState, TResult> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, TResult> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback or context is null. Execute<TResult, TState>(Func<TState, CancellationToken, TResult>, TState, CancellationToken) Executes the specified callback. public TResult Execute<TResult, TState>(Func<TState, CancellationToken, TResult> callback, TState state, CancellationToken cancellationToken = default) Parameters callback Func<TState, CancellationToken, TResult> The user-provided callback. state TState The state associated with the callback. cancellationToken CancellationToken The CancellationToken associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null. Execute<TResult, TState>(Func<TState, TResult>, TState) Executes the specified callback. public TResult Execute<TResult, TState>(Func<TState, TResult> callback, TState state) Parameters callback Func<TState, TResult> The user-provided callback. state TState The state associated with the callback. Returns TResult An instance of ValueTask that represents the asynchronous execution. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Exceptions ArgumentNullException Thrown when callback is null."
  },
  "api/Polly.ResiliencePipelineBuilder-1.html": {
    "href": "api/Polly.ResiliencePipelineBuilder-1.html",
    "title": "Class ResiliencePipelineBuilder<TResult> | Polly",
    "keywords": "Class ResiliencePipelineBuilder<TResult> Namespace Polly Assembly Polly.Core.dll A builder that is used to create an instance of ResiliencePipeline<T>. public sealed class ResiliencePipelineBuilder<TResult> : ResiliencePipelineBuilderBase Type Parameters TResult The type of result to handle. Inheritance object ResiliencePipelineBuilderBase ResiliencePipelineBuilder<TResult> Inherited Members ResiliencePipelineBuilderBase.Name ResiliencePipelineBuilderBase.InstanceName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods CircuitBreakerResiliencePipelineBuilderExtensions.AddCircuitBreaker<TResult>(ResiliencePipelineBuilder<TResult>, CircuitBreakerStrategyOptions<TResult>) FallbackResiliencePipelineBuilderExtensions.AddFallback<TResult>(ResiliencePipelineBuilder<TResult>, FallbackStrategyOptions<TResult>) HedgingResiliencePipelineBuilderExtensions.AddHedging<TResult>(ResiliencePipelineBuilder<TResult>, HedgingStrategyOptions<TResult>) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, int, int) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, ConcurrencyLimiterOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiterStrategyOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiter) ResiliencePipelineBuilderExtensions.AddPipeline<TBuilder>(TBuilder, ResiliencePipeline) ResiliencePipelineBuilderExtensions.AddPipeline<TResult>(ResiliencePipelineBuilder<TResult>, ResiliencePipeline<TResult>) ResiliencePipelineBuilderExtensions.AddStrategy<TResult>(ResiliencePipelineBuilder<TResult>, Func<StrategyBuilderContext, ResilienceStrategy<TResult>>, ResilienceStrategyOptions) ResiliencePipelineBuilderExtensions.AddStrategy<TBuilder>(TBuilder, Func<StrategyBuilderContext, ResilienceStrategy>, ResilienceStrategyOptions) RetryResiliencePipelineBuilderExtensions.AddRetry<TResult>(ResiliencePipelineBuilder<TResult>, RetryStrategyOptions<TResult>) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeoutStrategyOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeSpan) Remarks The builder supports combining multiple strategies into a pipeline of resilience strategies. The resulting instance of ResiliencePipeline<T> created by the Build() call will execute the strategies in the same order they were added to the builder. The order of the strategies is important. Constructors ResiliencePipelineBuilder() Initializes a new instance of the ResiliencePipelineBuilder<TResult> class. public ResiliencePipelineBuilder() Methods Build() Builds the resilience pipeline. public ResiliencePipeline<TResult> Build() Returns ResiliencePipeline<TResult> An instance of ResiliencePipeline<T>. Exceptions ValidationException Thrown when this builder has invalid configuration."
  },
  "api/Polly.ResiliencePipelineBuilder.html": {
    "href": "api/Polly.ResiliencePipelineBuilder.html",
    "title": "Class ResiliencePipelineBuilder | Polly",
    "keywords": "Class ResiliencePipelineBuilder Namespace Polly Assembly Polly.Core.dll A builder that is used to create an instance of ResiliencePipeline. public sealed class ResiliencePipelineBuilder : ResiliencePipelineBuilderBase Inheritance object ResiliencePipelineBuilderBase ResiliencePipelineBuilder Inherited Members ResiliencePipelineBuilderBase.Name ResiliencePipelineBuilderBase.InstanceName object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods CircuitBreakerResiliencePipelineBuilderExtensions.AddCircuitBreaker(ResiliencePipelineBuilder, CircuitBreakerStrategyOptions) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, int, int) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, ConcurrencyLimiterOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiterStrategyOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiter) ResiliencePipelineBuilderExtensions.AddPipeline<TBuilder>(TBuilder, ResiliencePipeline) ResiliencePipelineBuilderExtensions.AddStrategy(ResiliencePipelineBuilder, Func<StrategyBuilderContext, ResilienceStrategy<object>>, ResilienceStrategyOptions) ResiliencePipelineBuilderExtensions.AddStrategy<TBuilder>(TBuilder, Func<StrategyBuilderContext, ResilienceStrategy>, ResilienceStrategyOptions) RetryResiliencePipelineBuilderExtensions.AddRetry(ResiliencePipelineBuilder, RetryStrategyOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeoutStrategyOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeSpan) Remarks The builder supports combining multiple strategies into a pipeline of resilience strategies. The resulting instance of ResiliencePipeline created by the Build() call executes the strategies in the same order they were added to the builder. The order of the strategies is important. Methods Build() Builds the resilience pipeline. public ResiliencePipeline Build() Returns ResiliencePipeline An instance of ResiliencePipeline. Exceptions ValidationException Thrown when this builder has invalid configuration."
  },
  "api/Polly.ResiliencePipelineBuilderBase.html": {
    "href": "api/Polly.ResiliencePipelineBuilderBase.html",
    "title": "Class ResiliencePipelineBuilderBase | Polly",
    "keywords": "Class ResiliencePipelineBuilderBase Namespace Polly Assembly Polly.Core.dll A builder that is used to create an instance of ResiliencePipeline. public abstract class ResiliencePipelineBuilderBase Inheritance object ResiliencePipelineBuilderBase Derived ResiliencePipelineBuilder ResiliencePipelineBuilder<TResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, int, int) RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(TBuilder, ConcurrencyLimiterOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiterStrategyOptions) RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(TBuilder, RateLimiter) ResiliencePipelineBuilderExtensions.AddPipeline<TBuilder>(TBuilder, ResiliencePipeline) ResiliencePipelineBuilderExtensions.AddStrategy<TBuilder>(TBuilder, Func<StrategyBuilderContext, ResilienceStrategy>, ResilienceStrategyOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeoutStrategyOptions) TimeoutResiliencePipelineBuilderExtensions.AddTimeout<TBuilder>(TBuilder, TimeSpan) Remarks The builder supports combining multiple strategies into a pipeline of resilience strategies. The resulting instance of ResiliencePipeline executes the strategies in the same order they were added to the builder. The order of the strategies is important. Properties InstanceName Gets or sets the instance name of the builder. public string? InstanceName { get; set; } Property Value string The default value is null. Remarks This property is also included in the telemetry that is produced by the individual resilience strategies. The instance name can be used to differentiate between multiple builder instances with the same Name. Name Gets or sets the name of the builder. public string? Name { get; set; } Property Value string The default value is null. Remarks This property is also included in the telemetry that is produced by the individual resilience strategies."
  },
  "api/Polly.ResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.ResiliencePipelineBuilderExtensions.html",
    "title": "Class ResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class ResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for ResiliencePipelineBuilderBase. public static class ResiliencePipelineBuilderExtensions Inheritance object ResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddPipeline<TResult>(ResiliencePipelineBuilder<TResult>, ResiliencePipeline<TResult>) Adds an already created pipeline instance to the builder. public static ResiliencePipelineBuilder<TResult> AddPipeline<TResult>(this ResiliencePipelineBuilder<TResult> builder, ResiliencePipeline<TResult> pipeline) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. pipeline ResiliencePipeline<TResult> The pipeline instance. Returns ResiliencePipelineBuilder<TResult> The same builder instance. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when pipeline is null. InvalidOperationException Thrown when this builder was already used to create a strategy. The builder cannot be modified after it has been used. AddPipeline<TBuilder>(TBuilder, ResiliencePipeline) Adds an already created pipeline instance to the builder. public static TBuilder AddPipeline<TBuilder>(this TBuilder builder, ResiliencePipeline pipeline) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. pipeline ResiliencePipeline The pipeline instance. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when pipeline is null. InvalidOperationException Thrown when this builder was already used to create a pipeline. The builder cannot be modified after it has been used. AddStrategy(ResiliencePipelineBuilder, Func<StrategyBuilderContext, ResilienceStrategy<object>>, ResilienceStrategyOptions) Adds a reactive strategy to the builder. public static ResiliencePipelineBuilder AddStrategy(this ResiliencePipelineBuilder builder, Func<StrategyBuilderContext, ResilienceStrategy<object>> factory, ResilienceStrategyOptions options) Parameters builder ResiliencePipelineBuilder The builder instance. factory Func<StrategyBuilderContext, ResilienceStrategy<object>> The factory that creates a resilience strategy. options ResilienceStrategyOptions The options associated with the strategy. If none are provided the default instance of ResilienceStrategyOptions is created. Returns ResiliencePipelineBuilder The same builder instance. Exceptions ArgumentNullException Thrown when builder, factory or options is null. InvalidOperationException Thrown when this builder was already used to create a pipeline. The builder cannot be modified after it has been used. ValidationException Thrown when options is invalid. AddStrategy<TResult>(ResiliencePipelineBuilder<TResult>, Func<StrategyBuilderContext, ResilienceStrategy<TResult>>, ResilienceStrategyOptions) Adds a reactive strategy to the builder. public static ResiliencePipelineBuilder<TResult> AddStrategy<TResult>(this ResiliencePipelineBuilder<TResult> builder, Func<StrategyBuilderContext, ResilienceStrategy<TResult>> factory, ResilienceStrategyOptions options) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. factory Func<StrategyBuilderContext, ResilienceStrategy<TResult>> The factory that creates a resilience strategy. options ResilienceStrategyOptions The options associated with the strategy. If none are provided the default instance of ResilienceStrategyOptions is created. Returns ResiliencePipelineBuilder<TResult> The same builder instance. Type Parameters TResult The type of the result. Exceptions ArgumentNullException Thrown when builder, factory or options is null. InvalidOperationException Thrown when this builder was already used to create a pipeline. The builder cannot be modified after it has been used. ValidationException Thrown when options is invalid. AddStrategy<TBuilder>(TBuilder, Func<StrategyBuilderContext, ResilienceStrategy>, ResilienceStrategyOptions) Adds a proactive resilience strategy to the builder. public static TBuilder AddStrategy<TBuilder>(this TBuilder builder, Func<StrategyBuilderContext, ResilienceStrategy> factory, ResilienceStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. factory Func<StrategyBuilderContext, ResilienceStrategy> The factory that creates a resilience strategy. options ResilienceStrategyOptions The options associated with the strategy. If none are provided the default instance of ResilienceStrategyOptions is created. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder, factory or options is null. InvalidOperationException Thrown when this builder was already used to create a pipeline. The builder cannot be modified after it has been used. ValidationException Thrown when options is invalid."
  },
  "api/Polly.ResilienceProperties.html": {
    "href": "api/Polly.ResilienceProperties.html",
    "title": "Class ResilienceProperties | Polly",
    "keywords": "Class ResilienceProperties Namespace Polly Assembly Polly.Core.dll Represents a collection of custom resilience properties. public sealed class ResilienceProperties Inheritance object ResilienceProperties Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Methods GetValue<TValue>(ResiliencePropertyKey<TValue>, TValue) Gets the value of a given property with a fallback default value. public TValue GetValue<TValue>(ResiliencePropertyKey<TValue> key, TValue defaultValue) Parameters key ResiliencePropertyKey<TValue> Strongly typed key to get the value of the property. defaultValue TValue The default value to use if property is not found. Returns TValue The property value or the default value. Type Parameters TValue The type of property value as defined by key parameter. Set<TValue>(ResiliencePropertyKey<TValue>, TValue) Sets the value of a given property. public void Set<TValue>(ResiliencePropertyKey<TValue> key, TValue value) Parameters key ResiliencePropertyKey<TValue> Strongly typed key to get the value of the property. value TValue Returns the value of the property. Type Parameters TValue The type of property value as defined by key parameter. TryGetValue<TValue>(ResiliencePropertyKey<TValue>, out TValue) Gets the value of a given property. public bool TryGetValue<TValue>(ResiliencePropertyKey<TValue> key, out TValue value) Parameters key ResiliencePropertyKey<TValue> Strongly typed key to get the value of the property. value TValue Returns the value of the property. Returns bool True, if a property was retrieved. Type Parameters TValue The type of property value as defined by key parameter."
  },
  "api/Polly.ResiliencePropertyKey-1.html": {
    "href": "api/Polly.ResiliencePropertyKey-1.html",
    "title": "Struct ResiliencePropertyKey<TValue> | Polly",
    "keywords": "Struct ResiliencePropertyKey<TValue> Namespace Polly Assembly Polly.Core.dll Represents a key used by ResilienceProperties. public readonly struct ResiliencePropertyKey<TValue> Type Parameters TValue The type of the value of the property. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors ResiliencePropertyKey(string) Initializes a new instance of the ResiliencePropertyKey<TValue> struct. public ResiliencePropertyKey(string key) Parameters key string The key name. Properties Key Gets the name of the key. public string Key { get; } Property Value string Methods ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name."
  },
  "api/Polly.ResilienceStrategy-1.html": {
    "href": "api/Polly.ResilienceStrategy-1.html",
    "title": "Class ResilienceStrategy<TResult> | Polly",
    "keywords": "Class ResilienceStrategy<TResult> Namespace Polly Assembly Polly.Core.dll This base strategy class is used to simplify the implementation of generic (reactive) strategies by limiting the number of generic types the execute method receives. public abstract class ResilienceStrategy<TResult> Type Parameters TResult The type of result this strategy handles. Inheritance object ResilienceStrategy<TResult> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks For strategies that handle all result types the generic parameter must be of type object. Methods ExecuteCore<TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) An implementation of a reactive resilience strategy that executes the specified callback. protected abstract ValueTask<Outcome<TResult>> ExecuteCore<TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<Outcome<TResult>> An instance of a pending ValueTask for asynchronous executions or a completed ValueTask task for synchronous executions. Type Parameters TState The type of state associated with the callback. Remarks The provided callback never throws an exception. Instead, the exception is captured and converted to an Outcome<TResult>. Similarly, do not throw exceptions from your strategy implementation. Instead, return an exception instance as Outcome<TResult>."
  },
  "api/Polly.ResilienceStrategy.html": {
    "href": "api/Polly.ResilienceStrategy.html",
    "title": "Class ResilienceStrategy | Polly",
    "keywords": "Class ResilienceStrategy Namespace Polly Assembly Polly.Core.dll Base class for all proactive resilience strategies. public abstract class ResilienceStrategy Inheritance object ResilienceStrategy Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ExecuteCore<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>>, ResilienceContext, TState) An implementation of a proactive resilience strategy that executes the specified callback. protected abstract ValueTask<Outcome<TResult>> ExecuteCore<TResult, TState>(Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) Parameters callback Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> The user-provided callback. context ResilienceContext The context associated with the callback. state TState The state associated with the callback. Returns ValueTask<Outcome<TResult>> An instance of a pending ValueTask for asynchronous executions or a completed ValueTask task for synchronous executions. Type Parameters TResult The type of result returned by the callback. TState The type of state associated with the callback. Remarks The provided callback never throws an exception. Instead, the exception is captured and converted to an Outcome<TResult>. Similarly, do not throw exceptions from your strategy implementation. Instead, return an exception instance as Outcome<TResult>."
  },
  "api/Polly.ResilienceStrategyOptions.html": {
    "href": "api/Polly.ResilienceStrategyOptions.html",
    "title": "Class ResilienceStrategyOptions | Polly",
    "keywords": "Class ResilienceStrategyOptions Namespace Polly Assembly Polly.Core.dll The options associated with the individual resilience strategy. public abstract class ResilienceStrategyOptions Inheritance object ResilienceStrategyOptions Derived CircuitBreakerStrategyOptions<TResult> FallbackStrategyOptions<TResult> HedgingStrategyOptions<TResult> RateLimiterStrategyOptions RetryStrategyOptions<TResult> TimeoutStrategyOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Name Gets or sets the name of the strategy. public string? Name { get; set; } Property Value string The default value is null. Remarks This name uniquely identifies a particular instance of a specific strategy and is also included in the telemetry that is produced by the individual resilience strategies."
  },
  "api/Polly.Retry.OnRetryArguments-1.html": {
    "href": "api/Polly.Retry.OnRetryArguments-1.html",
    "title": "Struct OnRetryArguments<TResult> | Polly",
    "keywords": "Struct OnRetryArguments<TResult> Namespace Polly.Retry Assembly Polly.Core.dll Represents the arguments used by OnRetry for handling the retry event. public readonly struct OnRetryArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnRetryArguments(ResilienceContext, Outcome<TResult>, int, TimeSpan, TimeSpan) Initializes a new instance of the OnRetryArguments<TResult> struct. public OnRetryArguments(ResilienceContext context, Outcome<TResult> outcome, int attemptNumber, TimeSpan retryDelay, TimeSpan duration) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. attemptNumber int The zero-based attempt number. retryDelay TimeSpan The delay before the next retry. duration TimeSpan The duration of this attempt. Properties AttemptNumber Gets the zero-based attempt number. public int AttemptNumber { get; } Property Value int Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Duration Gets the duration of this attempt. public TimeSpan Duration { get; } Property Value TimeSpan Outcome Gets the outcome that will be retried. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult> RetryDelay Gets the delay before the next retry. public TimeSpan RetryDelay { get; } Property Value TimeSpan"
  },
  "api/Polly.Retry.RetryDelayGeneratorArguments-1.html": {
    "href": "api/Polly.Retry.RetryDelayGeneratorArguments-1.html",
    "title": "Struct RetryDelayGeneratorArguments<TResult> | Polly",
    "keywords": "Struct RetryDelayGeneratorArguments<TResult> Namespace Polly.Retry Assembly Polly.Core.dll Represents the arguments used by DelayGenerator for generating the next retry delay. public readonly struct RetryDelayGeneratorArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors RetryDelayGeneratorArguments(ResilienceContext, Outcome<TResult>, int) Initializes a new instance of the RetryDelayGeneratorArguments<TResult> struct. public RetryDelayGeneratorArguments(ResilienceContext context, Outcome<TResult> outcome, int attemptNumber) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. attemptNumber int The zero-based attempt number. Properties AttemptNumber Gets The zero-based attempt number. public int AttemptNumber { get; } Property Value int Context Gets the context in which the resilience operation or event occurred. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the resilience operation or event. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Retry.RetryPredicateArguments-1.html": {
    "href": "api/Polly.Retry.RetryPredicateArguments-1.html",
    "title": "Struct RetryPredicateArguments<TResult> | Polly",
    "keywords": "Struct RetryPredicateArguments<TResult> Namespace Polly.Retry Assembly Polly.Core.dll Represents the arguments used by ShouldHandle for determining whether a retry should be performed. public readonly struct RetryPredicateArguments<TResult> Type Parameters TResult The type of result. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors RetryPredicateArguments(ResilienceContext, Outcome<TResult>, int) Initializes a new instance of the RetryPredicateArguments<TResult> struct. public RetryPredicateArguments(ResilienceContext context, Outcome<TResult> outcome, int attemptNumber) Parameters context ResilienceContext The outcome of the resilience operation or event. outcome Outcome<TResult> The context in which the resilience operation or event occurred. attemptNumber int The zero-based attempt number. Properties AttemptNumber Gets the zero-based attempt number. public int AttemptNumber { get; } Property Value int Context Gets the context of this event. public ResilienceContext Context { get; } Property Value ResilienceContext Outcome Gets the outcome of the user-specified callback. public Outcome<TResult> Outcome { get; } Property Value Outcome<TResult>"
  },
  "api/Polly.Retry.RetryStrategyOptions-1.html": {
    "href": "api/Polly.Retry.RetryStrategyOptions-1.html",
    "title": "Class RetryStrategyOptions<TResult> | Polly",
    "keywords": "Class RetryStrategyOptions<TResult> Namespace Polly.Retry Assembly Polly.Core.dll Represents the options used to configure a retry strategy. public class RetryStrategyOptions<TResult> : ResilienceStrategyOptions Type Parameters TResult The type of result the retry strategy handles. Inheritance object ResilienceStrategyOptions RetryStrategyOptions<TResult> Derived RetryStrategyOptions Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RetryStrategyOptions() Initializes a new instance of the RetryStrategyOptions<TResult> class. public RetryStrategyOptions() Properties BackoffType Gets or sets the type of the back-off. public DelayBackoffType BackoffType { get; set; } Property Value DelayBackoffType The default value is Constant. Remarks This property is ignored when DelayGenerator is set. Delay Gets or sets the base delay between retries. [Range(typeof(TimeSpan), \"00:00:00\", \"1.00:00:00\")] public TimeSpan Delay { get; set; } Property Value TimeSpan The default value is 2 seconds. Remarks This value is used with the combination of BackoffType to generate the final delay for each individual retry attempt: Exponential: Represents the median delay to target before the first retry. Linear: Represents the initial delay, the following delays increasing linearly with this value. Constant Represents the constant delay between retries. This property is ignored when DelayGenerator is set. DelayGenerator Gets or sets a generator that calculates the delay between retries. public Func<RetryDelayGeneratorArguments<TResult>, ValueTask<TimeSpan?>>? DelayGenerator { get; set; } Property Value Func<RetryDelayGeneratorArguments<TResult>, ValueTask<TimeSpan?>> The default value is null. Remarks The generator can override the delay generated by the retry strategy. If the generator returns null, the delay generated by the retry strategy for that attempt will be used. MaxDelay Gets or sets the maximum delay between retries. [Range(typeof(TimeSpan), \"00:00:00\", \"1.00:00:00\")] public TimeSpan? MaxDelay { get; set; } Property Value TimeSpan? The default value is null. Remarks This property is used to cap the maximum delay between retries. It is useful when you want to limit the maximum delay after a certain number of retries when it could reach a unreasonably high values, especially if Exponential backoff is used. If not specified, the delay is not capped. This property is ignored for delays generated by DelayGenerator. MaxRetryAttempts Gets or sets the maximum number of retries to use, in addition to the original call. [Range(1, 2147483647)] public int MaxRetryAttempts { get; set; } Property Value int The default value is 3 retries. Remarks To retry indefinitely use MaxValue. Note that the reported attempt number is capped at MaxValue. OnRetry Gets or sets an event delegate that is raised when the retry happens. public Func<OnRetryArguments<TResult>, ValueTask>? OnRetry { get; set; } Property Value Func<OnRetryArguments<TResult>, ValueTask> The default value is null. Remarks After this event, the result produced the by user-callback is discarded and disposed to prevent resource over-consumption. If you need to preserve the result for further processing, create the copy of the result or extract and store all necessary information from the result within the event. ShouldHandle Gets or sets a predicate that determines whether the retry should be executed for a given outcome. [Required] public Func<RetryPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } Property Value Func<RetryPredicateArguments<TResult>, ValueTask<bool>> The default is a delegate that retries on any exception except OperationCanceledException. This property is required. UseJitter Gets or sets a value indicating whether jitter should be used when calculating the backoff delay between retries. public bool UseJitter { get; set; } Property Value bool The default value is false. Remarks See https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry#new-jitter-recommendation for more details on how jitter can improve the resilience when the retries are correlated."
  },
  "api/Polly.Retry.RetryStrategyOptions.html": {
    "href": "api/Polly.Retry.RetryStrategyOptions.html",
    "title": "Class RetryStrategyOptions | Polly",
    "keywords": "Class RetryStrategyOptions Namespace Polly.Retry Assembly Polly.Core.dll Represents the options used to configure a retry strategy. public class RetryStrategyOptions : RetryStrategyOptions<object> Inheritance object ResilienceStrategyOptions RetryStrategyOptions<object> RetryStrategyOptions Inherited Members RetryStrategyOptions<object>.MaxRetryAttempts RetryStrategyOptions<object>.BackoffType RetryStrategyOptions<object>.UseJitter RetryStrategyOptions<object>.Delay RetryStrategyOptions<object>.MaxDelay RetryStrategyOptions<object>.ShouldHandle RetryStrategyOptions<object>.DelayGenerator RetryStrategyOptions<object>.OnRetry ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/Polly.Retry.html": {
    "href": "api/Polly.Retry.html",
    "title": "Namespace Polly.Retry | Polly",
    "keywords": "Namespace Polly.Retry Classes RetryStrategyOptions Represents the options used to configure a retry strategy. RetryStrategyOptions<TResult> Represents the options used to configure a retry strategy. Structs OnRetryArguments<TResult> Represents the arguments used by OnRetry for handling the retry event. RetryDelayGeneratorArguments<TResult> Represents the arguments used by DelayGenerator for generating the next retry delay. RetryPredicateArguments<TResult> Represents the arguments used by ShouldHandle for determining whether a retry should be performed."
  },
  "api/Polly.RetryResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.RetryResiliencePipelineBuilderExtensions.html",
    "title": "Class RetryResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class RetryResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for adding retries to ResiliencePipelineBuilder. public static class RetryResiliencePipelineBuilderExtensions Inheritance object RetryResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddRetry(ResiliencePipelineBuilder, RetryStrategyOptions) Adds a retry to the builder. public static ResiliencePipelineBuilder AddRetry(this ResiliencePipelineBuilder builder, RetryStrategyOptions options) Parameters builder ResiliencePipelineBuilder The builder instance. options RetryStrategyOptions The retry options. Returns ResiliencePipelineBuilder The builder instance with the retry strategy added. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. AddRetry<TResult>(ResiliencePipelineBuilder<TResult>, RetryStrategyOptions<TResult>) Adds a retry to the builder. public static ResiliencePipelineBuilder<TResult> AddRetry<TResult>(this ResiliencePipelineBuilder<TResult> builder, RetryStrategyOptions<TResult> options) Parameters builder ResiliencePipelineBuilder<TResult> The builder instance. options RetryStrategyOptions<TResult> The retry options. Returns ResiliencePipelineBuilder<TResult> The builder instance with the retry added. Type Parameters TResult The type of result the retry handles. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid."
  },
  "api/Polly.StrategyBuilderContext.html": {
    "href": "api/Polly.StrategyBuilderContext.html",
    "title": "Class StrategyBuilderContext | Polly",
    "keywords": "Class StrategyBuilderContext Namespace Polly Assembly Polly.Core.dll The context used for building an individual resilience strategy. public sealed class StrategyBuilderContext Inheritance object StrategyBuilderContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Telemetry Gets the resilience telemetry used to report important events. public ResilienceStrategyTelemetry Telemetry { get; } Property Value ResilienceStrategyTelemetry"
  },
  "api/Polly.Telemetry.EnrichmentContext-2.html": {
    "href": "api/Polly.Telemetry.EnrichmentContext-2.html",
    "title": "Struct EnrichmentContext<TResult, TArgs> | Polly",
    "keywords": "Struct EnrichmentContext<TResult, TArgs> Namespace Polly.Telemetry Assembly Polly.Extensions.dll Enrichment context used when reporting resilience events. public readonly struct EnrichmentContext<TResult, TArgs> Type Parameters TResult The type of the result. TArgs The type of the arguments attached to the resilience event. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks This context is passed to enrichers in MeteringEnrichers. Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors EnrichmentContext(in TelemetryEventArguments<TResult, TArgs>, IList<KeyValuePair<string, object?>>) Initializes a new instance of the EnrichmentContext<TResult, TArgs> struct. public EnrichmentContext(in TelemetryEventArguments<TResult, TArgs> telemetryEvent, IList<KeyValuePair<string, object?>> tags) Parameters telemetryEvent TelemetryEventArguments<TResult, TArgs> The telemetry event info. tags IList<KeyValuePair<string, object>> Tags associated with the resilience event. Properties Tags Gets the tags associated with the resilience event. public IList<KeyValuePair<string, object?>> Tags { get; } Property Value IList<KeyValuePair<string, object>> Remarks Custom enricher can add tags to this collection. TelemetryEvent Gets the info about the telemetry event. public TelemetryEventArguments<TResult, TArgs> TelemetryEvent { get; } Property Value TelemetryEventArguments<TResult, TArgs>"
  },
  "api/Polly.Telemetry.ExecutionAttemptArguments.html": {
    "href": "api/Polly.Telemetry.ExecutionAttemptArguments.html",
    "title": "Struct ExecutionAttemptArguments | Polly",
    "keywords": "Struct ExecutionAttemptArguments Namespace Polly.Telemetry Assembly Polly.Core.dll Arguments that encapsulate the execution attempt for retries or hedging. public readonly struct ExecutionAttemptArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors ExecutionAttemptArguments(int, TimeSpan, bool) Initializes a new instance of the ExecutionAttemptArguments struct. public ExecutionAttemptArguments(int attemptNumber, TimeSpan duration, bool handled) Parameters attemptNumber int The execution attempt number. duration TimeSpan The execution duration. handled bool Determines whether the attempt was handled by the strategy. Properties AttemptNumber Gets the attempt number. public int AttemptNumber { get; } Property Value int Duration Gets the execution duration of the attempt. public TimeSpan Duration { get; } Property Value TimeSpan Handled Gets a value indicating whether the outcome was handled by retry or hedging strategy. public bool Handled { get; } Property Value bool"
  },
  "api/Polly.Telemetry.MeteringEnricher.html": {
    "href": "api/Polly.Telemetry.MeteringEnricher.html",
    "title": "Class MeteringEnricher | Polly",
    "keywords": "Class MeteringEnricher Namespace Polly.Telemetry Assembly Polly.Extensions.dll Enricher used to enrich the metrics with additional information. public abstract class MeteringEnricher Inheritance object MeteringEnricher Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs>) Enriches the metrics with additional information. public abstract void Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs> context) Parameters context EnrichmentContext<TResult, TArgs> The enrichment context. Type Parameters TResult The type of result. TArgs The type of arguments."
  },
  "api/Polly.Telemetry.PipelineExecutedArguments.html": {
    "href": "api/Polly.Telemetry.PipelineExecutedArguments.html",
    "title": "Struct PipelineExecutedArguments | Polly",
    "keywords": "Struct PipelineExecutedArguments Namespace Polly.Telemetry Assembly Polly.Core.dll Arguments that indicate the pipeline execution started. public readonly struct PipelineExecutedArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors PipelineExecutedArguments(TimeSpan) Initializes a new instance of the PipelineExecutedArguments struct. public PipelineExecutedArguments(TimeSpan duration) Parameters duration TimeSpan The pipeline execution duration. Properties Duration Gets the pipeline execution duration. public TimeSpan Duration { get; } Property Value TimeSpan"
  },
  "api/Polly.Telemetry.PipelineExecutingArguments.html": {
    "href": "api/Polly.Telemetry.PipelineExecutingArguments.html",
    "title": "Struct PipelineExecutingArguments | Polly",
    "keywords": "Struct PipelineExecutingArguments Namespace Polly.Telemetry Assembly Polly.Core.dll Arguments that indicate the pipeline execution started. public readonly struct PipelineExecutingArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility."
  },
  "api/Polly.Telemetry.ResilienceEvent.html": {
    "href": "api/Polly.Telemetry.ResilienceEvent.html",
    "title": "Struct ResilienceEvent | Polly",
    "keywords": "Struct ResilienceEvent Namespace Polly.Telemetry Assembly Polly.Core.dll Represents a resilience event that has been reported. public readonly struct ResilienceEvent Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors ResilienceEvent(ResilienceEventSeverity, string) Initializes a new instance of the ResilienceEvent struct. public ResilienceEvent(ResilienceEventSeverity severity, string eventName) Parameters severity ResilienceEventSeverity The severity of the event. eventName string The event name. Properties EventName Gets the event name. public string EventName { get; } Property Value string Severity Gets the severity of the event. public ResilienceEventSeverity Severity { get; } Property Value ResilienceEventSeverity Methods ToString() Returns an EventName. public override string ToString() Returns string An event name."
  },
  "api/Polly.Telemetry.ResilienceEventSeverity.html": {
    "href": "api/Polly.Telemetry.ResilienceEventSeverity.html",
    "title": "Enum ResilienceEventSeverity | Polly",
    "keywords": "Enum ResilienceEventSeverity Namespace Polly.Telemetry Assembly Polly.Core.dll The severity of reported resilience event. public enum ResilienceEventSeverity Fields Critical = 5 The resilience event should be treated as a critical error. Debug = 1 The resilience event is used for debugging purposes only. Error = 4 The resilience event should be treated as an error. Information = 2 The resilience event is informational. None = 0 The resilience event is not recorded. Warning = 3 The resilience event should be treated as a warning."
  },
  "api/Polly.Telemetry.ResilienceStrategyTelemetry.html": {
    "href": "api/Polly.Telemetry.ResilienceStrategyTelemetry.html",
    "title": "Class ResilienceStrategyTelemetry | Polly",
    "keywords": "Class ResilienceStrategyTelemetry Namespace Polly.Telemetry Assembly Polly.Core.dll Resilience telemetry is used by individual resilience strategies to report some important events. public sealed class ResilienceStrategyTelemetry Inheritance object ResilienceStrategyTelemetry Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks For example, the timeout strategy reports \"OnTimeout\" event when the timeout is reached or \"OnRetry\" for retry strategy. Methods Report<TArgs>(ResilienceEvent, ResilienceContext, TArgs) Reports an event that occurred in a resilience strategy. public void Report<TArgs>(ResilienceEvent resilienceEvent, ResilienceContext context, TArgs args) Parameters resilienceEvent ResilienceEvent The reported resilience event. context ResilienceContext The resilience context associated with this event. args TArgs The event arguments. Type Parameters TArgs The arguments associated with this event. Exceptions ArgumentNullException Thrown when context is null. Report<TArgs, TResult>(ResilienceEvent, ResilienceContext, Outcome<TResult>, TArgs) Reports an event that occurred in a resilience strategy. public void Report<TArgs, TResult>(ResilienceEvent resilienceEvent, ResilienceContext context, Outcome<TResult> outcome, TArgs args) Parameters resilienceEvent ResilienceEvent The reported resilience event. context ResilienceContext The resilience context associated with this event. outcome Outcome<TResult> The outcome associated with the event. args TArgs The event arguments. Type Parameters TArgs The arguments associated with this event. TResult The type of the result."
  },
  "api/Polly.Telemetry.ResilienceTelemetrySource.html": {
    "href": "api/Polly.Telemetry.ResilienceTelemetrySource.html",
    "title": "Class ResilienceTelemetrySource | Polly",
    "keywords": "Class ResilienceTelemetrySource Namespace Polly.Telemetry Assembly Polly.Core.dll The source of resilience telemetry events. public sealed class ResilienceTelemetrySource Inheritance object ResilienceTelemetrySource Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Remarks This class is used by the telemetry infrastructure and should not be used directly by user code. Constructors ResilienceTelemetrySource(string?, string?, string?) Initializes a new instance of the ResilienceTelemetrySource class. public ResilienceTelemetrySource(string? pipelineName, string? pipelineInstanceName, string? strategyName) Parameters pipelineName string The pipeline name. pipelineInstanceName string The pipeline instance name. strategyName string The strategy name. Properties PipelineInstanceName Gets the pipeline instance name. public string? PipelineInstanceName { get; } Property Value string PipelineName Gets the pipeline name. public string? PipelineName { get; } Property Value string StrategyName Gets the strategy name. public string? StrategyName { get; } Property Value string"
  },
  "api/Polly.Telemetry.TelemetryEventArguments-2.html": {
    "href": "api/Polly.Telemetry.TelemetryEventArguments-2.html",
    "title": "Struct TelemetryEventArguments<TResult, TArgs> | Polly",
    "keywords": "Struct TelemetryEventArguments<TResult, TArgs> Namespace Polly.Telemetry Assembly Polly.Core.dll Represents the information about the resilience event. public readonly struct TelemetryEventArguments<TResult, TArgs> Type Parameters TResult The type of result. TArgs The arguments associated with the resilience event. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors TelemetryEventArguments(ResilienceTelemetrySource, ResilienceEvent, ResilienceContext, TArgs, Outcome<TResult>?) Initializes a new instance of the TelemetryEventArguments<TResult, TArgs> struct. public TelemetryEventArguments(ResilienceTelemetrySource source, ResilienceEvent resilienceEvent, ResilienceContext context, TArgs args, Outcome<TResult>? outcome) Parameters source ResilienceTelemetrySource The source that produced the resilience event. resilienceEvent ResilienceEvent The resilience event. context ResilienceContext The context associated with the resilience event. args TArgs The arguments associated with the resilience event. outcome Outcome<TResult>? The outcome associated with the resilience event, if any. Properties Arguments Gets the arguments associated with the resilience event. public TArgs Arguments { get; } Property Value TArgs Context Gets the context associated with the resilience event. public ResilienceContext Context { get; } Property Value ResilienceContext Event Gets the resilience event. public ResilienceEvent Event { get; } Property Value ResilienceEvent Outcome Gets the outcome associated with the resilience event, if any. public Outcome<TResult>? Outcome { get; } Property Value Outcome<TResult>? Source Gets the source that produced the resilience event. public ResilienceTelemetrySource Source { get; } Property Value ResilienceTelemetrySource"
  },
  "api/Polly.Telemetry.TelemetryListener.html": {
    "href": "api/Polly.Telemetry.TelemetryListener.html",
    "title": "Class TelemetryListener | Polly",
    "keywords": "Class TelemetryListener Namespace Polly.Telemetry Assembly Polly.Core.dll Listener of resilience telemetry events. public abstract class TelemetryListener Inheritance object TelemetryListener Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Write<TResult, TArgs>(in TelemetryEventArguments<TResult, TArgs>) Writes a resilience event to the listener. public abstract void Write<TResult, TArgs>(in TelemetryEventArguments<TResult, TArgs> args) Parameters args TelemetryEventArguments<TResult, TArgs> The arguments associated with the event. Type Parameters TResult The result type. TArgs The type of arguments associated with the event."
  },
  "api/Polly.Telemetry.TelemetryOptions.html": {
    "href": "api/Polly.Telemetry.TelemetryOptions.html",
    "title": "Class TelemetryOptions | Polly",
    "keywords": "Class TelemetryOptions Namespace Polly.Telemetry Assembly Polly.Extensions.dll The options that are used to configure the telemetry that is produced by the resilience strategies. public class TelemetryOptions Inheritance object TelemetryOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties LoggerFactory Gets or sets the logger factory. [Required] public ILoggerFactory LoggerFactory { get; set; } Property Value ILoggerFactory The default value is Instance. MeteringEnrichers Gets the collection of telemetry enrichers. public ICollection<MeteringEnricher> MeteringEnrichers { get; } Property Value ICollection<MeteringEnricher> The default value is an empty collection. ResultFormatter Gets or sets the result formatter. [Required] public Func<ResilienceContext, object?, object?> ResultFormatter { get; set; } Property Value Func<ResilienceContext, object, object> The default value is a formatter that returns a status code for HTTP based responses and the result as-is for all other result types. This property is required. TelemetryListeners Gets the collection of telemetry listeners. public ICollection<TelemetryListener> TelemetryListeners { get; } Property Value ICollection<TelemetryListener> The default value is an empty collection."
  },
  "api/Polly.Telemetry.html": {
    "href": "api/Polly.Telemetry.html",
    "title": "Namespace Polly.Telemetry | Polly",
    "keywords": "Namespace Polly.Telemetry Classes MeteringEnricher Enricher used to enrich the metrics with additional information. ResilienceStrategyTelemetry Resilience telemetry is used by individual resilience strategies to report some important events. ResilienceTelemetrySource The source of resilience telemetry events. TelemetryListener Listener of resilience telemetry events. TelemetryOptions The options that are used to configure the telemetry that is produced by the resilience strategies. Structs EnrichmentContext<TResult, TArgs> Enrichment context used when reporting resilience events. ExecutionAttemptArguments Arguments that encapsulate the execution attempt for retries or hedging. PipelineExecutedArguments Arguments that indicate the pipeline execution started. PipelineExecutingArguments Arguments that indicate the pipeline execution started. ResilienceEvent Represents a resilience event that has been reported. TelemetryEventArguments<TResult, TArgs> Represents the information about the resilience event. Enums ResilienceEventSeverity The severity of reported resilience event."
  },
  "api/Polly.TelemetryResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.TelemetryResiliencePipelineBuilderExtensions.html",
    "title": "Class TelemetryResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class TelemetryResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Extensions.dll The telemetry extensions for the ResiliencePipelineBuilder. public static class TelemetryResiliencePipelineBuilderExtensions Inheritance object TelemetryResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ConfigureTelemetry<TBuilder>(TBuilder, ILoggerFactory) Enables telemetry for this builder. public static TBuilder ConfigureTelemetry<TBuilder>(this TBuilder builder, ILoggerFactory loggerFactory) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. loggerFactory ILoggerFactory The logger factory to be used for logging. Returns TBuilder The builder instance with the telemetry enabled. Type Parameters TBuilder The builder type. Remarks By enabling telemetry, the resilience pipeline will log and meter all resilience events. Additionally, the telemetry strategy that logs and meters the executions is added to the beginning of the composite strategy. Exceptions ArgumentNullException Thrown when builder or loggerFactory is null. ConfigureTelemetry<TBuilder>(TBuilder, TelemetryOptions) Enables telemetry for this builder. public static TBuilder ConfigureTelemetry<TBuilder>(this TBuilder builder, TelemetryOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options TelemetryOptions The resilience telemetry options. Returns TBuilder The builder instance with the telemetry enabled. Type Parameters TBuilder The builder type. Remarks By enabling telemetry, the resilience pipeline will log and meter all resilience events. Additionally, the telemetry strategy that logs and meters the executions is added to the beginning of the composite strategy. Exceptions ArgumentNullException Thrown when builder or options is null."
  },
  "api/Polly.Testing.ResiliencePipelineDescriptor.html": {
    "href": "api/Polly.Testing.ResiliencePipelineDescriptor.html",
    "title": "Class ResiliencePipelineDescriptor | Polly",
    "keywords": "Class ResiliencePipelineDescriptor Namespace Polly.Testing Assembly Polly.Testing.dll Describes the resilience pipeline. public sealed class ResiliencePipelineDescriptor Inheritance object ResiliencePipelineDescriptor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties FirstStrategy Gets the first strategy of the pipeline. public ResilienceStrategyDescriptor FirstStrategy { get; } Property Value ResilienceStrategyDescriptor IsReloadable Gets a value indicating whether the resilience pipeline is reloadable. public bool IsReloadable { get; } Property Value bool Strategies Gets the strategies the pipeline is composed of. public IReadOnlyList<ResilienceStrategyDescriptor> Strategies { get; } Property Value IReadOnlyList<ResilienceStrategyDescriptor>"
  },
  "api/Polly.Testing.ResiliencePipelineExtensions.html": {
    "href": "api/Polly.Testing.ResiliencePipelineExtensions.html",
    "title": "Class ResiliencePipelineExtensions | Polly",
    "keywords": "Class ResiliencePipelineExtensions Namespace Polly.Testing Assembly Polly.Testing.dll The test-related extensions for ResiliencePipeline and ResiliencePipeline<T>. public static class ResiliencePipelineExtensions Inheritance object ResiliencePipelineExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetPipelineDescriptor(ResiliencePipeline) Gets the pipeline descriptor. public static ResiliencePipelineDescriptor GetPipelineDescriptor(this ResiliencePipeline pipeline) Parameters pipeline ResiliencePipeline The pipeline instance. Returns ResiliencePipelineDescriptor A pipeline descriptor. Exceptions ArgumentNullException Thrown when pipeline is null. GetPipelineDescriptor<TResult>(ResiliencePipeline<TResult>) Gets the pipeline descriptor. public static ResiliencePipelineDescriptor GetPipelineDescriptor<TResult>(this ResiliencePipeline<TResult> pipeline) Parameters pipeline ResiliencePipeline<TResult> The pipeline instance. Returns ResiliencePipelineDescriptor A pipeline descriptor. Type Parameters TResult The type of result. Exceptions ArgumentNullException Thrown when pipeline is null."
  },
  "api/Polly.Testing.ResilienceStrategyDescriptor.html": {
    "href": "api/Polly.Testing.ResilienceStrategyDescriptor.html",
    "title": "Class ResilienceStrategyDescriptor | Polly",
    "keywords": "Class ResilienceStrategyDescriptor Namespace Polly.Testing Assembly Polly.Testing.dll This class provides additional information about a ResiliencePipeline. public sealed class ResilienceStrategyDescriptor Inheritance object ResilienceStrategyDescriptor Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Properties Options Gets the options used by the resilience strategy, if any. public ResilienceStrategyOptions? Options { get; } Property Value ResilienceStrategyOptions StrategyInstance Gets the strategy instance. public object StrategyInstance { get; } Property Value object"
  },
  "api/Polly.Testing.html": {
    "href": "api/Polly.Testing.html",
    "title": "Namespace Polly.Testing | Polly",
    "keywords": "Namespace Polly.Testing Classes ResiliencePipelineDescriptor Describes the resilience pipeline. ResiliencePipelineExtensions The test-related extensions for ResiliencePipeline and ResiliencePipeline<T>. ResilienceStrategyDescriptor This class provides additional information about a ResiliencePipeline."
  },
  "api/Polly.Timeout.OnTimeoutArguments.html": {
    "href": "api/Polly.Timeout.OnTimeoutArguments.html",
    "title": "Struct OnTimeoutArguments | Polly",
    "keywords": "Struct OnTimeoutArguments Namespace Polly.Timeout Assembly Polly.Core.dll Arguments used by the timeout strategy to notify that a timeout occurred. public readonly struct OnTimeoutArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors OnTimeoutArguments(ResilienceContext, TimeSpan) Initializes a new instance of the OnTimeoutArguments struct. public OnTimeoutArguments(ResilienceContext context, TimeSpan timeout) Parameters context ResilienceContext The context associated with the execution of a user-provided callback. timeout TimeSpan The timeout value assigned. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext Timeout Gets the timeout value assigned. public TimeSpan Timeout { get; } Property Value TimeSpan"
  },
  "api/Polly.Timeout.TimeoutGeneratorArguments.html": {
    "href": "api/Polly.Timeout.TimeoutGeneratorArguments.html",
    "title": "Struct TimeoutGeneratorArguments | Polly",
    "keywords": "Struct TimeoutGeneratorArguments Namespace Polly.Timeout Assembly Polly.Core.dll Arguments used by the timeout strategy to retrieve a timeout for current execution. public readonly struct TimeoutGeneratorArguments Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Remarks Always use the constructor when creating this struct, otherwise we do not guarantee binary compatibility. Constructors TimeoutGeneratorArguments(ResilienceContext) Initializes a new instance of the TimeoutGeneratorArguments struct. public TimeoutGeneratorArguments(ResilienceContext context) Parameters context ResilienceContext The context associated with the execution of a user-provided callback. Properties Context Gets the context associated with the execution of a user-provided callback. public ResilienceContext Context { get; } Property Value ResilienceContext"
  },
  "api/Polly.Timeout.TimeoutRejectedException.html": {
    "href": "api/Polly.Timeout.TimeoutRejectedException.html",
    "title": "Class TimeoutRejectedException | Polly",
    "keywords": "Class TimeoutRejectedException Namespace Polly.Timeout Assembly Polly.Core.dll Exception thrown when a delegate executed through a timeout resilience strategy does not complete, before the configured timeout. public class TimeoutRejectedException : ExecutionRejectedException, ISerializable Inheritance object Exception ExecutionRejectedException TimeoutRejectedException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors TimeoutRejectedException() Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException() TimeoutRejectedException(string) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(string message) Parameters message string The message. TimeoutRejectedException(string, Exception) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(string message, Exception innerException) Parameters message string The message. innerException Exception The inner exception. TimeoutRejectedException(string, TimeSpan) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(string message, TimeSpan timeout) Parameters message string The message. timeout TimeSpan The timeout value that caused this exception. TimeoutRejectedException(string, TimeSpan, Exception) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(string message, TimeSpan timeout, Exception innerException) Parameters message string The message. timeout TimeSpan The timeout value that caused this exception. innerException Exception The inner exception. TimeoutRejectedException(TimeSpan) Initializes a new instance of the TimeoutRejectedException class. public TimeoutRejectedException(TimeSpan timeout) Parameters timeout TimeSpan The timeout value that caused this exception. Properties Timeout Gets the timeout value that caused this exception. public TimeSpan Timeout { get; } Property Value TimeSpan"
  },
  "api/Polly.Timeout.TimeoutStrategyOptions.html": {
    "href": "api/Polly.Timeout.TimeoutStrategyOptions.html",
    "title": "Class TimeoutStrategyOptions | Polly",
    "keywords": "Class TimeoutStrategyOptions Namespace Polly.Timeout Assembly Polly.Core.dll Represents the options for the timeout strategy. public class TimeoutStrategyOptions : ResilienceStrategyOptions Inheritance object ResilienceStrategyOptions TimeoutStrategyOptions Inherited Members ResilienceStrategyOptions.Name object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors TimeoutStrategyOptions() Initializes a new instance of the TimeoutStrategyOptions class. public TimeoutStrategyOptions() Properties OnTimeout Gets or sets the timeout delegate that raised when timeout occurs. public Func<OnTimeoutArguments, ValueTask>? OnTimeout { get; set; } Property Value Func<OnTimeoutArguments, ValueTask> The default value is null. Timeout Gets or sets the default timeout. [Range(typeof(TimeSpan), \"00:00:01\", \"1.00:00:00\")] public TimeSpan Timeout { get; set; } Property Value TimeSpan This value must be greater than 1 second and less than 24 hours. The default value is 30 seconds. TimeoutGenerator Gets or sets a timeout generator that generates the timeout for a given execution. public Func<TimeoutGeneratorArguments, ValueTask<TimeSpan>>? TimeoutGenerator { get; set; } Property Value Func<TimeoutGeneratorArguments, ValueTask<TimeSpan>> The default value is null. Remarks If generator returns a TimeSpan value that is less or equal to Zero its value is ignored and Timeout is used instead. When generator is null the Timeout is used. Return InfiniteTimeSpan to disable the timeout for the given execution."
  },
  "api/Polly.Timeout.html": {
    "href": "api/Polly.Timeout.html",
    "title": "Namespace Polly.Timeout | Polly",
    "keywords": "Namespace Polly.Timeout Classes TimeoutRejectedException Exception thrown when a delegate executed through a timeout resilience strategy does not complete, before the configured timeout. TimeoutStrategyOptions Represents the options for the timeout strategy. Structs OnTimeoutArguments Arguments used by the timeout strategy to notify that a timeout occurred. TimeoutGeneratorArguments Arguments used by the timeout strategy to retrieve a timeout for current execution."
  },
  "api/Polly.TimeoutResiliencePipelineBuilderExtensions.html": {
    "href": "api/Polly.TimeoutResiliencePipelineBuilderExtensions.html",
    "title": "Class TimeoutResiliencePipelineBuilderExtensions | Polly",
    "keywords": "Class TimeoutResiliencePipelineBuilderExtensions Namespace Polly Assembly Polly.Core.dll Extensions for adding timeout to ResiliencePipelineBuilder. public static class TimeoutResiliencePipelineBuilderExtensions Inheritance object TimeoutResiliencePipelineBuilderExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddTimeout<TBuilder>(TBuilder, TimeoutStrategyOptions) Adds a timeout to the builder. public static TBuilder AddTimeout<TBuilder>(this TBuilder builder, TimeoutStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. options TimeoutStrategyOptions The timeout options. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder or options is null. ValidationException Thrown when options are invalid. AddTimeout<TBuilder>(TBuilder, TimeSpan) Adds a timeout to the builder. public static TBuilder AddTimeout<TBuilder>(this TBuilder builder, TimeSpan timeout) where TBuilder : ResiliencePipelineBuilderBase Parameters builder TBuilder The builder instance. timeout TimeSpan The timeout value. This value should be greater than Zero. Returns TBuilder The same builder instance. Type Parameters TBuilder The builder type. Exceptions ArgumentNullException Thrown when builder is null. ValidationException Thrown when the options produced from the arguments are invalid."
  },
  "api/Polly.html": {
    "href": "api/Polly.html",
    "title": "Namespace Polly | Polly",
    "keywords": "Namespace Polly Classes CircuitBreakerResiliencePipelineBuilderExtensions Circuit breaker extensions for ResiliencePipelineBuilder. ExecutionRejectedException Exception thrown when a policy rejects execution of a delegate. More specific exceptions which derive from this type, are generally thrown. FallbackResiliencePipelineBuilderExtensions Extensions for adding fallback to ResiliencePipelineBuilder. HedgingResiliencePipelineBuilderExtensions Extensions for adding hedging to ResiliencePipelineBuilder. Outcome Produces instances of Outcome<TResult>. PollyServiceCollectionExtensions Provides extension methods for registering resilience pipelines using the IServiceCollection. PredicateBuilder Defines a builder for creating exception predicates. PredicateBuilder<TResult> Defines a builder for creating predicates for TResult and Exception combinations. PredicateResult Class that represents the results that can be used in predicates. RateLimiterResiliencePipelineBuilderExtensions Extensions for adding rate limiting to ResiliencePipelineBuilder. ResilienceContext A context assigned to a single execution of ResiliencePipeline. It is created manually or automatically when the user calls the various extensions on top of ResiliencePipeline. After every execution the context should be discarded and returned to the pool. ResilienceContextPool The pool of ResilienceContext instances. ResiliencePipeline Resilience pipeline is used to execute the user-provided callbacks. ResiliencePipelineBuilder A builder that is used to create an instance of ResiliencePipeline. ResiliencePipelineBuilderBase A builder that is used to create an instance of ResiliencePipeline. ResiliencePipelineBuilderExtensions Extensions for ResiliencePipelineBuilderBase. ResiliencePipelineBuilder<TResult> A builder that is used to create an instance of ResiliencePipeline<T>. ResiliencePipeline<T> Resilience pipeline is used to execute the user-provided callbacks. ResilienceProperties Represents a collection of custom resilience properties. ResilienceStrategy Base class for all proactive resilience strategies. ResilienceStrategyOptions The options associated with the individual resilience strategy. ResilienceStrategy<TResult> This base strategy class is used to simplify the implementation of generic (reactive) strategies by limiting the number of generic types the execute method receives. RetryResiliencePipelineBuilderExtensions Extensions for adding retries to ResiliencePipelineBuilder. StrategyBuilderContext The context used for building an individual resilience strategy. TelemetryResiliencePipelineBuilderExtensions The telemetry extensions for the ResiliencePipelineBuilder. TimeoutResiliencePipelineBuilderExtensions Extensions for adding timeout to ResiliencePipelineBuilder. Structs Outcome<TResult> Represents the outcome of an operation which could be a result of type TResult or an exception. ResilienceContextCreationArguments Arguments used by the ResilienceContextPool when creating ResilienceContext. ResiliencePropertyKey<TValue> Represents a key used by ResilienceProperties. Enums DelayBackoffType The backoff type used by the strategies."
  },
  "api/Snippets.Docs.MyApi.html": {
    "href": "api/Snippets.Docs.MyApi.html",
    "title": "Class MyApi | Polly",
    "keywords": "Class MyApi Namespace Snippets.Docs Assembly Snippets.dll public class MyApi Inheritance object MyApi Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors MyApi(ResiliencePipelineProvider<string>) public MyApi(ResiliencePipelineProvider<string> pipelineProvider) Parameters pipelineProvider ResiliencePipelineProvider<string> Methods ExecuteAsync(CancellationToken) public Task ExecuteAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Returns Task"
  },
  "api/Snippets.Docs.MyApiExtensions.html": {
    "href": "api/Snippets.Docs.MyApiExtensions.html",
    "title": "Class MyApiExtensions | Polly",
    "keywords": "Class MyApiExtensions Namespace Snippets.Docs Assembly Snippets.dll public static class MyApiExtensions Inheritance object MyApiExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddMyApi(IServiceCollection) public static IServiceCollection AddMyApi(this IServiceCollection services) Parameters services IServiceCollection Returns IServiceCollection"
  },
  "api/Snippets.Docs.html": {
    "href": "api/Snippets.Docs.html",
    "title": "Namespace Snippets.Docs | Polly",
    "keywords": "Namespace Snippets.Docs Classes MyApi MyApiExtensions"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | Polly",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation!"
  },
  "community/libraries-and-contributions.html": {
    "href": "community/libraries-and-contributions.html",
    "title": "3rd Party Libraries and Contributions | Polly",
    "keywords": "3rd Party Libraries and Contributions Fluent Assertions - A set of .NET extension methods that allow you to more naturally specify the expected outcome of a TDD or BDD-style test | Apache License 2.0 (Apache) xUnit.net - Free, open source, community-focused unit testing tool for the .NET Framework | Apache License 2.0 (Apache) Ian Griffith's TimedLock Steven van Deursen's ReadOnlyDictionary (until Polly v5.0.6) Stephen Cleary's AsyncEx library for AsyncSemaphore (supports BulkheadAsync policy for .NET4.0 only) (until Polly v5.9.0) | MIT license @theraot's ExceptionDispatchInfo implementation for .NET4.0 (supports Timeout policy for .NET4.0 only) (until Polly v5.9.0) including also a contribution by @migueldeicaza | Licensed under and distributed under Creative Commons Attribution Share Alike license per StackExchange Terms of Service Build powered by Cake and MinVer. Developers powered by Resharper, with thanks to JetBrains for OSS licensing. Acknowledgements lokad-shared-libraries - Helper assemblies originally for .NET 3.5 and Silverlight 2.0 which were developed as part of the Open Source effort by Lokad.com (discontinued) | New BSD License @michael-wolfenden - The creator and mastermind of Polly! @ghuntley - Portable Class Library implementation. @mauricedb - Initial async implementation. @robgibbens - Added existing async files to PCL project Hacko - Added extra NotOnCapturedContext call to prevent potential deadlocks when blocking on asynchronous calls @ThomasMentzel - Added ability to capture the results of executing a policy via ExecuteAndCapture @yevhen - Added full control of whether to continue on captured synchronization context or not @reisenberger - Added full async cancellation support @reisenberger - Added async support for ContextualPolicy @reisenberger - Added ContextualPolicy support for circuit-breaker @reisenberger - Extended circuit-breaker for public monitoring and control @reisenberger - Added ExecuteAndCapture support with arbitrary context data @kristianhald and @reisenberger - Added AdvancedCircuitBreaker @reisenberger - Allowed async onRetry delegates to async retry policies @Lumirris - Add new Polly.Net40Async project/package supporting async for .NET40 via Microsoft.Bcl.Async @SteveCote - Added overloads to WaitAndRetry and WaitAndRetryAsync methods that accept an onRetry delegate which includes the attempt count. @reisenberger - Allowed policies to handle returned results; added strongly-typed policies Policy<TResult>;. @christopherbahr - Added optimisation for circuit-breaker hot path. @Finity - Fixed circuit-breaker threshold bug. @reisenberger - Add some missing ExecuteAndCapture/Async overloads. @brunolauze - Add CancellationToken support to synchronous executions (to support TimeoutPolicy). @reisenberger - Add PolicyWrap. @reisenberger - Add Fallback policy. @reisenberger - Add PolicyKeys and context to all policy executions, as bedrock for policy events and metrics tracking executions. @reisenberger, and contributions from @brunolauze - Add Bulkhead Isolation policy. @reisenberger - Add Timeout policy. @reisenberger - Fix .NETStandard 1.0 targeting. Remove PCL259 target. PCL259 support is provided via .NETStandard1.0 target, going forward. @reisenberger - Fix CircuitBreaker HalfOpen state and cases when breakDuration is shorter than typical call timeout. Thanks to @vgouw and @kharos for the reports and insightful thinking. @lakario - Tidy CircuitBreaker LastException property. @lakario - Add NoOpPolicy. @Julien-Mialon - Fixes, support and examples for .NETStandard compatibility with Xamarin PCL projects @reisenberger - Add mutable Context and extra overloads taking Context. Allows different parts of a policy execution to exchange data via the mutable Context travelling with each execution. @ankitbko - Add PolicyRegistry for storing and retrieving policies. @reisenberger - Add interfaces by policy type and execution type. @seanfarrow - Add IReadOnlyPolicyRegistry interface. @kesmy - Migrate solution to msbuild15, banish project.json and packages.config @hambudi - Ensure sync TimeoutPolicy with TimeoutStrategy.Pessimistic rethrows delegate exceptions without additional AggregateException. @jiimaho and @Extremo75 - Provide public factory methods for PolicyResult, to support testing. @Extremo75 - Allow fallback delegates to take handled fault as input parameter. @reisenberger and @seanfarrow - Add CachePolicy, with interfaces for pluggable cache providers and serializers. Thanks to the awesome devs at @tretton37 who delivered the following as part of a one-day in-company hackathon led by @reisenberger, sponsored by @tretton37 and convened by @thecodejunkie @matst80 - Allow WaitAndRetry to take handled fault as an input to the sleepDurationProvider, allowing WaitAndRetry to take account of systems which specify a duration to wait as part of a fault response; eg Azure CosmosDB may specify this in x-ms-retry-after-ms headers or in a property to an exception thrown by the Azure CosmosDB SDK. @MartinSStewart - Add GetPolicies() extension methods to IPolicyWrap. @jbergens37 - Parallelize test running where possible, to improve overall build speed. @reisenberger - Add new .HandleInner<TException>(...) syntax for handling inner exceptions natively. @rjongeneelen and @reisenberger - Allow PolicyWrap configuration to configure policies via interfaces. @reisenberger - Performance improvements. @awarrenlove - Add ability to calculate cache Ttl based on item to cache. @erickhouse - Add a new onBreak overload that provides the prior state on a transition to an open state. @benagain - Bug fix: RelativeTtl in CachePolicy now always returns a ttl relative to time item is cached. @urig - Allow TimeoutPolicy to be configured with Timeout.InfiniteTimeSpan. @reisenberger - Integration with IHttpClientFactory for ASPNET Core 2.1. @freakazoid182 - WaitAnd/RetryForever overloads where onRetry takes the retry number as a parameter. @dustyhoppe - Overloads where onTimeout takes thrown exception as a parameter. @flin-zap - Catch missing async continuation control. @reisenberger - Clarify separation of sync and async policies. @reisenberger - Enable extensibility by custom policies hosted external to Polly. @seanfarrow - Enable collection initialization syntax for PolicyRegistry. @moerwald - Code clean-ups, usage of more concise C# members. @cmeeren - Enable cache policies to cache values of default(TResult). @aprooks - Build script tweaks for Mac and mono. @kesmy - Add Soucelink support, clean up cake build. @simluk - Fix continueOnCaptureContext not being honored in async retry implementation (bug in v7.1.0 only). @jnyrup - Upgrade tests to Fluent Assertions v5.9.0 @SimonCropp - Add netcoreapp3.0 target; code clean-ups. @aerotog and @reisenberger - IConcurrentPolicyRegistry methods on PolicyRegistry @reisenberger and @martincostello - Add RateLimit policy."
  },
  "community/polly-contrib.html": {
    "href": "community/polly-contrib.html",
    "title": "Polly-Contrib | Polly",
    "keywords": "Polly-Contrib Polly now has a Polly-Contrib to allow the community to contribute policies or other enhancements around Polly with a low burden of ceremony. Have a contrib you'd like to publish under Polly-Contrib? Contact us with an issue here or on Polly's Slack, and we can set up a CI-ready Polly.Contrib repo to which you have full rights, to help you manage and deliver your awesomeness to the community! We also provide: a blank starter template for a custom policy (see above for more on custom policies) a template repo for any other contrib Both templates contain a full project structure referencing Polly, Polly's default build targets, and a build to build and test your contrib and make a NuGet package. Available via Polly-Contrib Polly.Contrib.WaitAndRetry: a collection of concise helper methods for common wait-and-retry strategies; and a new jitter formula combining exponential backoff with a very even distribution of randomly-jittered retry intervals. Polly.Contrib.AzureFunctions.CircuitBreaker: a distributed circuit-breaker implemented in Azure Functions; consumable in Azure Functions, or from anywhere over http. Simmy: our chaos engineering project. Polly.Contrib.TimingPolicy: a starter policy to publish execution timings of any call executed through Policy. Polly.Contrib.LoggingPolicy: a policy simply to log handled exceptions/faults, and rethrow or bubble the fault outwards."
  },
  "community/resources.html": {
    "href": "community/resources.html",
    "title": "Resources | Polly",
    "keywords": "Resources This includes Blogs, podcasts, courses, e-books, architecture samples and videos around Polly. When we discover an interesting write-up on Polly, we'll add it to this list. If you have a blog post you'd like to share, please submit a PR! Blog posts Adding a circuit breaker to your ASP.NET 6 application with Polly - by Lachlan Barclay Try .NET Samples of Polly, the .NET Resilience Framework - by Bryan Hogan Create exceptional interactive documentation with Try .NET - The Polly NuGet library did! - by Scott Hanselman (writing about the work of Bryan Hogan) Adding resilience and Transient Fault handling to your .NET Core HttpClient with Polly - by Scott Hanselman Reliable Event Processing in Azure Functions - by Jeff Hollan Optimally configuring ASPNET Core HttpClientFactory including with Polly policies - by Muhammad Rehan Saeed Integrating HttpClientFactory with Polly for transient fault handling - by Steve Gordon Resilient network connectivity in Xamarin Forms - by Adam Pedley Policy recommendations for Azure Cognitive Services - by Joel Hulen Using Polly with F# async workflows - by Mark Seemann Building resilient applications with Polly (with focus on Azure SQL transient errors) - by Geovanny Alzate Sandoval Azure SQL transient errors - by Mattias Karlsson Polly series on No Dogma blog - by Bryan Hogan Polly 5.0 - a wider resilience framework! - by Dylan Reisenberger Implementing the retry pattern in c sharp using Polly - by Alastair Crabtree NuGet Package of the Week: Polly wanna fluently express transient exception handling policies in .NET? - by Scott Hanselman Exception handling policies with Polly - by Mark Timmings When you use the Polly circuit-breaker, make sure you share your Policy instances! - by Andrew Lock Polly is Repetitive, and I love it! - by Joel Hulen Using the Context to Obtain the Retry Count for Diagnostics - by Steve Gordon Passing an ILogger to Polly Policies - by Steve Gordon Using Polly and Flurl to improve your website - by Jeremy Lindsay. Exploring the Polly.Contrib.WaitAndRetry helpers - by Ben Hyrman, who also wrote most of the Polly.Contrib.WaitAndRetry documentation. Podcasts June 2018: DotNetRocks features Polly as Carl Franklin and Richard Campbell chat with Dylan Reisenberger about policy patterns, and the new ASP NET Core 2.1 integration with IHttpClientFactory. April 2017: Dylan Reisenberger sits down virtually with Bryan Hogan of NoDogmaBlog for an Introduction to Polly podcast. Why do I need Polly? History of the Polly project. What do we mean by resilience and transient faults? How retry and circuit-breaker help. Exponential backoff. Stability patterns. Bulkhead isolation. Future directions (as at April 2017). PluralSight course Bryan Hogan of the NoDogmaBlog has authored a PluralSight course on Polly. The course takes you through all the major features of Polly, with an additional module added in the fall of 2018 on Http Client Factory. The course examples are based around using Polly for fault tolerance when calling remote web services, but the principles and techniques are applicable to any context in which Polly may be used. Sample microservices architecture and e-book Sample microservices architecture Cesar de la Torre produced the Microsoft eShopOnContainers project, a sample project demonstrating a .NET Microservices architecture. The project uses Polly retry and circuit-breaker policies for resilience in calls to microservices, and in establishing connections to transports such as RabbitMQ. e-book Accompanying the project is a .NET Microservices Architecture ebook with an extensive section (section 8) on using Polly for resilience, to which Dylan Reisenberger contributed. The e-book and code is now (June 2018) updated for using the latest ASP NET Core 2.1 features, Polly with IHttpClientFactory. Videos Robust Applications with Polly, the .NET Resilience Framework, Bryan Hogan introduces Polly and explains how to use it to build a fault tolerant application. From MVP Houssem Dellai, a YouTube video on How to use Polly with Xamarin Apps, covering wait-and-retry and discussing circuit-breaker policy with a demonstration in Xamarin Forms. Here is the source code of the application demonstrated in the video. Draws on the ResilientHttpClient from Microsoft's eShopOnContainers project. In the video, .NET Rocks Live with Jon Skeet and Bill Wagner, Bill Wagner discusses Polly. Scott Allen discusses Polly during his Building for Resiliency and Scale in the Cloud presentation at NDC. ASP.NET Community Standup April 24, 2018: Damian Edwards, Jon Galloway and Scott Hanselman discuss Scott Hanselman's blog on Polly with IHttpClientFactory and the Polly team documentation on IHttpClientFactory. Interesting background discussion also on feature richness and the importance of good documentation."
  },
  "extensibility/index.html": {
    "href": "extensibility/index.html",
    "title": "Extensibility | Polly",
    "keywords": "Extensibility This article explains how to extend Polly with new resilience strategies. Polly identifies two types of resilience strategies: Reactive: These strategies handle specific exceptions that are thrown, or results that are returned, by the callbacks executed through the strategy. Proactive: Unlike reactive strategies, proactive strategies do not focus on handling errors by the callbacks might throw or return. They can make proactive decisions to cancel or reject the execution of callbacks (e.g., using a rate limiter or a timeout resilience strategy). This guide will help you create a new illustrative resilience strategy for each type. Basics of extensibility Regardless of whether the strategy is reactive or proactive, every new resilience strategy should include the following components: Options detailing the strategy's configuration. These should inherit from ResilienceStrategyOptions. Extensions for ResiliencePipelineBuilder or ResiliencePipelineBuilder<T>. Custom argument types for delegates that contain information about a specific event. The strategy options contain properties of following types: Common types: Such as int, bool, TimeSpan, etc. Delegates: For example when a strategy needs to raise an event, or generate a value. In general, the delegates should by asynchronous. Arguments: Used by the delegates to pass the information to their consumers. Delegates Individual resilience strategies make use of several delegate types: Predicates: Vital for determining whether a resilience strategy should handle the given execution result. Events: Triggered when significant actions or states occur within the resilience strategy. Generators: Invoked when the resilience strategy needs specific information or values from the caller. Recommended signatures for these delegates are: Predicates Func<Args<TResult>, ValueTask<bool>> (Reactive) Events Func<Args<TResult>, ValueTask> (Reactive) Func<Args, ValueTask> (Proactive) Generators Func<Args<TResult>, ValueTask<TValue>> (Reactive) Func<Args, ValueTask<TValue>> (Proactive) These delegates accept either Args or Args<TResult> arguments, which encapsulate event information. Note that all these delegates are asynchronous and return a ValueTask. Learn more about arguments in the sections below. Note When setting up delegates, consider using the ResilienceContext.ContinueOnCapturedContext property if your user code interacts with a synchronization context (such as in asynchronous UI applications like Windows Forms or WPF). How to use delegates Below are some examples illustrating the usage of these delegates: new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { // Non-Generic predicate for multiple result types ShouldHandle = args => args.Outcome switch { { Exception: InvalidOperationException } => PredicateResult.True(), { Result: string result } when result == \"Failure\" => PredicateResult.True(), { Result: int result } when result == -1 => PredicateResult.True(), _ => PredicateResult.False() }, }) .Build(); new ResiliencePipelineBuilder<string>() .AddRetry(new RetryStrategyOptions<string> { // Generic predicate for a single result type ShouldHandle = args => args.Outcome switch { { Exception: InvalidOperationException } => PredicateResult.True(), { Result: { } result } when result == \"Failure\" => PredicateResult.True(), _ => PredicateResult.False() }, }) .Build(); Arguments Arguments are used by individual delegate types to flow information to the consumer. Arguments should always have an Arguments suffix and include a Context property. Using arguments boosts the extensibility and maintainability of the API, as adding new members becomes a non-breaking change. For proactive strategies, the arguments structure might resemble the following: // Structs for arguments encapsulate details about specific events within the resilience strategy. // Relevant properties to the event can be exposed. In this event, the actual execution time and the exceeded threshold are included. public readonly struct ThresholdExceededArguments { public ThresholdExceededArguments(ResilienceContext context, TimeSpan threshold, TimeSpan duration) { Context = context; Threshold = threshold; Duration = duration; } public TimeSpan Threshold { get; } public TimeSpan Duration { get; } // As per convention, all arguments should provide a \"Context\" property. public ResilienceContext Context { get; } } Implementing a resilience strategy To find out more details about implementing a strategy, follow the links below: Proactive strategy: Explains how to implement a proactive resilience strategy. Reactive strategy: Explains how to implement a reactive resilience strategy."
  },
  "extensibility/proactive-strategy.html": {
    "href": "extensibility/proactive-strategy.html",
    "title": "Proactive resilience strategy | Polly",
    "keywords": "Proactive resilience strategy This document guides you in creating a Timing resilience strategy that tracks the execution times of callbacks and reports when the execution time exceeds the expected duration. This is a prime example of a proactive strategy because we aren't concerned with the individual results produced by the callbacks. Hence, this strategy can be used across various result types. Implementation Proactive resilience strategies are derived from the ResilienceStrategy base class. For this strategy, the implementation is: // Strategies should be internal and not exposed in the library's public API. // Configure the strategy through extension methods and options. internal sealed class TimingResilienceStrategy : ResilienceStrategy { private readonly TimeSpan _threshold; private readonly Func<ThresholdExceededArguments, ValueTask>? _thresholdExceeded; private readonly ResilienceStrategyTelemetry _telemetry; public TimingResilienceStrategy( TimeSpan threshold, Func<ThresholdExceededArguments, ValueTask>? thresholdExceeded, ResilienceStrategyTelemetry telemetry) { _threshold = threshold; _telemetry = telemetry; _thresholdExceeded = thresholdExceeded; } protected override async ValueTask<Outcome<TResult>> ExecuteCore<TResult, TState>( Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback, ResilienceContext context, TState state) { var stopwatch = Stopwatch.StartNew(); // Execute the given callback and adhere to the ContinueOnCapturedContext property value. Outcome<TResult> outcome = await callback(context, state).ConfigureAwait(context.ContinueOnCapturedContext); if (stopwatch.Elapsed > _threshold) { // Bundle information about the event into arguments. var args = new ThresholdExceededArguments(context, _threshold, stopwatch.Elapsed); // Report this as a resilience event if the execution took longer than the threshold. _telemetry.Report( new ResilienceEvent(ResilienceEventSeverity.Warning, \"ExecutionThresholdExceeded\"), context, args); if (_thresholdExceeded is not null) { await _thresholdExceeded(args).ConfigureAwait(context.ContinueOnCapturedContext); } } // Return the outcome directly. return outcome; } } Review the code and comments to understand the implementation. Take note of the ThresholdExceededArguments struct: // Structs for arguments encapsulate details about specific events within the resilience strategy. // Relevant properties to the event can be exposed. In this event, the actual execution time and the exceeded threshold are included. public readonly struct ThresholdExceededArguments { public ThresholdExceededArguments(ResilienceContext context, TimeSpan threshold, TimeSpan duration) { Context = context; Threshold = threshold; Duration = duration; } public TimeSpan Threshold { get; } public TimeSpan Duration { get; } // As per convention, all arguments should provide a \"Context\" property. public ResilienceContext Context { get; } } Arguments should always have an Arguments suffix and include a Context property. Using arguments boosts the extensibility and maintainability of the API, as adding new members becomes a non-breaking change. The ThresholdExceededArguments provides details about the actual execution time and threshold, allowing consumers to respond to this event or supply a custom callback for such situations. Options In the previous section, we implemented the TimingResilienceStrategy. Now, it's time to integrate it with Polly and its public API. Let's define the public TimingStrategyOptions to configure our strategy: public class TimingStrategyOptions : ResilienceStrategyOptions { public TimingStrategyOptions() { // Assign a default name to the options for more detailed telemetry insights. Name = \"Timing\"; } // Apply validation attributes to guarantee the options' validity. // The pipeline will handle validation automatically during its construction. [Range(typeof(TimeSpan), \"00:00:00\", \"1.00:00:00\")] [Required] public TimeSpan? Threshold { get; set; } // Provide the delegate to be called when the threshold is surpassed. // Ideally, arguments should share the delegate's name, but with an \"Arguments\" suffix. public Func<ThresholdExceededArguments, ValueTask>? ThresholdExceeded { get; set; } } Options represent our public contract with the consumer. By using them, we can easily add new members without breaking changes and perform validation consistently. Extensions So far, we've covered: The public TimingStrategyOptions and its associated arguments. The proactive strategy implementation named TimingResilienceStrategy. The final step is to integrate these components with each other by adding new extensions for both ResiliencePipelineBuilder and ResiliencePipelineBuilder<T>. Since both builders inherit from the same base class, we can introduce a single extension for ResiliencePipelineBuilderBase to serve both. public static class TimingResilienceStrategyBuilderExtensions { // The extensions should return the builder to support a fluent API. // For proactive strategies, we can target both \"ResiliencePipelineBuilderBase\" and \"ResiliencePipelineBuilder<T>\" // using generic constraints. public static TBuilder AddTiming<TBuilder>(this TBuilder builder, TimingStrategyOptions options) where TBuilder : ResiliencePipelineBuilderBase { // Add the strategy through the AddStrategy method. This method accepts a factory delegate // and automatically validates the options. return builder.AddStrategy( context => { // The \"context\" provides various properties for the strategy's use. // In this case, we simply use the \"Telemetry\" property and pass it to the strategy. // The Threshold and ThresholdExceeded values are sourced from the options. var strategy = new TimingResilienceStrategy( options.Threshold!.Value, options.ThresholdExceeded, context.Telemetry); return strategy; }, options); } } Usage // Add the proactive strategy to the builder var pipeline = new ResiliencePipelineBuilder() // This is custom extension defined in this sample .AddTiming(new TimingStrategyOptions { Threshold = TimeSpan.FromSeconds(1), ThresholdExceeded = args => { Console.WriteLine(\"Execution threshold exceeded!\"); return default; }, }) .Build(); Resources For further information on proactive resilience strategies, consider exploring these resources: Timing strategy sample: A practical example from this guide. Timeout resilience strategy: Discover the built-in timeout resilience strategy implementation. Rate limiter resilience strategy: Discover how rate limiter strategy is implemented."
  },
  "extensibility/reactive-strategy.html": {
    "href": "extensibility/reactive-strategy.html",
    "title": "Reactive resilience strategy | Polly",
    "keywords": "Reactive resilience strategy This document describes how to set up a Result reporting resilience strategy. This strategy lets you listen for specific results and report them to other components. It serves as a good example of a reactive strategy because it deals with specific results. Implementation Reactive resilience strategies inherit from the ResilienceStrategy<T> base class. The implementation for this specific strategy is as follows: // Strategies should be internal and not exposed in the library's public API. // Use extension methods and options to configure the strategy. internal sealed class ResultReportingResilienceStrategy<T> : ResilienceStrategy<T> { private readonly Func<ResultReportingPredicateArguments<T>, ValueTask<bool>> _shouldHandle; private readonly Func<OnReportResultArguments<T>, ValueTask> _onReportResult; private readonly ResilienceStrategyTelemetry _telemetry; public ResultReportingResilienceStrategy( Func<ResultReportingPredicateArguments<T>, ValueTask<bool>> shouldHandle, Func<OnReportResultArguments<T>, ValueTask> onReportResult, ResilienceStrategyTelemetry telemetry) { _shouldHandle = shouldHandle; _onReportResult = onReportResult; _telemetry = telemetry; } protected override async ValueTask<Outcome<T>> ExecuteCore<TState>( Func<ResilienceContext, TState, ValueTask<Outcome<T>>> callback, ResilienceContext context, TState state) { Outcome<T> outcome = await callback(context, state).ConfigureAwait(context.ContinueOnCapturedContext); // Check if the outcome should be reported using the \"ShouldHandle\" predicate. if (await _shouldHandle(new ResultReportingPredicateArguments<T>(context, outcome)).ConfigureAwait(context.ContinueOnCapturedContext)) { var args = new OnReportResultArguments<T>(context, outcome); // Report the event with an informational severity level to the telemetry infrastructure. _telemetry.Report(new ResilienceEvent(ResilienceEventSeverity.Information, \"ResultReported\"), context, outcome, args); // Call the \"OnReportResult\" callback. await _onReportResult(args).ConfigureAwait(context.ContinueOnCapturedContext); } return outcome; } } Reactive strategies use the ShouldHandle predicate to decide whether to handle the outcome of a user callback. The convention is to name the predicate's arguments using the {StrategyName}PredicateArguments pattern and return a ValueTask<bool>. Here, we use ResultReportingPredicateArguments<TResult>: public struct ResultReportingPredicateArguments<TResult> { public ResultReportingPredicateArguments(ResilienceContext context, Outcome<TResult> outcome) { Context = context; Outcome = outcome; } // Always include the \"Context\" property in the arguments. public ResilienceContext Context { get; } // Always have the \"Outcome\" property in reactive arguments. public Outcome<TResult> Outcome { get; } } Reactive arguments always contain the Context and Outcome properties. Additionally, to report the outcome, the strategy uses OnReportResultArguments<TResult>: public struct OnReportResultArguments<TResult> { public OnReportResultArguments(ResilienceContext context, Outcome<TResult> outcome) { Context = context; Outcome = outcome; } // Always include the \"Context\" property in the arguments. public ResilienceContext Context { get; } // Always have the \"Outcome\" property in reactive arguments. public Outcome<TResult> Outcome { get; } } Using arguments in callbacks supports a more maintainable and extensible API. Options In the previous section, we implemented the ResultReportingResilienceStrategy<T>. Now, we need to integrate it with Polly and its public API. Define the public ResultReportingStrategyOptions<TResult> class to configure our strategy: public class ResultReportingStrategyOptions<TResult> : ResilienceStrategyOptions { public ResultReportingStrategyOptions() { // Set a default name for the options to enhance telemetry insights. Name = \"ResultReporting\"; } // Options for reactive strategies should always include a \"ShouldHandle\" delegate. // Set a sensible default when possible. Here, we handle all exceptions. public Func<ResultReportingPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } = args => { return new ValueTask<bool>(args.Outcome.Exception is not null); }; // This illustrates an event delegate. Note that the arguments struct carries the same name as the delegate but with an \"Arguments\" suffix. // The event follows the async convention and must be set by the user. // // The [Required] attribute enforces the consumer to specify this property, used when some properties do not have sensible defaults and are required. [Required] public Func<OnReportResultArguments<TResult>, ValueTask>? OnReportResult { get; set; } } If you want to support non-generic options for the ResiliencePipelineBuilder, you can expose them as well: // Simply derive from the generic options, using 'object' as the result type. // This allows the strategy to manage all results. public class ResultReportingStrategyOptions : ResultReportingStrategyOptions<object> { } Using options as a public contract helps us ensure flexibility with consumers. By adopting this method, you can introduce new members with ease without introducing breaking changes and maintain consistent validation. Extensions Up until now, we've discussed: The public ResultReportingStrategyOptions<TResult> and the related arguments. The proactive strategy implementation called ResultReportingResilienceStrategy<TResult>. The next step is to combine these elements by introducing new extensions for ResiliencePipelineBuilder<T> and, optionally, ResiliencePipelineBuilder. public static class ResultReportingResilienceStrategyBuilderExtensions { // Add extensions for the generic builder. // Extensions should return the builder to support a fluent API. public static ResiliencePipelineBuilder<TResult> AddResultReporting<TResult>(this ResiliencePipelineBuilder<TResult> builder, ResultReportingStrategyOptions<TResult> options) { // Incorporate the strategy using the AddStrategy() method. This method receives a factory delegate // and automatically checks the options. return builder.AddStrategy( context => { // The \"context\" offers various properties for the strategy to use. // Here, we simply use the \"Telemetry\" property and hand it over to the strategy. // The ShouldHandle and OnReportResult values come from the options. var strategy = new ResultReportingResilienceStrategy<TResult>( options.ShouldHandle, options.OnReportResult!, context.Telemetry); return strategy; }, options); } // Optionally, if suitable for the strategy, add support for non-generic builders. // Observe the use of the non-generic ResultReportingStrategyOptions. public static ResiliencePipelineBuilder AddResultReporting(this ResiliencePipelineBuilder builder, ResultReportingStrategyOptions options) { return builder.AddStrategy( context => { var strategy = new ResultReportingResilienceStrategy<object>( options.ShouldHandle, options.OnReportResult!, context.Telemetry); return strategy; }, options); } } Usage // Add reactive strategy to the builder new ResiliencePipelineBuilder<HttpResponseMessage>() .AddResultReporting(new ResultReportingStrategyOptions<HttpResponseMessage> { // Define what outcomes to handle ShouldHandle = args => args.Outcome switch { { Exception: { } } => PredicateResult.True(), { Result: { StatusCode: HttpStatusCode.InternalServerError } } => PredicateResult.True(), _ => PredicateResult.False() }, OnReportResult = args => { Console.WriteLine($\"Result: {args.Outcome}\"); return default; } }); // You can also use the non-generic ResiliencePipelineBuilder to handle any kind of result. new ResiliencePipelineBuilder() .AddResultReporting(new ResultReportingStrategyOptions { // Define what outcomes to handle ShouldHandle = args => args.Outcome switch { { Exception: { } } => PredicateResult.True(), { Result: HttpResponseMessage message } when message.StatusCode == HttpStatusCode.InternalServerError => PredicateResult.True(), _ => PredicateResult.False() }, OnReportResult = args => { Console.WriteLine($\"Result: {args.Outcome}\"); return default; } }); Resources For further information about reactive resilience strategies, consider exploring these resources: Result reporting strategy sample: A practical example from this guide. Retry resilience strategy: Discover the built-in retry resilience strategy implementation. Fallback resilience strategy: Discover the built-in fallback resilience strategy implementation."
  },
  "general.html": {
    "href": "general.html",
    "title": "General | Polly",
    "keywords": "General Supported targets Polly targets .NET Standard 2.0+ (coverage: .NET Core 2.0+, .NET Core 3.0, .NET 6.0+ and later Mono, Xamarin and UWP targets). The NuGet package also includes direct targets for .NET Framework 4.6.1 and 4.7.2. For details of supported compilation targets by version, see the supported targets grid. Asynchronous support Polly provides native support for asynchronous operations through all its resilience strategies by offering the ExecuteAsync methods on the ResiliencePipeline class. SynchronizationContext By default, asynchronous continuations and retries do not execute on a captured synchronization context. To modify this behavior, you can use the ResilienceContext class and set its ContinueOnCapturedContext property to true. The following example illustrates this: // Retrieve an instance of ResilienceContext from the pool // with the ContinueOnCapturedContext property set to true ResilienceContext context = ResilienceContextPool.Shared.Get(continueOnCapturedContext: true); await pipeline.ExecuteAsync( static async context => { // Execute your code, honoring the ContinueOnCapturedContext setting await MyMethodAsync(context.CancellationToken).ConfigureAwait(context.ContinueOnCapturedContext); }, context); // Optionally, return the ResilienceContext instance back to the pool // to minimize allocations and enhance performance ResilienceContextPool.Shared.Return(context); Cancellation support Asynchronous pipeline execution in Polly supports cancellation. This is facilitated through the ExecuteAsync(...) method overloads that accept a CancellationToken, or by initializing the ResilienceContext class with the CancellationToken property. The CancellationToken you pass to the ExecuteAsync(...) method serves multiple functions: It cancels resilience actions such as retries, wait times between retries, or rate-limiter leases. It is passed to any delegate executed by the strategy as a CancellationToken parameter, enabling cancellation during the delegate's execution. Is consistent with the .NET Base Class Library's (BCL) behavior in Task.Run(...), if the cancellation token is cancelled before execution begins, the user-defined delegate will not execute at all. // Execute your code with cancellation support await pipeline.ExecuteAsync( static async token => await MyMethodAsync(token), cancellationToken); // Use ResilienceContext for more advanced scenarios ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken: cancellationToken); await pipeline.ExecuteAsync( static async context => await MyMethodAsync(context.CancellationToken), context); Thread safety All Polly resilience strategies are fully thread-safe. You can safely re-use strategies at multiple call sites, and execute through strategies concurrently on different threads. Important While the internal operation of the strategy is thread-safe, this does not automatically make delegates you execute through the strategy thread-safe: if delegates you execute through the strategy are not thread-safe, they remain not thread-safe."
  },
  "getting-started.html": {
    "href": "getting-started.html",
    "title": "Getting started | Polly",
    "keywords": "Getting started To use Polly, you must provide a callback and execute it using a resilience pipeline. A resilience pipeline is a combination of one or more resilience strategies such as retry, timeout, and rate limiter. Polly uses builders to integrate these strategies into a pipeline. To get started, first add the Polly.Core package to your project by running the following command: dotnet add package Polly.Core You can create a ResiliencePipeline using the ResiliencePipelineBuilder class as shown below: // Create a instance of builder that exposes various extensions for adding resilience strategies ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions()) // Add retry using the default options .AddTimeout(TimeSpan.FromSeconds(10)) // Add 10 second timeout .Build(); // Builds the resilience pipeline // Execute the pipeline asynchronously await pipeline.ExecuteAsync(static async cancellationToken => { /*Your custom logic here */ }, cancellationToken); Dependency injection If you prefer to define resilience pipelines using IServiceCollection, you'll need to install the Polly.Extensions package: dotnet add package Polly.Extensions You can then define your resilience pipeline using the AddResiliencePipeline(...) extension method as shown: var services = new ServiceCollection(); // Define a resilience pipeline with the name \"my-pipeline\" services.AddResiliencePipeline(\"my-pipeline\", builder => { builder .AddRetry(new RetryStrategyOptions()) .AddTimeout(TimeSpan.FromSeconds(10)); }); // Build the service provider IServiceProvider serviceProvider = services.BuildServiceProvider(); // Retrieve ResiliencePipelineProvider that caches and dynamically creates the resilience pipelines var pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>(); // Retrieve resilience pipeline using the name it was registered with ResiliencePipeline pipeline = pipelineProvider.GetPipeline(\"my-pipeline\"); // Execute the pipeline await pipeline.ExecuteAsync(static async token => { // Your custom logic here });"
  },
  "index.html": {
    "href": "index.html",
    "title": "Meet Polly: The .NET resilience library | Polly",
    "keywords": "Meet Polly: The .NET resilience library Polly is a powerful library for .NET that helps you handle transient faults and improve the resilience of your applications. With Polly, you can easily define and apply strategies such as Retry, Circuit Breaker, Hedging, Timeout, Rate Limiter and Fallback to handle failures and slowdowns in a fluent and thread-safe way. Polly is part of the .NET Foundation! What can Polly do for you? Polly lets you use and combine different resilience strategies to cope with various scenarios, such as: Retry: Try again if something fails. This can be useful when the problem is temporary and might go away. Circuit Breaker: Stop trying if something is broken or busy. This can benefit you by avoiding wasting time and making things worse. It can also support the system to recover. Timeout: Give up if something takes too long. This can improve your performance by freeing up space and resources. Rate Limiter: Limit how many requests you make or accept. This can enable you to control the load and prevent problems or penalties. Fallback: Do something else if something fails. This can improve your user experience and keep the program working. Hedging: Do more than one thing at the same time and take the fastest one. This can make your program faster and more responsive. You can learn more about each strategy and how to use them resilience strategies section. How to get started with Polly? Polly is easy to install and use. You can follow the getting started guide to add Polly to your project and use it for your requests. Where to find more information? Polly has a rich documentation that covers various topics, such as: Resilience strategies: A collection of strategies for improving the resilience of your system. Resilience pipelines: How to combine and reuse strategies in a flexible and modular way. Telemetry and monitoring: How to access and analyze the data generated by Polly strategies and pipelines. Dependency injection: How to integrate Polly with dependency injection frameworks and containers. Performance: Tips on optimizing and getting the best performance from Polly. Testing: How to test the composition and configuration of resilience pipelines. Chaos engineering: How to use Polly to inject faults and test the resilience of your system. Extensibility: How to create and use custom strategies and extensions for Polly. You can also find many resources and community contributions, such as: Samples: Samples in this repository that serve as an introduction to Polly. Practical Samples: Practical examples for using various implementations of Polly. Please feel free to contribute to the Polly-Samples repository in order to assist others who are either learning Polly for the first time, or are seeking advanced examples and novel approaches provided by our generous community. Polly-Contrib: Community projects and libraries that extend and enhance Polly's functionality and ecosystem. Libraries and contributions: Dependencies and contributors that make Polly possible and awesome. Microsoft's eShopOnContainers project: Sample project demonstrating a .NET Microservices architecture and using Polly for resilience. You can browse the documentation using the sidebar or visit the API section for the reference documentation."
  },
  "migration-v8.html": {
    "href": "migration-v8.html",
    "title": "Migration guide from v7 to v8 | Polly",
    "keywords": "Migration guide from v7 to v8 Welcome to the migration guide for Polly's v8 release. Version 8 of Polly brings major new enhancements and supports all of the same scenarios as previous versions. In the following sections, we'll detail the differences between the v7 and v8 APIs, and provide steps on how to transition smoothly. Note The v7 API is still available and fully supported even when using the v8 version by referencing the Polly package. Major differences The term Policy is now replaced with Strategy: In previous versions, Polly used the term policy for retries, timeouts, etc. In v8, these are referred to as resilience strategies. Introduction of Resilience Pipelines: A resilience pipeline combines one or more resilience strategies. This is the foundational API for Polly v8, similar to the Policy Wrap in previous versions but integrated into the core API. Unified sync and async flows: Interfaces such as IAsyncPolicy, IAsyncPolicy<T>, ISyncPolicy, ISyncPolicy<T>, and IPolicy are now unified under ResiliencePipeline and ResiliencePipeline<T>. The resilience pipeline supports both synchronous and asynchronous execution flows. Native async support: Polly v8 was designed with asynchronous support from the start. No static APIs: Unlike previous versions, v8 doesn't use static APIs. This improves testability and extensibility while maintaining ease of use. Options-based configuration: Configuring individual resilience strategies is now options-based, offering more flexibility and improving maintainability and extensibility. Built-in telemetry: Polly v8 now has built-in telemetry support. Improved performance and low-allocation APIs: Polly v8 brings significant performance enhancements and provides zero-allocation APIs for advanced use cases. Note Please read the comments in the code carefully for additional context and explanations. Migrating execution policies This section describes how to migrate from execution policies (i.e. IAsyncPolicy, ISyncPolicy) to resilience pipelines (i.e. ResiliencePipeline, ResiliencePipeline<T>). Configuring policies in v7 In earlier versions, Polly exposed various interfaces to execute user code: IAsyncPolicy IAsyncPolicy<T> ISyncPolicy ISyncPolicy<T> These interfaces were created and used as shown below: // Create and use the ISyncPolicy. ISyncPolicy syncPolicy = Policy.Handle<Exception>().WaitAndRetry(3, _ => TimeSpan.FromSeconds(1)); syncPolicy.Execute(() => { // Your code here }); // Create and use the IAsyncPolicy IAsyncPolicy asyncPolicy = Policy.Handle<Exception>().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1)); await asyncPolicy.ExecuteAsync( async cancellationToken => { // Your code here }, cancellationToken); // Create and use the ISyncPolicy<T> ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode) .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1)); syncPolicyT.Execute(() => { // Your code here return GetResponse(); }); // Create and use the IAsyncPolicy<T> IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode) .WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1)); await asyncPolicyT.ExecuteAsync( async cancellationToken => { // Your code here return await GetResponseAsync(cancellationToken); }, cancellationToken); Configuring strategies in v8 In Polly v8, the previous code becomes: // Create and use the ResiliencePipeline. // // The ResiliencePipelineBuilder is used to start building the resilience pipeline, // instead of the static Policy.HandleException<TException>() call. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<Exception>(), Delay = TimeSpan.FromSeconds(1), MaxRetryAttempts = 3, BackoffType = DelayBackoffType.Constant }) .Build(); // After all necessary strategies are added, call Build() to create the pipeline. // Synchronous execution pipeline.Execute(() => { // Your code here }); // Asynchronous execution is also supported with the same pipeline instance await pipeline.ExecuteAsync(static async cancellationToken => { // Your code here }, cancellationToken); // Create and use the ResiliencePipeline<T>. // // Building of generic resilience pipeline is very similar to non-generic one. // Notice the use of generic RetryStrategyOptions<HttpResponseMessage> to configure the strategy // as opposed to providing the arguments into the method. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRetry(new RetryStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<Exception>() .HandleResult(result => !result.IsSuccessStatusCode), Delay = TimeSpan.FromSeconds(1), MaxRetryAttempts = 3, BackoffType = DelayBackoffType.Constant }) .Build(); // Synchronous execution pipelineT.Execute(() => { // Your code here return GetResponse(); }); // Asynchronous execution await pipelineT.ExecuteAsync(static async cancellationToken => { // Your code here return await GetResponseAsync(cancellationToken); }, cancellationToken); Migrating policy wrap Policy wrap in v7 Policy wrap is used to combine multiple policies into one as shown in the v7 example below: IAsyncPolicy retryPolicy = Policy.Handle<Exception>().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1)); IAsyncPolicy timeoutPolicy = Policy.TimeoutAsync(TimeSpan.FromSeconds(3)); // Wrap the policies. The policies are executed in the following order (i.e. Last-In-First-Out): // 1. Retry // 2. Timeout IAsyncPolicy wrappedPolicy = Policy.WrapAsync(timeoutPolicy, retryPolicy); Policy wrap in v8 In v8, there's no need to use policy wrap explicitly. Instead, policy wrapping is integrated into ResiliencePipelineBuilder, as shown in the example below: // The \"PolicyWrap\" is integrated directly. Strategies are executed in the same order as they were added (i.e. First-In-First-Out): // 1. Retry // 2. Timeout ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new() { MaxRetryAttempts = 3, Delay = TimeSpan.FromSeconds(1), BackoffType = DelayBackoffType.Constant, ShouldHandle = new PredicateBuilder().Handle<Exception>() }) .AddTimeout(TimeSpan.FromSeconds(3)) .Build(); Important In v7, the policy wrap ordering is different; the policy added first was executed last (FILO). In v8, the execution order matches the order in which they were added (FIFO). Migrating retry policies This section describes how to migrate the v7 retry policy to a resilience strategy in v8. Retry in v7 In v7 the retry policy is configured as: // Retry once Policy .Handle<SomeExceptionType>() .Retry(); // Retry multiple times Policy .Handle<SomeExceptionType>() .Retry(3); // Retry multiple times with callback Policy .Handle<SomeExceptionType>() .Retry(3, onRetry: (exception, retryCount) => { // Add logic to be executed before each retry, such as logging }); Retry in v8 In v8 the retry strategy is configured as: // Retry once // // Because we are adding retries to a non-generic pipeline, // we use the non-generic RetryStrategyOptions. new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { // PredicateBuilder is used to simplify the initialization of predicates. // Its API should be familiar to the v7 way of configuring what exceptions to handle. ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 1, // To disable waiting between retries, set the Delay property to TimeSpan.Zero. Delay = TimeSpan.Zero, }) .Build(); // Retry multiple times new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 3, Delay = TimeSpan.Zero, }) .Build(); // Retry multiple times with callback new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 3, Delay = TimeSpan.Zero, OnRetry = args => { // Add logic to be executed before each retry, such as logging return default; } }) .Build(); // Retry forever new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), // To retry forever, set the MaxRetryAttempts property to int.MaxValue. MaxRetryAttempts = int.MaxValue, Delay = TimeSpan.Zero, }) .Build(); Retry and wait in v7 // Retry forever Policy .Handle<SomeExceptionType>() .WaitAndRetryForever(_ => TimeSpan.FromSeconds(1)); // Wait and retry multiple times Policy .Handle<SomeExceptionType>() .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1)); // Wait and retry multiple times with callback Policy .Handle<SomeExceptionType>() .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1), onRetry: (exception, retryCount) => { // Add logic to be executed before each retry, such as logging }); // Wait and retry forever Policy .Handle<SomeExceptionType>() .WaitAndRetryForever(_ => TimeSpan.FromSeconds(1)); Retry and wait in v8 // Wait and retry multiple times new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 3, Delay = TimeSpan.FromSeconds(1), BackoffType = DelayBackoffType.Constant }) .Build(); // Wait and retry multiple times with callback new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = 3, Delay = TimeSpan.FromSeconds(1), BackoffType = DelayBackoffType.Constant, OnRetry = args => { // Add logic to be executed before each retry, such as logging return default; } }) .Build(); // Wait and retry forever new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), MaxRetryAttempts = int.MaxValue, Delay = TimeSpan.FromSeconds(1), BackoffType = DelayBackoffType.Constant }) .Build(); Retry results in v7 // Wait and retry with result handling Policy .Handle<SomeExceptionType>() .OrResult<HttpResponseMessage>(response => response.StatusCode == HttpStatusCode.InternalServerError) .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1)); Retry results in v8 // Shows how to add a retry strategy that also retries particular results. new ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new RetryStrategyOptions<HttpResponseMessage> { // PredicateBuilder is a convenience API that can used to configure the ShouldHandle predicate. ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<SomeExceptionType>() .HandleResult(result => result.StatusCode == HttpStatusCode.InternalServerError), MaxRetryAttempts = 3, }) .Build(); // The same as above, but using the switch expressions for best performance. new ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new RetryStrategyOptions<HttpResponseMessage> { // Determine what results to retry using switch expressions. // Note that PredicateResult.True() is just a shortcut for \"new ValueTask<bool>(true)\". ShouldHandle = args => args.Outcome switch { { Exception: SomeExceptionType } => PredicateResult.True(), { Result: { StatusCode: HttpStatusCode.InternalServerError } } => PredicateResult.True(), _ => PredicateResult.False() }, MaxRetryAttempts = 3, }) .Build(); It's important to remember that the configuration in v8 is options based, i.e. RetryStrategyOptions are used. Migrating rate limit policies The rate limit policy is now replaced by the rate limiter strategy which uses the System.Threading.RateLimiting package. Polly does not implement its own rate limiter anymore. Rate limit in v7 // Create sync rate limiter ISyncPolicy syncPolicy = Policy.RateLimit( numberOfExecutions: 100, perTimeSpan: TimeSpan.FromMinutes(1)); // Create async rate limiter IAsyncPolicy asyncPolicy = Policy.RateLimitAsync( numberOfExecutions: 100, perTimeSpan: TimeSpan.FromMinutes(1)); // Create generic sync rate limiter ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.RateLimit<HttpResponseMessage>( numberOfExecutions: 100, perTimeSpan: TimeSpan.FromMinutes(1)); // Create generic async rate limiter IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.RateLimitAsync<HttpResponseMessage>( numberOfExecutions: 100, perTimeSpan: TimeSpan.FromMinutes(1)); Rate limit in v8 // The equivalent to Polly v7's RateLimit is the SlidingWindowRateLimiter. // // Polly exposes just a simple wrapper to the APIs exposed by the System.Threading.RateLimiting APIs. // There is no need to create separate instances for sync and async flows as ResiliencePipeline handles both scenarios. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions { PermitLimit = 100, Window = TimeSpan.FromMinutes(1), })) .Build(); // The creation of generic pipeline is almost identical. // // Polly exposes the same set of rate-limiter extensions for both ResiliencePipeline<HttpResponseMessage> and ResiliencePipeline. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions { PermitLimit = 100, Window = TimeSpan.FromMinutes(1), })) .Build(); Migrating bulkhead policies The bulkhead policy is now replaced by the rate limiter strategy which uses the System.Threading.RateLimiting package. The new counterpart to bulkhead is ConcurrencyLimiter. Note In v7, the bulkhead was presented as an individual strategy. In v8, it's not separately exposed because it's essentially a specialized type of rate limiter: the ConcurrencyLimiter. Bulkhead in v7 // Create sync bulkhead ISyncPolicy syncPolicy = Policy.Bulkhead(maxParallelization: 100, maxQueuingActions: 50); // Create async bulkhead IAsyncPolicy asyncPolicy = Policy.BulkheadAsync(maxParallelization: 100, maxQueuingActions: 50); // Create generic sync bulkhead ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.Bulkhead<HttpResponseMessage>(maxParallelization: 100, maxQueuingActions: 50); // Create generic async bulkhead IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.BulkheadAsync<HttpResponseMessage>(maxParallelization: 100, maxQueuingActions: 50); Bulkhead in v8 // Create pipeline with concurrency limiter. Because ResiliencePipeline supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddConcurrencyLimiter(permitLimit: 100, queueLimit: 50) .Build(); // Create a generic pipeline with concurrency limiter. Because ResiliencePipeline<T> supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddConcurrencyLimiter(permitLimit: 100, queueLimit: 50) .Build(); Migrating timeout policies Note In v8, the timeout resilience strategy does not support pessimistic timeouts because they can cause thread-pool starvation and non-cancellable background tasks. To address this, you can use this workaround to make the action cancellable. Timeout in v7 // Create sync timeout ISyncPolicy syncPolicy = Policy.Timeout(TimeSpan.FromSeconds(10)); // Create async timeout IAsyncPolicy asyncPolicy = Policy.TimeoutAsync(TimeSpan.FromSeconds(10)); // Create generic sync timeout ISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.Timeout<HttpResponseMessage>(TimeSpan.FromSeconds(10)); // Create generic async timeout IAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10)); Timeout in v8 // Create pipeline with timeout. Because ResiliencePipeline supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(10)) .Build(); // Create a generic pipeline with timeout. Because ResiliencePipeline<T> supports both sync and async // callbacks, there is no need to define it twice. ResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddTimeout(TimeSpan.FromSeconds(10)) .Build(); Migrating other policies Migrating is a process similar to the ones described in the previous sections. Keep in mind that: Strategy configurations (or policies in v7) are now in options. Property names should match the v7 APIs and scenarios. Use ResiliencePipelineBuilder or ResiliencePipelineBuilder<T> and their respective extensions to add specific strategies. For more details on each strategy, refer to the resilience strategies documentation. Migrating Polly.Context Polly.Context has been succeeded by ResilienceContext. Here are the main changes: ResilienceContext is pooled for enhanced performance and isn't directly creatable. Instead, use the ResilienceContextPool class to get an instance. Directly attaching custom data is supported by Context, whereas ResilienceContext employs the ResilienceContext.Properties property. Both PolicyKey and PolicyWrapKey are no longer a part of ResilienceContext. They've been relocated to ResiliencePipelineBuilder and are now used for telemetry. The CorrelationId property has been removed. For similar functionality, you can either use System.Diagnostics.Activity.Current.Id or attach your custom Id using ResilienceContext.Properties. Additionally, ResilienceContext introduces the CancellationToken property. Context in v7 // Create context Context context = new Context(); // Create context with operation key context = new Context(\"my-operation-key\"); // Attach custom properties context[\"prop-1\"] = \"value-1\"; context[\"prop-2\"] = 100; // Retrieve custom properties string value1 = (string)context[\"prop-1\"]; int value2 = (int)context[\"prop-2\"]; ResilienceContext in v8 // Create context ResilienceContext context = ResilienceContextPool.Shared.Get(); // Create context with operation key context = ResilienceContextPool.Shared.Get(\"my-operation-key\"); // Attach custom properties context.Properties.Set(new ResiliencePropertyKey<string>(\"prop-1\"), \"value-1\"); context.Properties.Set(new ResiliencePropertyKey<int>(\"prop-2\"), 100); // Retrieve custom properties string value1 = context.Properties.GetValue(new ResiliencePropertyKey<string>(\"prop-1\"), \"default\"); int value2 = context.Properties.GetValue(new ResiliencePropertyKey<int>(\"prop-2\"), 0); // Return the context to the pool ResilienceContextPool.Shared.Return(context); For more details, refer to the Resilience Context documentation. Migrating safe execution In v7, the ExecuteAndCapture{Async} methods are considered the safe counterpart of the Execute{Async}. The former does not throw an exception in case of failure rather than wrap the outcome in a result object. In v8, the ExecuteOutcomeAsync method should be used to execute the to-be-decorated method in a safe way. ExecuteAndCapture{Async} in V7 // Synchronous execution ISyncPolicy<int> syncPolicy = Policy.Timeout<int>(TimeSpan.FromSeconds(1)); PolicyResult<int> policyResult = syncPolicy.ExecuteAndCapture(Method); // Asynchronous execution IAsyncPolicy<int> asyncPolicy = Policy.TimeoutAsync<int>(TimeSpan.FromSeconds(1)); PolicyResult<int> asyncPolicyResult = await asyncPolicy.ExecuteAndCaptureAsync(MethodAsync, CancellationToken.None); // Assess policy result if (policyResult.Outcome == OutcomeType.Successful) { int result = policyResult.Result; // Process result } else { Exception exception = policyResult.FinalException; FaultType failtType = policyResult.FaultType!.Value; ExceptionType exceptionType = policyResult.ExceptionType!.Value; // Process failure } // Access context IAsyncPolicy<int> asyncPolicyWithContext = Policy.TimeoutAsync<int>(TimeSpan.FromSeconds(10), onTimeoutAsync: (ctx, ts, task) => { ctx[\"context_key\"] = \"context_value\"; return Task.CompletedTask; }); asyncPolicyResult = await asyncPolicyWithContext.ExecuteAndCaptureAsync((ctx, token) => MethodAsync(token), new Context(), CancellationToken.None); string? ctxValue = asyncPolicyResult.Context.GetValueOrDefault(\"context_key\") as string; ExecuteOutcomeAsync in V8 ResiliencePipeline<int> pipeline = new ResiliencePipelineBuilder<int>() .AddTimeout(TimeSpan.FromSeconds(1)) .Build(); // Synchronous execution // Polly v8 does not provide an API to synchronously execute and capture the outcome of a pipeline // Asynchronous execution var context = ResilienceContextPool.Shared.Get(); Outcome<int> pipelineResult = await pipeline.ExecuteOutcomeAsync( static async (ctx, state) => Outcome.FromResult(await MethodAsync(ctx.CancellationToken)), context, \"state\"); ResilienceContextPool.Shared.Return(context); // Assess policy result if (pipelineResult.Exception is null) { int result = pipelineResult.Result; // Process result } else { Exception exception = pipelineResult.Exception; // Process failure // If needed you can rethrow the exception pipelineResult.ThrowIfException(); } // Access context ResiliencePropertyKey<string> contextKey = new(\"context_key\"); ResiliencePipeline<int> pipelineWithContext = new ResiliencePipelineBuilder<int>() .AddTimeout(new TimeoutStrategyOptions { Timeout = TimeSpan.FromSeconds(1), OnTimeout = args => { args.Context.Properties.Set(contextKey, \"context_value\"); return default; } }) .Build(); context = ResilienceContextPool.Shared.Get(); pipelineResult = await pipelineWithContext.ExecuteOutcomeAsync( static async (ctx, state) => Outcome.FromResult(await MethodAsync(ctx.CancellationToken)), context, \"state\"); context.Properties.TryGetValue(contextKey, out var ctxValue); ResilienceContextPool.Shared.Return(context); Migrating no-op policies For Policy.NoOp or Policy.NoOpAsync, switch to ResiliencePipeline.Empty. For Policy.NoOp<T> or Policy.NoOpAsync<T>, switch to ResiliencePipeline<T>.Empty. Migrating policy registries In v7, the following registry APIs are exposed: IPolicyRegistry<T> IReadOnlyPolicyRegistry<T> IConcurrentPolicyRegistry<T> PolicyRegistry<T> In v8, these have been replaced by: ResiliencePipelineProvider<TKey>: Allows adding and accessing resilience pipelines. ResiliencePipelineRegistry<TKey>: Read-only access to resilience pipelines. The main updates in the new registry include: It's append-only, which means removal of items is not supported to avoid race conditions. It's thread-safe and supports features like dynamic reloading and resource disposal. It allows dynamic creation and caching of resilience pipelines (previously known as policies in v7) using pre-registered delegates. Type safety is enhanced, eliminating the need for casting between policy types. For more details, refer to the pipeline registry documentation. Registry in v7 // Create a registry var registry = new PolicyRegistry(); // Try get a policy registry.TryGet<IAsyncPolicy>(\"my-key\", out IAsyncPolicy? policy); // Try get a generic policy registry.TryGet<IAsyncPolicy<string>>(\"my-key\", out IAsyncPolicy<string>? genericPolicy); // Add a policy registry.Add(\"my-key\", Policy.Timeout(TimeSpan.FromSeconds(10))); // Update a policy registry.AddOrUpdate( \"my-key\", Policy.Timeout(TimeSpan.FromSeconds(10)), (key, previous) => Policy.Timeout(TimeSpan.FromSeconds(10))); Registry in v8 // Create a registry var registry = new ResiliencePipelineRegistry<string>(); // Try get a pipeline registry.TryGetPipeline(\"my-key\", out ResiliencePipeline? pipeline); // Try get a generic pipeline registry.TryGetPipeline<string>(\"my-key\", out ResiliencePipeline<string>? genericPipeline); // Add a pipeline using a builder, when \"my-key\" pipeline is retrieved it will be dynamically built and cached registry.TryAddBuilder(\"my-key\", (builder, context) => builder.AddTimeout(TimeSpan.FromSeconds(10))); // Get or add pipeline registry.GetOrAddPipeline(\"my-key\", builder => builder.AddTimeout(TimeSpan.FromSeconds(10))); Interoperability between policies and resilience pipelines In certain scenarios, you might not want to migrate your code to the v8 API. Instead, you may prefer to use strategies from v8 and apply them to v7 APIs. Polly provides a set of extension methods to support easy conversion from v8 to v7 APIs, as shown in the example below: // First, create a resilience pipeline. ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRateLimiter(new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions { Window = TimeSpan.FromSeconds(10), PermitLimit = 100 })) .Build(); // Now, convert it to a v7 policy. Note that it can be converted to both sync and async policies. ISyncPolicy syncPolicy = pipeline.AsSyncPolicy(); IAsyncPolicy asyncPolicy = pipeline.AsAsyncPolicy(); // Finally, use it in a policy wrap. ISyncPolicy wrappedPolicy = Policy.Wrap( syncPolicy, Policy.Handle<SomeExceptionType>().Retry(3));"
  },
  "pipelines/index.html": {
    "href": "pipelines/index.html",
    "title": "Resilience pipelines | Polly",
    "keywords": "Resilience pipelines The ResiliencePipeline allows executing arbitrary user-provided callbacks. It is a combination of one or more resilience strategies. Usage The ResiliencePipeline allow executing various synchronous and asynchronous user-provided callbacks as seen in the examples below: // Creating a new resilience pipeline ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddConcurrencyLimiter(100) .Build(); // Executing an asynchronous void callback await pipeline.ExecuteAsync( async token => await MyMethodAsync(token), cancellationToken); // Executing a synchronous void callback pipeline.Execute(() => MyMethod()); // Executing an asynchronous callback that returns a value await pipeline.ExecuteAsync( async token => await httpClient.GetAsync(endpoint, token), cancellationToken); // Executing an asynchronous callback without allocating a lambda await pipeline.ExecuteAsync( static async (state, token) => await state.httpClient.GetAsync(state.endpoint, token), (httpClient, endpoint), // State provided here cancellationToken); // Executing an asynchronous callback and passing custom data // 1. Retrieve a context from the shared pool ResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken); // 2. Add custom data to the context context.Properties.Set(new ResiliencePropertyKey<string>(\"my-custom-data\"), \"my-custom-data\"); // 3. Execute the callback await pipeline.ExecuteAsync(static async context => { // Retrieve custom data from the context var customData = context.Properties.GetValue( new ResiliencePropertyKey<string>(\"my-custom-data\"), \"default-value\"); Console.WriteLine(\"Custom Data: {0}\", customData); await MyMethodAsync(context.CancellationToken); }, context); // 4. Optionally, return the context to the shared pool ResilienceContextPool.Shared.Return(context); The above samples demonstrate how to use the resilience pipeline within the same scope. Additionally, consider the following: Separate the resilience pipeline's definition from its usage. Inject pipelines into the code that will consume them. This facilitates various unit-testing scenarios. If your application uses Polly in multiple locations, define all pipelines at startup using ResiliencePipelineRegistry or using the AddResiliencePipeline extension. This is a common approach in .NET Core applications. For example, you could create your own extension method on IServiceCollection to configure pipelines consumed elsewhere in your application. public static void ConfigureMyPipelines(IServiceCollection services) { services.AddResiliencePipeline(\"pipeline-A\", builder => builder.AddConcurrencyLimiter(100)); services.AddResiliencePipeline(\"pipeline-B\", builder => builder.AddRetry(new())); // Later, resolve the pipeline by name using ResiliencePipelineProvider<string> or ResiliencePipelineRegistry<string> var pipelineProvider = services.BuildServiceProvider().GetRequiredService<ResiliencePipelineProvider<string>>(); pipelineProvider.GetPipeline(\"pipeline-A\").Execute(() => { }); } Empty resilience pipeline The empty resilience pipeline is a special construct that lacks any resilience strategies. You can access it through the following ways: ResiliencePipeline.Empty ResiliencePipeline<T>.Empty This is particularly useful in test scenarios where implementing resilience strategies could slow down the test execution or over-complicate test setup. Retrieving execution results with Outcome<T> The ResiliencePipeline class provides the ExecuteOutcomeAsync(...) method, which is designed to never throw exceptions. Instead, it stores either the result or the exception within an Outcome<T> struct. // Acquire a ResilienceContext from the pool ResilienceContext context = ResilienceContextPool.Shared.Get(); // Execute the pipeline and store the result in an Outcome<bool> Outcome<bool> outcome = await pipeline.ExecuteOutcomeAsync( static async (context, state) => { Console.WriteLine(\"State: {0}\", state); try { await MyMethodAsync(context.CancellationToken); // Use static utility methods from Outcome to easily create an Outcome<T> instance return Outcome.FromResult(true); } catch (Exception e) { // Create an Outcome<T> instance that holds the exception return Outcome.FromException<bool>(e); } }, context, \"my-state\"); // Return the acquired ResilienceContext to the pool ResilienceContextPool.Shared.Return(context); // Evaluate the outcome if (outcome.Exception is not null) { Console.WriteLine(\"Execution Failed: {0}\", outcome.Exception.Message); } else { Console.WriteLine(\"Execution Result: {0}\", outcome.Result); } Use ExecuteOutcomeAsync(...) in high-performance scenarios where you wish to avoid re-throwing exceptions. Keep in mind that Polly's resilience strategies also make use of the Outcome struct to prevent unnecessary exception throwing."
  },
  "pipelines/resilience-pipeline-registry.html": {
    "href": "pipelines/resilience-pipeline-registry.html",
    "title": "Resilience pipeline registry | Polly",
    "keywords": "Resilience pipeline registry Note This documentation supports the upcoming Polly v8 release. The ResiliencePipelineRegistry<TKey> is designed to create and cache resilience pipeline instances. The registry also implements the ResiliencePipelineProvider<TKey>, allowing read-only access to pipelines. The registry offers these features: Thread-safe retrieval and dynamic creation for both generic and non-generic resilience pipelines. Dynamic reloading of resilience pipelines when configurations change. Capability to register both generic and non-generic resilience pipeline builders, enabling dynamic pipeline instance creation. Automated resource management, which includes disposing of resources linked to resilience pipelines. Note The generic TKey parameter sets the key type for caching individual resilience pipelines within the registry. Typically, you would use the string-based ResiliencePipelineRegistry<string>. Usage To register pipeline builders, use the TryAddBuilder(...) method. This method accepts a callback argument that configures an instance of ResiliencePipelineBuilder for the pipeline being defined. The registry supports both generic and non-generic resilience pipelines. Here's an example demonstrating these features: var registry = new ResiliencePipelineRegistry<string>(); // Register builder for pipeline \"A\" registry.TryAddBuilder(\"A\", (builder, context) => { // Define your pipeline builder.AddRetry(new RetryStrategyOptions()); }); // Register generic builder for pipeline \"A\"; you can use the same key // because generic and non-generic pipelines are stored separately registry.TryAddBuilder<HttpResponseMessage>(\"A\", (builder, context) => { // Define your pipeline builder.AddRetry(new RetryStrategyOptions<HttpResponseMessage>()); }); // Fetch pipeline \"A\" ResiliencePipeline pipelineA = registry.GetPipeline(\"A\"); // Fetch generic pipeline \"A\" ResiliencePipeline<HttpResponseMessage> genericPipelineA = registry.GetPipeline<HttpResponseMessage>(\"A\"); // Returns false since pipeline \"unknown\" isn't registered registry.TryGetPipeline(\"unknown\", out var pipeline); // Throws KeyNotFoundException because pipeline \"unknown\" isn't registered try { registry.GetPipeline(\"unknown\"); } catch (KeyNotFoundException) { // Handle the exception } Additionally, the registry allows you to add pipelines with the GetOrAddPipeline(...) method. In this method, there's no need to register builders. Instead, the caller provides a factory method called when the pipeline isn't cached: var registry = new ResiliencePipelineRegistry<string>(); // Dynamically retrieve or create pipeline \"A\" ResiliencePipeline pipeline = registry.GetOrAddPipeline(\"A\", (builder, context) => { // Define your pipeline builder.AddRetry(new RetryStrategyOptions()); }); // Dynamically retrieve or create generic pipeline \"A\" ResiliencePipeline<HttpResponseMessage> genericPipeline = registry.GetOrAddPipeline<HttpResponseMessage>(\"A\", (builder, context) => { // Define your pipeline builder.AddRetry(new RetryStrategyOptions<HttpResponseMessage>()); }); Registry options The constructor for ResiliencePipelineRegistry<TKey> accepts a parameter of type ResiliencePipelineRegistryOptions<TKey>. This parameter lets you configure the behavior of the registry. Here's a breakdown of the available properties: Property Default Value Description BuilderFactory Function returning a new ResiliencePipelineBuilder each time. Allows consumers to customize builder creation. PipelineComparer EqualityComparer<TKey>.Default Comparer the registry uses to fetch resilience pipelines. BuilderComparer EqualityComparer<TKey>.Default Comparer the registry uses to fetch registered pipeline builders. InstanceNameFormatter null Delegate formatting TKey to instance name. BuilderNameFormatter Function returning the key.ToString() value. Delegate formatting TKey to builder name. [>NOTE] The BuilderName and InstanceName are used in telemetry. Usage example: var options = new ResiliencePipelineRegistryOptions<string> { BuilderComparer = StringComparer.OrdinalIgnoreCase, PipelineComparer = StringComparer.OrdinalIgnoreCase, BuilderFactory = () => new ResiliencePipelineBuilder { InstanceName = \"lets change the defaults\", Name = \"lets change the defaults\", }, BuilderNameFormatter = key => $\"key:{key}\", InstanceNameFormatter = key => $\"instance-key:{key}\", }; var registry = new ResiliencePipelineRegistry<string>(); Even though the example might seem unnecessary, given that the defaults for a registry using the string type are suitable, it showcases the various properties of the registry and how to set them up. This is particularly helpful when you use complex registry keys. Dynamic reloads Dynamic reloading lets you refresh cached pipelines when the reload token, represented as a CancellationToken, is triggered. To enable dynamic reloads: var registry = new ResiliencePipelineRegistry<string>(); registry.TryAddBuilder(\"A\", (builder, context) => { // Add the reload token. Tokens that are already canceled are ignored. context.AddReloadToken(cancellationToken); // Define the pipeline. builder.AddRetry(new RetryStrategyOptions()); }); // This instance remains valid even after a reload. ResiliencePipeline pipeline = registry.GetPipeline(\"A\"); If an error occurs during reloading, the cached pipeline remains, and dynamic reloading stops. You should not reuse the cancellation token when the pipeline is reloaded. Pipelines enabled for reloads remain valid and current post-reload. The registry manages this transparently. Resource disposal The registry caches and manages all pipelines and resources linked to them. When you dispose of the registry, all pipelines created by it are also disposed of and can't be used anymore. The following example illustrates this: var registry = new ResiliencePipelineRegistry<string>(); // This instance is valid even after reload. ResiliencePipeline pipeline = registry .GetOrAddPipeline(\"A\", (builder, context) => builder.AddTimeout(TimeSpan.FromSeconds(10))); // Dispose the registry registry.Dispose(); try { pipeline.Execute(() => { }); } catch (ObjectDisposedException) { // Using a pipeline that was disposed by the registry } The registry also allows for the registration of dispose callbacks. These are called when a pipeline is discarded, either because of the registry's disposal or after the pipeline has reloaded. The example below works well with dynamic reloads, letting you dispose of the CancellationTokenSource when it's not needed anymore. var registry = new ResiliencePipelineRegistry<string>(); registry.TryAddBuilder(\"A\", (builder, context) => { var cancellation = new CancellationTokenSource(); // Register the source for potential external triggering RegisterCancellationSource(cancellation); // Add the reload token; note that an already cancelled token is disregarded context.AddReloadToken(cancellation.Token); // Configure your pipeline builder.AddRetry(new RetryStrategyOptions()); context.OnPipelineDisposed(() => cancellation.Dispose()); }); Both AddReloadToken(...) and OnPipelineDisposed(...) are used to implement the EnableReloads<TOptions>(...) extension method that is used by the Dependency Injection layer. Complex registry keys Though the pipeline registry supports complex keys, we suggest you use them when defining pipelines with the Dependency Injection (DI) containers. For further information, see the section on complex pipeline keys."
  },
  "strategies/circuit-breaker.html": {
    "href": "strategies/circuit-breaker.html",
    "title": "Circuit breaker resilience strategy | Polly",
    "keywords": "Circuit breaker resilience strategy About Options: CircuitBreakerStrategyOptions CircuitBreakerStrategyOptions<T> Extensions: AddCircuitBreaker Strategy Type: Reactive Exceptions: BrokenCircuitException: Thrown when a circuit is broken and the action could not be executed. IsolatedCircuitException: Thrown when a circuit is isolated (held open) by manual override. Note Be aware that the Circuit Breaker strategy rethrows all exceptions, including those that are handled. A Circuit Breaker's role is to monitor faults and break the circuit when a certain threshold is reached; it does not manage retries. Combine the Circuit Breaker with a Retry strategy if needed. Usage // Add circuit breaker with default options. // See https://www.pollydocs.org/strategies/circuit-breaker#defaults for defaults. new ResiliencePipelineBuilder().AddCircuitBreaker(new CircuitBreakerStrategyOptions()); // Add circuit breaker with customized options: // // The circuit will break if more than 50% of actions result in handled exceptions, // within any 10-second sampling duration, and at least 8 actions are processed. new ResiliencePipelineBuilder().AddCircuitBreaker(new CircuitBreakerStrategyOptions { FailureRatio = 0.5, SamplingDuration = TimeSpan.FromSeconds(10), MinimumThroughput = 8, BreakDuration = TimeSpan.FromSeconds(30), ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>() }); // Handle specific failed results for HttpResponseMessage: new ResiliencePipelineBuilder<HttpResponseMessage>() .AddCircuitBreaker(new CircuitBreakerStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<SomeExceptionType>() .HandleResult(response => response.StatusCode == HttpStatusCode.InternalServerError) }); // Monitor the circuit state, useful for health reporting: var stateProvider = new CircuitBreakerStateProvider(); new ResiliencePipelineBuilder<HttpResponseMessage>() .AddCircuitBreaker(new() { StateProvider = stateProvider }) .Build(); /* CircuitState.Closed - Normal operation; actions are executed. CircuitState.Open - Circuit is open; actions are blocked. CircuitState.HalfOpen - Recovery state after break duration expires; actions are permitted. CircuitState.Isolated - Circuit is manually held open; actions are blocked. */ // Manually control the Circuit Breaker state: var manualControl = new CircuitBreakerManualControl(); new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ManualControl = manualControl }) .Build(); // Manually isolate a circuit, e.g., to isolate a downstream service. await manualControl.IsolateAsync(); // Manually close the circuit to allow actions to be executed again. await manualControl.CloseAsync(); Defaults Property Default Value Description ShouldHandle Predicate that handles all exceptions except OperationCanceledException. Specifies which results and exceptions are managed by the circuit breaker strategy. FailureRatio 0.1 The ratio of failures to successes that will cause the circuit to break/open. MinimumThroughput 100 The minimum number of actions that must occur in the circuit within a specific time slice. SamplingDuration 30 seconds The time period over which failure ratios are calculated. BreakDuration 5 seconds The time period for which the circuit will remain broken/open before attempting to reset. OnClosed null Event triggered when the circuit transitions to the Closed state. OnOpened null Event triggered when the circuit transitions to the Opened state. OnHalfOpened null Event triggered when the circuit transitions to the HalfOpened state. ManualControl null Allows for manual control to isolate or close the circuit. StateProvider null Enables the retrieval of the current state of the circuit. Resources Making the Netflix API More Resilient Circuit Breaker by Martin Fowler Circuit Breaker Pattern by Microsoft Original Circuit Breaking Article Patterns and anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. This section highlights the recommended practices and those to avoid. 1 - Using different sleep duration between retry attempts based on Circuit Breaker state Imagine that we have an inner Circuit Breaker and an outer Retry strategies. We would like to define the retry in a way that the sleep duration calculation is taking into account the Circuit Breaker's state. ❌ DON'T Use a closure to branch based on circuit breaker state: var stateProvider = new CircuitBreakerStateProvider(); var circuitBreaker = new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), BreakDuration = TimeSpan.FromSeconds(5), StateProvider = stateProvider }) .Build(); var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<HttpRequestException>() .Handle<BrokenCircuitException>(), DelayGenerator = args => { TimeSpan? delay = TimeSpan.FromSeconds(1); if (stateProvider.CircuitState == CircuitState.Open) { delay = TimeSpan.FromSeconds(5); } return ValueTask.FromResult(delay); } }) .Build(); Reasoning: By default, each strategy is independent and has no any reference to other strategies. We use the (stateProvider) to access the Circuit Breaker's state. However, this approach is not optimal as the retry strategy's DelayGenerator varies based on state. This solution is delicate because the break duration and the sleep duration aren't linked. If a future code maintainer modifies the circuitBreaker's BreakDuration, they might overlook adjusting the sleep duration. ✅ DO Use Context to pass information between strategies: var circuitBreaker = new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), BreakDuration = TimeSpan.FromSeconds(5), OnOpened = static args => { args.Context.Properties.Set(SleepDurationKey, args.BreakDuration); return ValueTask.CompletedTask; }, OnClosed = args => { args.Context.Properties.Set(SleepDurationKey, null); return ValueTask.CompletedTask; } }) .Build(); var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<HttpRequestException>() .Handle<BrokenCircuitException>(), DelayGenerator = static args => { _ = args.Context.Properties.TryGetValue(SleepDurationKey, out var delay); delay ??= TimeSpan.FromSeconds(1); return ValueTask.FromResult(delay); } }) .Build(); Reasoning: Both strategies are less coupled in this approach since they rely on the context and the sleepDurationKey components. The Circuit Breaker shares the BreakDuration through the context when it breaks. When it transitions back to Closed, the sharring is revoked. The Retry strategy fetches the sleep duration dynamically without knowing any specific knowledge about the Circuit Breaker. If adjustments are needed for the BreakDuration, they can be made in one place. 2 - Using different duration for breaks In the case of Retry you can specify dynamically the sleep duration via the DelayGenerator. In the case of Circuit Breaker the BreakDuration is considered constant (can't be changed between breaks). ❌ DON'T Use Task.Delay inside OnOpened: static IEnumerable<TimeSpan> GetSleepDuration() { for (int i = 1; i < 10; i++) { yield return TimeSpan.FromSeconds(i); } } var sleepDurationProvider = GetSleepDuration().GetEnumerator(); sleepDurationProvider.MoveNext(); var circuitBreaker = new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), BreakDuration = TimeSpan.FromSeconds(0.5), OnOpened = async args => { await Task.Delay(sleepDurationProvider.Current); sleepDurationProvider.MoveNext(); } }) .Build(); Reasoning: The minimum break duration value is half a second. This implies that each sleep lasts for sleepDurationProvider.Current plus an additional half a second. One might think that setting the BreakDuration to sleepDurationProvider.Current would address this, but it doesn't. This is because the BreakDuration is established only once and isn't re-assessed during each break. circuitBreaker = new ResiliencePipelineBuilder() .AddCircuitBreaker(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), BreakDuration = sleepDurationProvider.Current, OnOpened = async args => { Console.WriteLine($\"Break: {sleepDurationProvider.Current}\"); sleepDurationProvider.MoveNext(); } }) .Build(); ✅ DO The CircuitBreakerStartegyOptions currently do not support defining break durations dynamically. This may be re-evaluted in the future. For now, refer to the first example for a potential workaround. However, please use it with caution. 3 - Wrapping each endpoint with a circuit breaker Imagine that you have to call N number of services via HttpClients. You want to decorate all downstream calls with the service-aware Circuit Breaker. ❌ DON'T Use a collection of Circuit Breakers and explicitly call ExecuteAsync(): // Defined in a common place var uriToCbMappings = new Dictionary<Uri, ResiliencePipeline> { [new Uri(\"https://downstream1.com\")] = GetCircuitBreaker(), // ... [new Uri(\"https://downstreamN.com\")] = GetCircuitBreaker() }; // Used in the downstream 1 client var downstream1Uri = new Uri(\"https://downstream1.com\"); await uriToCbMappings[downstream1Uri].ExecuteAsync(CallXYZOnDownstream1, CancellationToken.None); Reasoning: Whenever you use an HttpClient, you must have a reference to the uriToCbMappings dictionary. It's your responsibility to decorate each network call with the corresponding circuit breaker. ✅ DO Use named and typed HttpClients: foreach (string uri in uris) { builder.Services .AddHttpClient<IResilientClient, ResilientClient>(uri, client => client.BaseAddress = new Uri(uri)) .AddPolicyHandler(GetCircuitBreaker().AsAsyncPolicy<HttpResponseMessage>()); } ... private const string serviceUrl = \"https://downstream1.com\"; public Downstream1Client( IHttpClientFactory namedClientFactory, ITypedHttpClientFactory<ResilientClient> typedClientFactory) { var namedClient = namedClientFactory.CreateClient(serviceUrl); var namedTypedClient = typedClientFactory.CreateClient(namedClient); ... } Reasoning: The HttpClient integrates with Circuit Breaker during startup. There's no need to call ExecuteAsync() directly. The DelegatingHandler handles it automatically. Note The above sample code used the AsAsyncPolicy<HttpResponseMessage>() method to convert the ResiliencePipeline<HttpResponseMessage> to IAsyncPolicy<HttpResponseMessage>. It is required because the AddPolicyHandler() method anticipates an IAsyncPolicy<HttpResponse> parameter. Please be aware that, later an AddResilienceHandler() will be introduced in the Microsoft.Extensions.Http.Resilience package which is the successor of the Microsoft.Extensions.Http.Polly."
  },
  "strategies/fallback.html": {
    "href": "strategies/fallback.html",
    "title": "Fallback resilience strategy | Polly",
    "keywords": "Fallback resilience strategy About Options: FallbackStrategyOptions<T> Extensions: AddFallback Strategy Type: Reactive Usage // Add a fallback/substitute value if an operation fails. new ResiliencePipelineBuilder<UserAvatar>() .AddFallback(new FallbackStrategyOptions<UserAvatar> { ShouldHandle = new PredicateBuilder<UserAvatar>() .Handle<SomeExceptionType>() .HandleResult(r => r is null), FallbackAction = args => Outcome.FromResultAsValueTask(UserAvatar.Blank) }); // Use a dynamically generated value if an operation fails. new ResiliencePipelineBuilder<UserAvatar>() .AddFallback(new FallbackStrategyOptions<UserAvatar> { ShouldHandle = new PredicateBuilder<UserAvatar>() .Handle<SomeExceptionType>() .HandleResult(r => r is null), FallbackAction = args => { var avatar = UserAvatar.GetRandomAvatar(); return Outcome.FromResultAsValueTask(avatar); } }); // Use a default or dynamically generated value, and execute an additional action if the fallback is triggered. new ResiliencePipelineBuilder<UserAvatar>() .AddFallback(new FallbackStrategyOptions<UserAvatar> { ShouldHandle = new PredicateBuilder<UserAvatar>() .Handle<SomeExceptionType>() .HandleResult(r => r is null), FallbackAction = args => { var avatar = UserAvatar.GetRandomAvatar(); return Outcome.FromResultAsValueTask(UserAvatar.Blank); }, OnFallback = args => { // Add extra logic to be executed when the fallback is triggered, such as logging. return default; // Returns an empty ValueTask } }); Defaults Property Default Value Description ShouldHandle Predicate that handles all exceptions except OperationCanceledException. Predicate that determines what results and exceptions are handled by the fallback strategy. FallbackAction Null, Required Fallback action to be executed. OnFallback null Event that is raised when fallback happens. Patterns and anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. This section highlights the recommended practices and ones to avoid. 1 - Using fallback to replace thrown exception ❌ DON'T Throw custom exceptions from the OnFallback delegate: var fallback = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddFallback(new() { ShouldHandle = new PredicateBuilder<HttpResponseMessage>().Handle<HttpRequestException>(), FallbackAction = args => Outcome.FromResultAsValueTask(new HttpResponseMessage()), OnFallback = args => throw new CustomNetworkException(\"Replace thrown exception\", args.Outcome.Exception!) }) .Build(); Reasoning: Throwing an exception from a user-defined delegate can disrupt the normal control flow. ✅ DO Use ExecuteOutcomeAsync and then evaluate the Exception: var outcome = await WhateverPipeline.ExecuteOutcomeAsync(Action, context, \"state\"); if (outcome.Exception is HttpRequestException requestException) { throw new CustomNetworkException(\"Replace thrown exception\", requestException); } Reasoning: This method lets you execute the strategy or pipeline smoothly, without unexpected interruptions. If you repeatedly find yourself writing this exception \"remapping\" logic, consider marking the method you wish to decorate as private and expose the \"remapping\" logic publicly. public static async ValueTask<HttpResponseMessage> Action() { var context = ResilienceContextPool.Shared.Get(); var outcome = await WhateverPipeline.ExecuteOutcomeAsync<HttpResponseMessage, string>( async (ctx, state) => { var result = await ActionCore(); return Outcome.FromResult(result); }, context, \"state\"); if (outcome.Exception is HttpRequestException requestException) { throw new CustomNetworkException(\"Replace thrown exception\", requestException); } ResilienceContextPool.Shared.Return(context); return outcome.Result!; } private static ValueTask<HttpResponseMessage> ActionCore() { // The core logic return ValueTask.FromResult(new HttpResponseMessage()); } 2 - Using retry for fallback Suppose you have a primary and a secondary endpoint. If the primary fails, you want to call the secondary. ❌ DON'T Use retry for fallback: var fallback = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRetry(new() { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .HandleResult(res => res.StatusCode == HttpStatusCode.RequestTimeout), MaxRetryAttempts = 1, OnRetry = async args => { args.Context.Properties.Set(fallbackKey, await CallSecondary(args.Context.CancellationToken)); } }) .Build(); var context = ResilienceContextPool.Shared.Get(); var outcome = await fallback.ExecuteOutcomeAsync<HttpResponseMessage, string>( async (ctx, state) => { var result = await CallPrimary(ctx.CancellationToken); return Outcome.FromResult(result); }, context, \"none\"); var result = outcome.Result is not null ? outcome.Result : context.Properties.GetValue(fallbackKey, default); ResilienceContextPool.Shared.Return(context); return result; Reasoning: A retry strategy by default executes the same operation up to N times, where N equals the initial attempt plus MaxRetryAttempts. In this case, that means 2 times. Here, the fallback is introduced as a side effect rather than a replacement. ✅ DO Use fallback to call the secondary: var fallback = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddFallback(new() { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .HandleResult(res => res.StatusCode == HttpStatusCode.RequestTimeout), OnFallback = async args => await CallSecondary(args.Context.CancellationToken) }) .Build(); return await fallback.ExecuteAsync(CallPrimary, CancellationToken.None); Reasoning: The target code is executed only once. The fallback value is returned directly, eliminating the need for additional code like Context or ExecuteOutcomeAsync(). 3 - Nesting ExecuteAsync calls Combining multiple strategies can be achieved in various ways. However, deeply nesting ExecuteAsync calls can lead to what's commonly referred to as Execute Hell. Note While this isn't strictly tied to the Fallback mechanism, it's frequently observed when Fallback is the outermost layer. ❌ DON'T Nest ExecuteAsync calls: var result = await fallback.ExecuteAsync(async (CancellationToken outerCT) => { return await timeout.ExecuteAsync(static async (CancellationToken innerCT) => { return await CallExternalSystem(innerCT); }, outerCT); }, CancellationToken.None); return result; Reasoning: This is akin to JavaScript's callback hell or the pyramid of doom. It's easy to mistakenly reference the wrong CancellationToken parameter. ✅ DO Use ResiliencePipelineBuilder to chain strategies: var pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddPipeline(timeout) .AddPipeline(fallback) .Build(); return await pipeline.ExecuteAsync(CallExternalSystem, CancellationToken.None); Reasoning: In this approach, we leverage the escalation mechanism provided by Polly rather than creating our own through nesting. CancellationToken values are automatically propagated between the strategies for you."
  },
  "strategies/hedging.html": {
    "href": "strategies/hedging.html",
    "title": "Hedging resilience strategy | Polly",
    "keywords": "Hedging resilience strategy About Options: HedgingStrategyOptions<T> Extensions: AddHedging Strategy Type: Reactive The hedging strategy enables the re-execution of a user-defined callback if the previous execution takes too long. This approach gives you the option to either run the original callback again or specify a new callback for subsequent hedged attempts. Implementing a hedging strategy can boost the overall responsiveness of the system. However, it's essential to note that this improvement comes at the cost of increased resource utilization. If low latency is not a critical requirement, you may find the retry strategy is more appropriate. This strategy also supports multiple concurrency modes for added flexibility. Note Please do not start any background work when executing actions using the hedging strategy. This strategy can spawn multiple parallel tasks, and as a result multiple background tasks can be started. Usage // Add hedging with default options. // See https://www.pollydocs.org/strategies/hedging#defaults for defaults. new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new HedgingStrategyOptions<HttpResponseMessage>()); // Add a customized hedging strategy that retries up to 3 times if the execution // takes longer than 1 second or if it fails due to an exception or returns an HTTP 500 Internal Server Error. new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new HedgingStrategyOptions<HttpResponseMessage> { ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .Handle<SomeExceptionType>() .HandleResult(response => response.StatusCode == HttpStatusCode.InternalServerError), MaxHedgedAttempts = 3, Delay = TimeSpan.FromSeconds(1), ActionGenerator = args => { Console.WriteLine(\"Preparing to execute hedged action.\"); // Return a delegate function to invoke the original action with the action context. // Optionally, you can also create a completely new action to be executed. return () => args.Callback(args.ActionContext); } }); // Subscribe to hedging events. new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new HedgingStrategyOptions<HttpResponseMessage> { OnHedging = args => { Console.WriteLine($\"OnHedging: Attempt number {args.AttemptNumber}\"); return default; } }); Defaults Property Default Value Description ShouldHandle Predicate that handles all exceptions except OperationCanceledException. Predicate that determines what results and exceptions are handled by the retry strategy. MaxHedgedAttempts 1 The maximum number of hedged actions to use, in addition to the original action. Delay 2 seconds The maximum waiting time before spawning a new hedged action. ActionGenerator Returns the original callback that was passed to the hedging strategy. Generator that creates hedged actions. DelayGenerator null Used for generating custom delays for hedging. If null then Delay is used. OnHedging null Event that is raised when a hedging is performed. You can use the following special values for Delay or in DelayGenerator: 0 seconds - the hedging strategy immediately creates a total of MaxHedgedAttempts and completes when the fastest acceptable result is available. -1 millisecond - this value indicates that the strategy does not create a new hedged task before the previous one completes. This enables scenarios where having multiple concurrent hedged tasks can cause side effects. Concurrency modes In the sections below, explore the different concurrency modes available in the hedging strategy. The behavior is primarily controlled by the Delay property value. Latency mode When the Delay property is set to a value greater than zero, the hedging strategy operates in latency mode. In this mode, additional executions are triggered when the initial ones take too long to complete. By default, the Delay is set to 2 seconds. The primary execution is initiated. If the initial execution either fails or takes longer than the Delay to complete, a new execution is initiated. If the first two executions fail or exceed the Delay (calculated from the last initiated execution), another execution is triggered. The final result is the result of fastest successful execution. If all executions fail, the final result will be the first failure encountered. Fallback mode In fallback mode, the Delay value should be less than TimeSpan.Zero. This mode allows only a single execution to proceed at a given time. An execution is initiated, and the strategy waits for its completion. If the initial execution fails, new one is initiated. The final result will be the first successful execution. If all executions fail, the final result will be the first failure encountered. Parallel mode The hedging strategy operates in parallel mode when the Delay property is set to TimeSpan.Zero. In this mode, all executions are initiated simultaneously, and the strategy waits for the fastest completion. Important Use this mode only when absolutely necessary, as it consumes the most resources, particularly when the hedging strategy uses remote resources such as remote HTTP services. All executions are initiated simultaneously, adhering to the MaxHedgedAttempts limit. The final result will be the fastest successful execution. If all executions fail, the final result will be the first failure encountered. Dynamic mode In dynamic mode, you have the flexibility to control how the hedging strategy behaves during each execution. This control is achieved through the DelayGenerator property. Note The Delay property is disregarded when DelayGenerator is set. Example scenario: First, initiate the first two executions in parallel mode. Subsequently, switch to fallback mode for additional executions. To configure hedging according to the above scenario, use the following code: new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new() { MaxHedgedAttempts = 3, DelayGenerator = args => { var delay = args.AttemptNumber switch { 0 => TimeSpan.FromSeconds(1), 1 => TimeSpan.FromSeconds(2), _ => System.Threading.Timeout.InfiniteTimeSpan }; return new ValueTask<TimeSpan>(delay); } }); With this configuration, the hedging strategy: Initiates a maximum of 4 executions. This includes initial action and an additional 3 attempts. Allows the first two executions to proceed in parallel, while the third and fourth executions follow the fallback mode. Action generator The hedging options include an ActionGenerator property, allowing you to customize the actions executed during hedging. By default, the ActionGenerator returns the original callback passed to the strategy. The original callback also includes any logic introduced by subsequent resilience strategies. For more advanced scenarios, the ActionGenerator can be used to return entirely new hedged actions, as demonstrated in the example below: new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new() { ActionGenerator = args => { // You can access data from the original (primary) context here var customData = args.PrimaryContext.Properties.GetValue(customDataKey, \"default-custom-data\"); Console.WriteLine($\"Hedging, Attempt: {args.AttemptNumber}, Custom Data: {customData}\"); // Here, we can access the original callback and return it or return a completely new action var callback = args.Callback; // A function that returns a ValueTask<Outcome<HttpResponseMessage>> is required. return async () => { try { // A dedicated ActionContext is provided for each hedged action. // It comes with a separate CancellationToken created specifically for this hedged attempt, // which can be cancelled later if needed. // // Note that the \"MyRemoteCallAsync\" call won't have any additional resilience applied. // You are responsible for wrapping it with any additional resilience pipeline. var response = await MyRemoteCallAsync(args.ActionContext.CancellationToken); return Outcome.FromResult(response); } catch (Exception e) { // Note: All exceptions should be caught and converted to Outcome. return Outcome.FromException<HttpResponseMessage>(e); } }; } }); Parameterized callbacks and action generator When you have control over the callbacks that the resilience pipeline receives, you can parameterize them. This flexibility allows for reusing the callbacks within an action generator. A common use case is with DelegatingHandler. Here, you can parameterize the HttpRequestMessage: internal class HedgingHandler : DelegatingHandler { private readonly ResiliencePipeline<HttpResponseMessage> _pipeline; public HedgingHandler(ResiliencePipeline<HttpResponseMessage> pipeline) { _pipeline = pipeline; } protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) { var context = ResilienceContextPool.Shared.Get(cancellationToken); // Store the incoming request in the context context.Properties.Set(ResilienceKeys.RequestMessage, request); try { return await _pipeline.ExecuteAsync(async cxt => { // Allow the pipeline to use request message that was stored in the context. // This allows replacing the request message with a new one in the resilience pipeline. request = cxt.Properties.GetValue(ResilienceKeys.RequestMessage, request); return await base.SendAsync(request, cxt.CancellationToken); }, context); } finally { ResilienceContextPool.Shared.Return(context); } } } Where ResilienceKeys is defined as: internal static class ResilienceKeys { public static readonly ResiliencePropertyKey<HttpRequestMessage> RequestMessage = new(\"MyFeature.RequestMessage\"); } In your ActionGenerator, you can easily provide your own HttpRequestMessage to ActionContext, and the original callback will use it: new ResiliencePipelineBuilder<HttpResponseMessage>() .AddHedging(new() { ActionGenerator = args => { if (!args.PrimaryContext.Properties.TryGetValue(ResilienceKeys.RequestMessage, out var request)) { throw new InvalidOperationException(\"The request message must be provided.\"); } // Prepare a new request message for the callback, potentially involving: // // - Cloning the request message // - Providing alternate endpoint URLs request = PrepareRequest(request); // Override the request message in the action context args.ActionContext.Properties.Set(ResilienceKeys.RequestMessage, request); // Then, execute the original callback return () => args.Callback(args.ActionContext); } });"
  },
  "strategies/index.html": {
    "href": "strategies/index.html",
    "title": "Resilience strategies | Polly",
    "keywords": "Resilience strategies Resilience strategies are essential components of Polly, designed to execute user-defined callbacks while adding an extra layer of resilience. These strategies can't be executed directly; they must be run through a resilience pipeline. Polly provides an API to construct resilience pipelines by incorporating one or more resilience strategies through the pipeline builders. Polly categorizes resilience strategies into two main groups: Reactive: These strategies handle specific exceptions that are thrown, or results that are returned, by the callbacks executed through the strategy. Proactive: Unlike reactive strategies, proactive strategies do not focus on handling errors by the callbacks might throw or return. They can make proactive decisions to cancel or reject the execution of callbacks (e.g., using a rate limiter or a timeout resilience strategy). Built-in strategies Strategy Reactive Premise AKA How does the strategy mitigate? Retry Yes Many faults are transient and may self-correct after a short delay. Maybe it's just a blip Allows configuring automatic retries. Circuit-breaker Yes When a system is seriously struggling, failing fast is better than making users/callers wait. Protecting a faulting system from overload can help it recover. Stop doing it if it hurts Give that system a break Breaks the circuit (blocks executions) for a period, when faults exceed some pre-configured threshold. Timeout No Beyond a certain wait, a success result is unlikely. Don't wait forever Guarantees the caller won't have to wait beyond the timeout. Rate Limiter No Limiting the rate a system handles requests is another way to control load. This can apply to the way your system accepts incoming calls, and/or to the way you call downstream services. Slow down a bit, will you? Constrains executions to not exceed a certain rate. Fallback Yes Things will still fail - plan what you will do when that happens. Degrade gracefully Defines an alternative value to be returned (or action to be executed) on failure. Hedging Yes Things can be slow sometimes, plan what you will do when that happens. Hedge your bets Executes parallel actions when things are slow and waits for the fastest one. Usage Extensions for adding resilience strategies to the builders are provided by each strategy. Depending on the type of strategy, these extensions may be available for both ResiliencePipelineBuilder and ResiliencePipelineBuilder<T> or just one of them. Proactive strategies like timeout or rate limiter are available for both types of builders, while specialized reactive strategies are only available for ResiliencePipelineBuilder<T>. Adding multiple resilience strategies is supported. Each resilience strategy provides: Extensions for the resilience strategy builders. Configuration options (e.g., RetryStrategyOptions) to specify the strategy's behavior. Here's an simple example: ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddTimeout(new TimeoutStrategyOptions { Timeout = TimeSpan.FromSeconds(5) }) .Build(); Note The configuration options are automatically validated by Polly and come with sensible defaults. Therefore, you don't have to specify all the properties unless needed. Fault-handling in reactive strategies Each reactive strategy exposes the ShouldHandle predicate property. This property represents a predicate to determine whether the fault or the result returned after executing the resilience strategy should be managed or not. This is demonstrated below: // Create an instance of options for a retry strategy. In this example, // we use RetryStrategyOptions. You could also use other options like // CircuitBreakerStrategyOptions or FallbackStrategyOptions. var options = new RetryStrategyOptions<HttpResponseMessage>(); // PredicateBuilder can simplify the setup of the ShouldHandle predicate. options.ShouldHandle = new PredicateBuilder<HttpResponseMessage>() .HandleResult(response => !response.IsSuccessStatusCode) .Handle<HttpRequestException>(); // For greater flexibility, you can directly use the ShouldHandle delegate with switch expressions. options.ShouldHandle = args => args.Outcome switch { // Strategies may offer additional context for result handling. // For instance, the retry strategy exposes the number of attempts made. _ when args.AttemptNumber > 3 => PredicateResult.False(), { Exception: HttpRequestException } => PredicateResult.True(), { Result: HttpResponseMessage response } when !response.IsSuccessStatusCode => PredicateResult.True(), _ => PredicateResult.False() }; Some additional notes from the preceding example: PredicateBuilder is a utility API designed to make configuring predicates easier. PredicateResult.True() is shorthand for new ValueTask<bool>(true). All ShouldHandle predicates are asynchronous and have the type Func<Args<TResult>, ValueTask<bool>>. The Args<TResult> serves as a placeholder, and each strategy defines its own arguments."
  },
  "strategies/rate-limiter.html": {
    "href": "strategies/rate-limiter.html",
    "title": "Rate limiter resilience strategy | Polly",
    "keywords": "Rate limiter resilience strategy About Options: RateLimiterStrategyOptions Extensions: AddRateLimiter, AddConcurrencyLimiter Strategy Type: Proactive Exceptions: RateLimiterRejectedException: Thrown when a rate limiter rejects an execution. Package: Polly.RateLimiting The rate limiter resilience strategy controls the number of operations that can pass through it. This strategy is a thin layer over the API provided by the System.Threading.RateLimiting package. Further reading: Announcing rate limiting for .NET Rate limiting API documentation Usage // Add rate limiter with default options. // See https://www.pollydocs.org/strategies/rate-limiter#defaults for defaults. new ResiliencePipelineBuilder() .AddRateLimiter(new RateLimiterStrategyOptions()); // Create a rate limiter to allow a maximum of 100 concurrent executions and a queue of 50. new ResiliencePipelineBuilder() .AddConcurrencyLimiter(100, 50); // Create a rate limiter that allows 100 executions per minute. new ResiliencePipelineBuilder() .AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions { PermitLimit = 100, Window = TimeSpan.FromMinutes(1) })); Example execution: var pipeline = new ResiliencePipelineBuilder().AddConcurrencyLimiter(100, 50).Build(); try { // Execute an asynchronous text search operation. var result = await pipeline.ExecuteAsync( token => TextSearchAsync(query, token), cancellationToken); } catch (RateLimiterRejectedException ex) { // Handle RateLimiterRejectedException, // that can optionally contain information about when to retry. if (ex.RetryAfter is TimeSpan retryAfter) { Console.WriteLine($\"Retry After: {retryAfter}\"); } } Defaults Property Default Value Description RateLimiter null Generator that creates a RateLimitLease for executions. DefaultRateLimiterOptions PermitLimit set to 1000 and QueueLimit set to 0. The options for the default concurrency limiter that will be used when RateLimiter is null. OnRejected null Event that is raised when the execution is rejected by the rate limiter. Disposal of rate limiters The RateLimiter is a disposable resource. When you explicitly create a RateLimiter instance, it's good practice to dispose of it once it's no longer needed. This is usually not an issue when manually creating resilience pipelines using the ResiliencePipelineBuilder. However, when dynamic reloads are enabled, failing to dispose of discarded rate limiters can lead to excessive resource consumption. Fortunately, Polly provides a way to dispose of discarded rate limiters, as demonstrated in the example below: services .AddResiliencePipeline(\"my-pipeline\", (builder, context) => { var options = context.GetOptions<ConcurrencyLimiterOptions>(\"my-concurrency-options\"); // This call enables dynamic reloading of the pipeline // when the named ConcurrencyLimiterOptions change. context.EnableReloads<ConcurrencyLimiterOptions>(\"my-concurrency-options\"); var limiter = new ConcurrencyLimiter(options); builder.AddRateLimiter(limiter); // Dispose of the limiter when the pipeline is disposed. context.OnPipelineDisposed(() => limiter.Dispose()); }); The above example uses the AddResiliencePipeline(...) extension method to configure the pipeline. However, a similar approach can be taken when directly using the ResiliencePipelineRegistry<T>. Partitioned rate limiter For advanced use-cases, the partitioned rate limiter is also available. The following example illustrates how to retrieve a partition key from ResilienceContext using the GetPartitionKey method: var partitionedLimiter = PartitionedRateLimiter.Create<ResilienceContext, string>(context => { // Extract the partition key. string partitionKey = GetPartitionKey(context); return RateLimitPartition.GetConcurrencyLimiter( partitionKey, key => new ConcurrencyLimiterOptions { PermitLimit = 100 }); }); new ResiliencePipelineBuilder() .AddRateLimiter(new RateLimiterStrategyOptions { // Provide a custom rate limiter delegate. RateLimiter = args => { return partitionedLimiter.AcquireAsync(args.Context, 1, args.Context.CancellationToken); } });"
  },
  "strategies/retry.html": {
    "href": "strategies/retry.html",
    "title": "Retry resilience strategy | Polly",
    "keywords": "Retry resilience strategy About Options: RetryStrategyOptions RetryStrategyOptions<T> Extensions: AddRetry Strategy Type: Reactive Usage // Add retry using the default options. // See https://www.pollydocs.org/strategies/retry#defaults for defaults. new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions()); // For instant retries with no delay new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { Delay = TimeSpan.Zero }); // For advanced control over the retry behavior, including the number of attempts, // delay between retries, and the types of exceptions to handle. new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(), BackoffType = DelayBackoffType.Exponential, UseJitter = true, // Adds a random factor to the delay MaxRetryAttempts = 4, Delay = TimeSpan.FromSeconds(3), }); // To use a custom function to generate the delay for retries new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { MaxRetryAttempts = 2, DelayGenerator = args => { var delay = args.AttemptNumber switch { 0 => TimeSpan.Zero, 1 => TimeSpan.FromSeconds(1), _ => TimeSpan.FromSeconds(5) }; // This example uses a synchronous delay generator, // but the API also supports asynchronous implementations. return new ValueTask<TimeSpan?>(delay); } }); // To extract the delay from the result object new ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new RetryStrategyOptions<HttpResponseMessage> { DelayGenerator = args => { if (args.Outcome.Result is HttpResponseMessage responseMessage && TryGetDelay(responseMessage, out TimeSpan delay)) { return new ValueTask<TimeSpan?>(delay); } // Returning null means the retry strategy will use its internal delay for this attempt. return new ValueTask<TimeSpan?>((TimeSpan?)null); } }); // To get notifications when a retry is performed new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { MaxRetryAttempts = 2, OnRetry = args => { Console.WriteLine(\"OnRetry, Attempt: {0}\", args.AttemptNumber); // Event handlers can be asynchronous; here, we return an empty ValueTask. return default; } }); // To keep retrying indefinitely or until success use int.MaxValue. new ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions { MaxRetryAttempts = int.MaxValue, }); Defaults Property Default Value Description ShouldHandle Predicate that handles all exceptions except OperationCanceledException. Predicate that determines what results and exceptions are handled by the retry strategy. MaxRetryAttempts 3 The maximum number of retries to use, in addition to the original call. Delay 2 seconds The base delay between retries. BackoffType Constant The type of the back-off used to generate the retry delay. UseJitter False Allows adding jitter to retry delays. DelayGenerator null Used for generating custom delays for retries. OnRetry null Action executed when retry occurs. MaxDelay null Caps the calculated retry delay to a specified maximum duration. Patterns and anti-patterns Over the years, many developers have used Polly in various ways. Some of these recurring patterns may not be ideal. This section highlights the recommended practices and those to avoid. 1 - Overusing builder methods ❌ DON'T Overuse Handle/HandleResult: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder() .Handle<HttpRequestException>() .Handle<BrokenCircuitException>() .Handle<TimeoutRejectedException>() .Handle<SocketException>() .Handle<RateLimitRejectedException>(), MaxRetryAttempts = 3, }) .Build(); Reasoning: Using multiple Handle/HandleResult methods is redundant. Instead of specifying to retry if the decorated code throws a certain exception repeatedly, it's more efficient to state that retries should occur if any of the retryable exceptions are thrown. ✅ DO Use collections and simple predicate functions: ImmutableArray<Type> networkExceptions = new[] { typeof(SocketException), typeof(HttpRequestException), }.ToImmutableArray(); ImmutableArray<Type> strategyExceptions = new[] { typeof(TimeoutRejectedException), typeof(BrokenCircuitException), typeof(RateLimitRejectedException), }.ToImmutableArray(); ImmutableArray<Type> retryableExceptions = networkExceptions .Union(strategyExceptions) .ToImmutableArray(); var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = ex => new ValueTask<bool>(retryableExceptions.Contains(ex.GetType())), MaxRetryAttempts = 3, }) .Build(); Reasoning: Grouping exceptions simplifies the configuration and improves reusability. For example, the networkExceptions array can be reused in various strategies such as retry, circuit breaker, and more. 2 - Using retry for periodic execution ❌ DON'T Use a retry strategy to run indefinitely at a specified interval: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = _ => ValueTask.FromResult(true), Delay = TimeSpan.FromHours(24), }) .Build(); Reasoning: The waiting period can be either blocking or non-blocking, based on the defined strategy/pipeline. Even when used non-blockingly, it unnecessarily consumes memory that can't be reclaimed by the garbage collector. ✅ DO Use a suitable tool to schedule recurring tasks, such as Quartz.Net, Hangfire, or others. Reasoning: Polly was not designed to support this scenario; its primary purpose is to help manage brief transient failures. Specialized job scheduling tools are more memory-efficient and can be set up to withstand machine failures by using persistent storage. 3 - Combining multiple sleep duration strategies ❌ DON'T Mix increasing values with constant ones: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { DelayGenerator = args => { var delay = args.AttemptNumber switch { <= 5 => TimeSpan.FromSeconds(Math.Pow(2, args.AttemptNumber)), _ => TimeSpan.FromMinutes(3) }; return new ValueTask<TimeSpan?>(delay); } }) .Build(); Reasoning: Using this approach essentially turns the logic into a state machine. Although this offers a concise way to express sleep durations, it has several disadvantages: It doesn't support reusability (for instance, you can't use only the quick retries). The sleep duration logic is closely tied to the AttemptNumber. Testing becomes more challenging. ✅ DO Use two distinct retry strategy options and combine them: var slowRetries = new RetryStrategyOptions { MaxRetryAttempts = 5, Delay = TimeSpan.FromMinutes(3), BackoffType = DelayBackoffType.Constant }; var quickRetries = new RetryStrategyOptions { MaxRetryAttempts = 5, Delay = TimeSpan.FromSeconds(1), UseJitter = true, BackoffType = DelayBackoffType.Exponential }; var retry = new ResiliencePipelineBuilder() .AddRetry(slowRetries) .AddRetry(quickRetries) .Build(); Reasoning: While this method may appear more verbose than the first, it offers greater flexibility. Retry strategies can be arranged in any order (either slower first and then quicker, or the other way around). Different triggers can be defined for the retry strategies, allowing for switches between them based on exceptions or results. The order isn't fixed, so quick and slow retries can alternate. 4 - Branching retry logic based on request URL Suppose you have an HttpClient and you want to add a retry only for specific endpoints. ❌ DON'T Use ResiliencePipeline.Empty and the ?: operator: var retry = IsRetryable(request.RequestUri) ? new ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new()).Build() : ResiliencePipeline<HttpResponseMessage>.Empty; Reasoning: The triggering conditions and logic are spread across different sections. This design is not ideal for extensibility since adding more conditions can make the code less readable. ✅ DO Use the ShouldHandle clause to define the triggering logic: var retry = new ResiliencePipelineBuilder<HttpResponseMessage>() .AddRetry(new() { ShouldHandle = _ => ValueTask.FromResult(IsRetryable(request.RequestUri)) }) .Build(); Reasoning: The conditions for triggering are consolidated in a familiar and easily accessible location. You don't need to specify actions for scenarios when the strategy shouldn't be triggered. 5 - Calling a method before/after each retry attempt ❌ DON'T Call a specific method before Execute/ExecuteAsync: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { OnRetry = args => { BeforeEachAttempt(); return ValueTask.CompletedTask; }, }) .Build(); BeforeEachAttempt(); await retry.ExecuteAsync(DoSomething); Reasoning: The OnRetry function is triggered before each retry attempt, but it doesn't activate before the initial attempt since it's not considered a retry. Using this method across various parts can lead to accidentally omitting the BeforeEachAttempt call before every Execute. Even though the naming here is straightforward, in real-world scenarios, your method might not start with 'Before', leading to potential misuse by calling it after the Execute. ✅ DO Group the two method calls: var retry = new ResiliencePipelineBuilder() .AddRetry(new()) .Build(); await retry.ExecuteAsync(ct => { BeforeEachAttempt(); return DoSomething(ct); }); Reasoning: If DoSomething and BeforeEachAttempt are interdependent, group them or declare a simple wrapper to invoke them in the correct sequence. 6 - Having a single strategy for multiple failures Suppose we have an HttpClient that issues a request and then we try to parse a large JSON response. ❌ DON'T Use a single strategy for everything: var builder = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), MaxRetryAttempts = 3 }); builder.AddTimeout(TimeSpan.FromMinutes(1)); var pipeline = builder.Build(); await pipeline.ExecuteAsync(static async (httpClient, ct) => { var stream = await httpClient.GetStreamAsync(new Uri(\"endpoint\"), ct); var foo = await JsonSerializer.DeserializeAsync<Foo>(stream, cancellationToken: ct); }, httpClient); Reasoning: Previously, it was suggested that you should combine X and Y only if they are part of the same failure domain. In simpler terms, a pipeline should address only one type of failure. ✅ DO Define a strategy for each failure domain: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(), MaxRetryAttempts = 3 }) .Build(); var stream = await retry.ExecuteAsync( static async (httpClient, ct) => await httpClient.GetStreamAsync(new Uri(\"endpoint\"), ct), httpClient); var timeout = new ResiliencePipelineBuilder<Foo>() .AddTimeout(TimeSpan.FromMinutes(1)) .Build(); var foo = await timeout.ExecuteAsync((ct) => JsonSerializer.DeserializeAsync<Foo>(stream, cancellationToken: ct)); Reasoning: The failure domain of a network call is different from that of deserialization. Using dedicated strategies makes the application more resilient to various transient failures. 7 - Cancelling retry for specific exceptions If you encounter a TimeoutException, you may not want to retry the operation. ❌ DON'T Embed cancellation logic within OnRetry: var ctsKey = new ResiliencePropertyKey<CancellationTokenSource>(\"cts\"); var retry = new ResiliencePipelineBuilder() .AddRetry(new() { OnRetry = args => { if (args.Outcome.Exception is TimeoutException) { if (args.Context.Properties.TryGetValue(ctsKey, out var cts)) { cts.Cancel(); } } return ValueTask.CompletedTask; } }) .Build(); Reasoning: Conditions for triggering retries should be located in ShouldHandle. Bypassing the strategy from within a user-defined delegate—either through an Exception or a CancellationToken—unnecessarily complicates the control flow. ✅ DO Set the condition for retry within ShouldHandle: var retry = new ResiliencePipelineBuilder() .AddRetry(new() { ShouldHandle = args => ValueTask.FromResult(args.Outcome.Exception is not TimeoutException) }) .Build(); Reasoning: As previously mentioned, always use the designated area to define retry conditions. Reframe your original exit conditions to specify when a retry should be initiated. Limiting the maximum delay In some cases, you might want to set a limit on the calculated delay. This is beneficial when multiple retries are anticipated, and you wish to prevent excessive wait times between these retries. Consider the following example of a long-running background job: ResiliencePipeline pipeline = new ResiliencePipelineBuilder() .AddRetry(new() { Delay = TimeSpan.FromSeconds(2), MaxRetryAttempts = int.MaxValue, // Initially, we aim for an exponential backoff, but after a certain number of retries, we set a maximum delay of 15 minutes. MaxDelay = TimeSpan.FromMinutes(15), UseJitter = true }) .Build(); // Background processing while (!cancellationToken.IsCancellationRequested) { await pipeline.ExecuteAsync(async token => { // In the event of a prolonged service outage, we can afford to wait for a successful retry since this is a background task. await SynchronizeDataAsync(token); }, cancellationToken); await Task.Delay(TimeSpan.FromMinutes(30)); // The sync runs every 30 minutes. }"
  },
  "strategies/timeout.html": {
    "href": "strategies/timeout.html",
    "title": "Timeout resilience strategy | Polly",
    "keywords": "Timeout resilience strategy About Options: TimeoutStrategyOptions Extensions: AddTimeout Strategy Type: Proactive Exceptions: TimeoutRejectedException: Thrown when a delegate executed through a timeout strategy does not complete before the timeout. Usage // Add timeout using the default options. // See https://www.pollydocs.org/strategies/timeout#defaults for defaults. new ResiliencePipelineBuilder() .AddTimeout(new TimeoutStrategyOptions()); // To add a timeout with a custom TimeSpan duration new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(3)); // To add a timeout using a custom timeout generator function new ResiliencePipelineBuilder() .AddTimeout(new TimeoutStrategyOptions { TimeoutGenerator = args => { // Note: the timeout generator supports asynchronous operations return new ValueTask<TimeSpan>(TimeSpan.FromSeconds(123)); } }); // To add a timeout and listen for timeout events new ResiliencePipelineBuilder() .AddTimeout(new TimeoutStrategyOptions { TimeoutGenerator = args => { // Note: the timeout generator supports asynchronous operations return new ValueTask<TimeSpan>(TimeSpan.FromSeconds(123)); }, OnTimeout = args => { Console.WriteLine($\"{args.Context.OperationKey}: Execution timed out after {args.Timeout.TotalSeconds} seconds.\"); return default; } }); Example execution: var pipeline = new ResiliencePipelineBuilder() .AddTimeout(TimeSpan.FromSeconds(3)) .Build(); HttpResponseMessage httpResponse = await pipeline.ExecuteAsync( async ct => { // Execute a delegate that takes a CancellationToken as an input parameter. return await httpClient.GetAsync(endpoint, ct); }, cancellationToken); Defaults Property Default Value Description Timeout 30 seconds The default timeout used by the strategy. TimeoutGenerator null Generates the timeout for a given execution. OnTimeout null Event that is raised when timeout occurs."
  },
  "v7/extensibility.html": {
    "href": "v7/extensibility.html",
    "title": "Custom policies | Polly",
    "keywords": "Custom policies From Polly v7.0 it is possible to create your own custom policies outside Polly. These custom policies can integrate in to all the existing goodness from Polly: the Policy.Handle<>() syntax; PolicyWrap; all the execution-dispatch overloads. For more info see our blog series: Part I: Introducing custom Polly policies and the Polly.Contrib Part II: Authoring a non-reactive custom policy (a policy which acts on all executions) Part III: Authoring a reactive custom policy (a policy which react to faults). Part IV: Custom policies for all execution types: sync and async, generic and non-generic. We provide a starter template for a custom policy for developing your own custom policy."
  }
}