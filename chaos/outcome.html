<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Outcome chaos strategy | Polly </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Outcome chaos strategy | Polly ">
      
      
      <link rel="icon" href="../icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/App-vNext/Polly/blob/main/docs/chaos/outcome.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../icon.png" alt="Polly">
            Polly
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="outcome-chaos-strategy">Outcome chaos strategy</h1>

<h2 id="about">About</h2>
<ul>
<li><strong>Option(s)</strong>:
<ul>
<li><a class="xref" href="../api/Polly.Simmy.Outcomes.ChaosOutcomeStrategyOptions-1.html"><code>ChaosOutcomeStrategyOptions&lt;T&gt;</code></a></li>
</ul>
</li>
<li><strong>Extension(s)</strong>:
<ul>
<li><code>AddChaosOutcome</code></li>
</ul>
</li>
<li><strong>Exception(s)</strong>: -</li>
</ul>
<hr>
<p>The outcome <strong>reactive</strong> chaos strategy is designed to inject or substitute fake results into system operations. This allows testing how an application behaves when it receives different types of responses, like successful results, errors, or exceptions.</p>
<h2 id="usage">Usage</h2>
<!-- snippet: chaos-outcome-usage -->
<pre><code class="lang-cs">// To use OutcomeGenerator&lt;T&gt; to register the results and exceptions to be injected (equal probability)
var optionsWithResultGenerator = new ChaosOutcomeStrategyOptions&lt;HttpResponseMessage&gt;
{
    OutcomeGenerator = new OutcomeGenerator&lt;HttpResponseMessage&gt;()
        .AddResult(() =&gt; new HttpResponseMessage(HttpStatusCode.TooManyRequests))
        .AddResult(() =&gt; new HttpResponseMessage(HttpStatusCode.InternalServerError))
        .AddException(() =&gt; new HttpRequestException(&quot;Chaos request exception.&quot;)),
    InjectionRate = 0.1
};

// To get notifications when a result is injected
var optionsOnBehaviorInjected = new ChaosOutcomeStrategyOptions&lt;HttpResponseMessage&gt;
{
    OutcomeGenerator = new OutcomeGenerator&lt;HttpResponseMessage&gt;()
        .AddResult(() =&gt; new HttpResponseMessage(HttpStatusCode.InternalServerError)),
    InjectionRate = 0.1,
    OnOutcomeInjected = static args =&gt;
    {
        Console.WriteLine($&quot;OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.&quot;);
        return default;
    }
};

// Add a result strategy with a ChaosOutcomeStrategyOptions{&lt;TResult&gt;} instance to the pipeline
new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;().AddChaosOutcome(optionsWithResultGenerator);
new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;().AddChaosOutcome(optionsOnBehaviorInjected);

// There are also a couple of handy overloads to inject the chaos easily
new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;().AddChaosOutcome(0.1, () =&gt; new HttpResponseMessage(HttpStatusCode.TooManyRequests));
</code></pre>
<!-- endSnippet -->
<p>Example execution:</p>
<!-- snippet: chaos-outcome-execution -->
<pre><code class="lang-cs">var pipeline = new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddRetry(new RetryStrategyOptions&lt;HttpResponseMessage&gt;
    {
        ShouldHandle = static args =&gt; args.Outcome switch
        {
            { Result.StatusCode: HttpStatusCode.InternalServerError } =&gt; PredicateResult.True(),
            _ =&gt; PredicateResult.False()
        },
        BackoffType = DelayBackoffType.Exponential,
        UseJitter = true,
        MaxRetryAttempts = 4,
        Delay = TimeSpan.FromSeconds(3),
    })
    .AddChaosOutcome(new ChaosOutcomeStrategyOptions&lt;HttpResponseMessage&gt; // Chaos strategies are usually placed as the last ones in the pipeline
    {
        OutcomeGenerator = static args =&gt;
        {
            var response = new HttpResponseMessage(HttpStatusCode.InternalServerError);
            return ValueTask.FromResult&lt;Outcome&lt;HttpResponseMessage&gt;?&gt;(Outcome.FromResult(response));
        },
        InjectionRate = 0.1
    })
    .Build();
</code></pre>
<!-- endSnippet -->
<h2 id="defaults">Defaults</h2>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OutcomeGenerator</code></td>
<td><code>null</code></td>
<td>This required delegate allows you to inject custom outcome by utilizing information that is only available at runtime.</td>
</tr>
<tr>
<td><code>OnOutcomeInjected</code></td>
<td><code>null</code></td>
<td>If provided then it will be invoked after the outcome injection occurred.</td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>Please note this strategy is a reactive chaos strategy, but it does not have a <code>ShouldHandle</code> delegate.</p>
</div>
<h2 id="telemetry">Telemetry</h2>
<p>The outcome chaos strategy reports the following telemetry events:</p>
<table>
<thead>
<tr>
<th>Event Name</th>
<th>Event Severity</th>
<th>When?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Chaos.OnOutcome</code></td>
<td><code>Information</code></td>
<td>Just before the strategy calls the <code>OnOutcomeInjected</code> delegate</td>
</tr>
</tbody>
</table>
<p>Here are some sample events:</p>
<pre><code class="lang-none">Resilience event occurred. EventName: 'Chaos.OnOutcome', Source: '(null)/(null)/Chaos.Outcome', Operation Key: '', Result: ''

Resilience event occurred. EventName: 'Chaos.OnOutcome', Source: 'MyPipeline/MyPipelineInstance/MyOutcomeStrategy', Operation Key: 'MyOutcomeInjectedOperation', Result: ''
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Please note that the <code>Chaos.OnOutcome</code> telemetry event will be reported <strong>only if</strong> the outcome chaos strategy injects an outcome object.</p>
<p>So, if the outcome is not injected or injected but the generator delegate throws an exception then there will be no telemetry emitted.</p>
<p>Also remember that the <code>Result</code> will be <strong>always empty</strong> for the <code>Chaos.OnOutcome</code> telemetry event.</p>
</div>
<p>For further information please check out the <a href="../advanced/telemetry.html">telemetry page</a>.</p>
<h2 id="diagrams">Diagrams</h2>
<h3 id="normal--sequence-diagram">Normal 🐵 sequence diagram</h3>
<pre><code class="lang-mermaid">sequenceDiagram
    actor C as Caller
    participant P as Pipeline
    participant B as Outcome
    participant D as DecoratedUserCallback

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;B: Calls ExecuteCore
    activate B
    B--&gt;&gt;B: Determines Injection&lt;br/&gt;Decision: 🐵
    deactivate B
    B-&gt;&gt;+D: Invokes
    D-&gt;&gt;-B: Returns result
    B-&gt;&gt;P: Returns result
    P-&gt;&gt;C: Returns result
</code></pre>
<h3 id="chaos--sequence-diagram">Chaos 🙈 sequence diagram</h3>
<pre><code class="lang-mermaid">sequenceDiagram
    actor C as Caller
    participant P as Pipeline
    participant B as Outcome
    participant D as DecoratedUserCallback

    C-&gt;&gt;P: Calls ExecuteAsync
    P-&gt;&gt;B: Calls ExecuteCore
    activate B
    B--&gt;&gt;B: Determines Injection&lt;br/&gt;Decision: 🙈
    B--&gt;&gt;B: Injects Outcome
    deactivate B
    Note over D: The user's Callback is not invoked&lt;br/&gt;when a fake result is injected
    B-&gt;&gt;P: Returns result
    P-&gt;&gt;C: Returns result
</code></pre>
<h2 id="generating-outcomes">Generating outcomes</h2>
<p>To generate a faulted outcome (result or exception), you need to specify a <code>OutcomeGenerator</code> delegate. You have the following options as to how you customize this delegate:</p>
<h3 id="use-outcomegeneratort-class-to-generate-outcomes">Use <code>OutcomeGenerator&lt;T&gt;</code> class to generate outcomes</h3>
<p>The <code>OutcomeGenerator&lt;T&gt;</code> is a convenience API that allows you to specify what outcomes (results or exceptions) are to be injected. Additionally, it also allows assigning weight to each registered outcome.</p>
<!-- snippet: chaos-outcome-generator-class -->
<pre><code class="lang-cs">new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddChaosOutcome(new ChaosOutcomeStrategyOptions&lt;HttpResponseMessage&gt;
    {
        // Use OutcomeGenerator&lt;T&gt; to register the results and exceptions to be injected
        OutcomeGenerator = new OutcomeGenerator&lt;HttpResponseMessage&gt;()
            .AddResult(() =&gt; new HttpResponseMessage(HttpStatusCode.InternalServerError)) // Result generator
            .AddResult(() =&gt; new HttpResponseMessage(HttpStatusCode.TooManyRequests), weight: 50) // Result generator with weight
            .AddResult(context =&gt; new HttpResponseMessage(CreateResultFromContext(context))) // Access the ResilienceContext to create result
            .AddException&lt;HttpRequestException&gt;(), // You can also register exceptions
    });
</code></pre>
<!-- endSnippet -->
<h3 id="use-delegates-to-generate-outcomes">Use delegates to generate outcomes</h3>
<p>Delegates give you the most flexibility at the expense of slightly more complicated syntax. Delegates also support asynchronous outcome generation, if you ever need that possibility.</p>
<!-- snippet: chaos-outcome-generator-delegate -->
<pre><code class="lang-cs">new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddChaosOutcome(new ChaosOutcomeStrategyOptions&lt;HttpResponseMessage&gt;
    {
        // The same behavior can be achieved with delegates
        OutcomeGenerator = static args =&gt;
        {
            Outcome&lt;HttpResponseMessage&gt;? outcome = Random.Shared.Next(350) switch
            {
                &lt; 100 =&gt; Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.InternalServerError)),
                &lt; 150 =&gt; Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.TooManyRequests)),
                &lt; 250 =&gt; Outcome.FromResult(new HttpResponseMessage(CreateResultFromContext(args.Context))),
                &lt; 350 =&gt; Outcome.FromException&lt;HttpResponseMessage&gt;(new TimeoutException()),
                _ =&gt; Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.OK))
            };

            return ValueTask.FromResult(outcome);
        }
    });
</code></pre>
<!-- endSnippet -->
<h2 id="anti-patterns">Anti-patterns</h2>
<h3 id="injecting-faults-exceptions">Injecting faults (exceptions)</h3>
<p>❌ DON'T</p>
<p>Use outcome strategies to inject faults in advanced scenarios which you need to inject outcomes using delegates. This is an opinionated anti-pattern since you can consider an exception as a result/outcome, however, there might be undesired implications when doing so. One of these implications is these is to the telemetry events. Events might end up affecting your metrics as the <code>ChaosOutcomeStrategy</code> reports both result and exceptions in the same way. This could pose a problem for instrumentation purposes since it's clearer looking for fault injected events to be 100% sure where/when exceptions were injected, rather than have them mixed in the same &quot;bag&quot;.</p>
<p>Another problem is that you end up losing control of how/when to inject outcomes vs. faults. This is because the approach does not allow you to separately control when to inject a fault vs. an outcome.</p>
<!-- snippet: chaos-outcome-anti-pattern-generator-inject-fault -->
<pre><code class="lang-cs">var pipeline = new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddChaosOutcome(new ChaosOutcomeStrategyOptions&lt;HttpResponseMessage&gt;
    {
        InjectionRate = 0.5, // Same injection rate for both fault and outcome
        OutcomeGenerator = static args =&gt;
        {
            Outcome&lt;HttpResponseMessage&gt;? outcome = Random.Shared.Next(350) switch
            {
                &lt; 100 =&gt; Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.InternalServerError)),
                &lt; 150 =&gt; Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.TooManyRequests)),
                &lt; 250 =&gt; Outcome.FromResult(new HttpResponseMessage(CreateResultFromContext(args.Context))),
                &lt; 350 =&gt; Outcome.FromException&lt;HttpResponseMessage&gt;(new HttpRequestException(&quot;Chaos request exception.&quot;)), // ⚠️ Avoid this ⚠️
                _ =&gt; Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.OK))
            };

            return ValueTask.FromResult(outcome);
        },
        OnOutcomeInjected = static args =&gt;
        {
            // You might have to put some logic here to determine what kind of output was injected. 😕
            if (args.Outcome.Exception != null)
            {
                Console.WriteLine($&quot;OnBehaviorInjected, Exception: {args.Outcome.Exception.Message}, Operation: {args.Context.OperationKey}.&quot;);
            }
            else
            {
                Console.WriteLine($&quot;OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.&quot;);
            }

            return default;
        }
    })
    .Build();
</code></pre>
<!-- endSnippet -->
<p>✅ DO</p>
<p>The previous approach is tempting since it looks like less code, but use fault chaos instead as the <a href="fault.html"><code>ChaosFaultStrategy</code></a> correctly tracks telemetry events as faults, not just as any other outcome. By separating them, you can control the injection rate and enable/disable them separately which gives you more control when it comes to injecting chaos dynamically and in a controlled manner.</p>
<!-- snippet: chaos-outcome-pattern-generator-inject-fault -->
<pre><code class="lang-cs">var pipeline = new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddChaosFault(new ChaosFaultStrategyOptions
    {
        InjectionRate = 0.1, // Different injection rate for faults
        EnabledGenerator = static args =&gt; ShouldEnableFaults(args.Context), // Different settings might apply to inject faults
        FaultGenerator = static args =&gt;
        {
            Exception? exception = RandomThreshold switch
            {
                &gt;= 250 and &lt; 350 =&gt; new HttpRequestException(&quot;Chaos request exception.&quot;),
                _ =&gt; null
            };

            return ValueTask.FromResult(exception);
        },
        OnFaultInjected = static args =&gt;
        {
            Console.WriteLine($&quot;OnFaultInjected, Exception: {args.Fault.Message}, Operation: {args.Context.OperationKey}.&quot;);
            return default;
        }
    })
    .AddChaosOutcome(new ChaosOutcomeStrategyOptions&lt;HttpResponseMessage&gt;
    {
        InjectionRate = 0.5, // Different injection rate for outcomes
        EnabledGenerator = static args =&gt; ShouldEnableOutcome(args.Context), // Different settings might apply to inject outcomes
        OutcomeGenerator = static args =&gt;
        {
            HttpStatusCode statusCode = RandomThreshold switch
            {
                &lt; 100 =&gt; HttpStatusCode.InternalServerError,
                &lt; 150 =&gt; HttpStatusCode.TooManyRequests,
                &lt; 250 =&gt; CreateResultFromContext(args.Context),
                _ =&gt; HttpStatusCode.OK
            };

            return ValueTask.FromResult&lt;Outcome&lt;HttpResponseMessage&gt;?&gt;(Outcome.FromResult(new HttpResponseMessage(statusCode)));
        },
        OnOutcomeInjected = static args =&gt;
        {
            Console.WriteLine($&quot;OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.&quot;);
            return default;
        }
    })
    .Build();
</code></pre>
<!-- endSnippet -->
<p>❌ DON'T</p>
<p>Use outcome strategies to inject only faults, use the <a href="fault.html"><code>ChaosFaultStrategy</code></a> instead.</p>
<!-- snippet: chaos-outcome-anti-pattern-only-inject-fault -->
<pre><code class="lang-cs">new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddChaosOutcome(new ChaosOutcomeStrategyOptions&lt;HttpResponseMessage&gt;
    {
        OutcomeGenerator = new OutcomeGenerator&lt;HttpResponseMessage&gt;()
            .AddException&lt;HttpRequestException&gt;(),  // ⚠️ Avoid this ⚠️
    });
</code></pre>
<!-- endSnippet -->
<p>✅ DO</p>
<p>Use fault strategies to inject the exception.</p>
<!-- snippet: chaos-outcome-pattern-only-inject-fault -->
<pre><code class="lang-cs">new ResiliencePipelineBuilder&lt;HttpResponseMessage&gt;()
    .AddChaosFault(new ChaosFaultStrategyOptions
    {
        FaultGenerator = new FaultGenerator()
            .AddException&lt;HttpRequestException&gt;(),
    });
</code></pre>
<!-- endSnippet -->
<div class="NOTE">
<h5>Note</h5>
<p>Even though the outcome strategy is flexible enough to allow you to inject outcomes as well as exceptions without the need to chain a fault strategy in the pipeline, use your judgment when doing so because of the caveats and side effects explained regarding telemetry and injection control.</p>
</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/App-vNext/Polly/blob/main/docs/chaos/outcome.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
