<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Resilience pipeline registry | Polly </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Resilience pipeline registry | Polly ">
      
      
      <link rel="icon" href="../icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/App-vNext/Polly/blob/main/docs/pipelines/resilience-pipeline-registry.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../icon.png" alt="Polly">
            Polly
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="resilience-pipeline-registry">Resilience pipeline registry</h1>

<p>The <code>ResiliencePipelineRegistry&lt;TKey&gt;</code> is designed to create and cache resilience pipeline instances. The registry also implements the <code>ResiliencePipelineProvider&lt;TKey&gt;</code>, allowing read-only access to pipelines.</p>
<p>The registry offers these features:</p>
<ul>
<li>Thread-safe retrieval and dynamic creation for both generic and non-generic resilience pipelines.</li>
<li>Dynamic reloading of resilience pipelines when configurations change.</li>
<li>Capability to register both generic and non-generic resilience pipeline builders, enabling dynamic pipeline instance creation.</li>
<li>Automated resource management, which includes disposing of resources linked to resilience pipelines.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>The generic <code>TKey</code> parameter sets the key type for caching individual resilience pipelines within the registry. Typically, you would use the string-based <code>ResiliencePipelineRegistry&lt;string&gt;</code>.</p>
</div>
<h2 id="usage">Usage</h2>
<p>To register pipeline builders, use the <code>TryAddBuilder(...)</code> method. This method accepts a callback argument that configures an instance of <code>ResiliencePipelineBuilder</code> for the pipeline being defined. The registry supports both generic and non-generic resilience pipelines.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Please note that you do not have to call the <code>Build</code> method after you have set up your pipeline on the <code>builder</code> parameter of the <code>TryAddBuilder</code>. You can call the <code>Build</code> if you want but it is not necessary.</p>
</div>
<p>Here's an example demonstrating these features:</p>
<!-- snippet: registry-usage -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

// Register builder for pipeline &quot;A&quot;
registry.TryAddBuilder(&quot;A&quot;, (builder, context) =&gt;
{
    // Define your pipeline
    builder.AddRetry(new RetryStrategyOptions());
});

// Register generic builder for pipeline &quot;A&quot;; you can use the same key
// because generic and non-generic pipelines are stored separately
registry.TryAddBuilder&lt;HttpResponseMessage&gt;(&quot;A&quot;, (builder, context) =&gt;
{
    // Define your pipeline
    builder.AddRetry(new RetryStrategyOptions&lt;HttpResponseMessage&gt;());
});

// Fetch pipeline &quot;A&quot;
ResiliencePipeline pipelineA = registry.GetPipeline(&quot;A&quot;);

// Fetch generic pipeline &quot;A&quot;
ResiliencePipeline&lt;HttpResponseMessage&gt; genericPipelineA = registry.GetPipeline&lt;HttpResponseMessage&gt;(&quot;A&quot;);

// Returns false since pipeline &quot;unknown&quot; isn't registered
var doesPipelineExist = registry.TryGetPipeline(&quot;unknown&quot;, out var pipeline);

// Throws KeyNotFoundException because pipeline &quot;unknown&quot; isn't registered
try
{
    registry.GetPipeline(&quot;unknown&quot;);
}
catch (KeyNotFoundException)
{
    // Handle the exception
}
</code></pre>
<!-- endSnippet -->
<p>Additionally, the registry allows you to add pipelines with the <code>GetOrAddPipeline(...)</code> method. In this method, there's no need to register builders. Instead, the caller provides a factory method called when the pipeline isn't cached:</p>
<!-- snippet: registry-usage-no-builder -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

// Dynamically retrieve or create pipeline &quot;A&quot;
ResiliencePipeline pipeline = registry.GetOrAddPipeline(&quot;A&quot;, (builder, context) =&gt;
{
    // Define your pipeline
    builder.AddRetry(new RetryStrategyOptions());
});

// Dynamically retrieve or create generic pipeline &quot;A&quot;
ResiliencePipeline&lt;HttpResponseMessage&gt; genericPipeline = registry.GetOrAddPipeline&lt;HttpResponseMessage&gt;(&quot;A&quot;, (builder, context) =&gt;
{
    // Define your pipeline
    builder.AddRetry(new RetryStrategyOptions&lt;HttpResponseMessage&gt;());
});
</code></pre>
<!-- endSnippet -->
<h2 id="registry-options">Registry options</h2>
<p>The constructor for <code>ResiliencePipelineRegistry&lt;TKey&gt;</code> accepts a parameter of type <code>ResiliencePipelineRegistryOptions&lt;TKey&gt;</code>. This parameter lets you configure the behavior of the registry. Here's a breakdown of the available properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BuilderFactory</code></td>
<td>Function returning a new <code>ResiliencePipelineBuilder</code> each time.</td>
<td>Allows consumers to customize builder creation.</td>
</tr>
<tr>
<td><code>PipelineComparer</code></td>
<td><code>EqualityComparer&lt;TKey&gt;.Default</code></td>
<td>Comparer the registry uses to fetch resilience pipelines.</td>
</tr>
<tr>
<td><code>BuilderComparer</code></td>
<td><code>EqualityComparer&lt;TKey&gt;.Default</code></td>
<td>Comparer the registry uses to fetch registered pipeline builders.</td>
</tr>
<tr>
<td><code>InstanceNameFormatter</code></td>
<td><code>null</code></td>
<td>Delegate formatting <code>TKey</code> to instance name.</td>
</tr>
<tr>
<td><code>BuilderNameFormatter</code></td>
<td>Function returning the <code>key.ToString()</code> value.</td>
<td>Delegate formatting <code>TKey</code> to builder name.</td>
</tr>
</tbody>
</table>
<div class="NOTE">
<h5>Note</h5>
<p>The <code>BuilderName</code> and <code>InstanceName</code> are used in <a href="../advanced/telemetry.html#metrics">telemetry</a>.</p>
</div>
<p>Usage example:</p>
<!-- snippet: registry-options -->
<pre><code class="lang-cs">var options = new ResiliencePipelineRegistryOptions&lt;string&gt;
{
    BuilderComparer = StringComparer.OrdinalIgnoreCase,
    PipelineComparer = StringComparer.OrdinalIgnoreCase,
    BuilderFactory = () =&gt; new ResiliencePipelineBuilder
    {
        InstanceName = &quot;lets change the default of InstanceName&quot;,
        Name = &quot;lets change the default of Name&quot;,
    },
    BuilderNameFormatter = key =&gt; $&quot;key:{key}&quot;,
    InstanceNameFormatter = key =&gt; $&quot;instance-key:{key}&quot;,
};

var registry = new ResiliencePipelineRegistry&lt;string&gt;();
</code></pre>
<!-- endSnippet -->
<p>Even though the example might seem unnecessary, given that the defaults for a registry using the <code>string</code> type are suitable, it showcases the various properties of the registry and how to set them up. This is particularly helpful when you use <a href="#complex-registry-keys">complex registry keys</a>.</p>
<h2 id="dynamic-reloads">Dynamic reloads</h2>
<p>Dynamic reloading lets you refresh cached pipelines when the reload token, represented as a <code>CancellationToken</code>, is triggered. To enable dynamic reloads:</p>
<!-- snippet: registry-reloads -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

registry.TryAddBuilder(&quot;A&quot;, (builder, context) =&gt;
{
    // Add the reload token. Tokens that are already canceled are ignored.
    context.AddReloadToken(cancellationToken);

    // Define the pipeline.
    builder.AddRetry(new RetryStrategyOptions());
});

// This instance remains valid even after a reload.
ResiliencePipeline pipeline = registry.GetPipeline(&quot;A&quot;);
</code></pre>
<!-- endSnippet -->
<ul>
<li>If an error occurs during reloading, the cached pipeline remains, and dynamic reloading stops.</li>
<li>You should <strong>not</strong> reuse the cancellation token when the pipeline is reloaded.</li>
<li>Pipelines enabled for reloads remain valid and current post-reload. The registry manages this transparently.</li>
</ul>
<h3 id="how-dynamic-reloads-work">How dynamic reloads work</h3>
<p>Dynamic reloading is a concept anchored in the registry, while the <a class="xref" href="../api/Polly.ResiliencePipelineBuilder.html">ResiliencePipelineBuilder</a> remains agnostic to it. The registry employs callbacks to configure the builders, and these callbacks are invoked right before the creation of the pipeline. When dynamic reloading is activated, the registry monitors any changes that could affect the pipeline, seamlessly reloading it as needed. The reloading process involves invoking the callback that configures the pipeline; within this callback is also the call to the <code>AddReloadToken</code> method. Thus, each reload also enables dynamic reloads for that particular pipeline. As a consumer, you may opt to stop reloading by simply not invoking the <code>AddReloadToken</code> method. It's crucial to note that if any error occurs during reloading, the previous pipeline is retained, reloading is halted, and Polly emits a <code>ReloadFailed</code> telemetry event.</p>
<h2 id="resource-disposal">Resource disposal</h2>
<p>The registry caches and manages all pipelines and resources linked to them. When you dispose of the registry, all pipelines created by it are also disposed of and can't be used anymore. The following example illustrates this:</p>
<!-- snippet: registry-disposed -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

// This instance is valid even after reload.
ResiliencePipeline pipeline = registry
    .GetOrAddPipeline(&quot;A&quot;, (builder, context) =&gt; builder.AddTimeout(TimeSpan.FromSeconds(10)));

// Dispose the registry
registry.Dispose();

try
{
    pipeline.Execute(() =&gt; { });
}
catch (ObjectDisposedException)
{
    // Using a pipeline that was disposed by the registry
}
</code></pre>
<!-- endSnippet -->
<p>The registry also allows for the registration of dispose callbacks. These are called when a pipeline is discarded, either because of the registry's disposal or after the pipeline has reloaded. The example below works well with dynamic reloads, letting you dispose of the <code>CancellationTokenSource</code> when it's not needed anymore.</p>
<!-- snippet: registry-reloads-and-dispose -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

registry.TryAddBuilder(&quot;A&quot;, (builder, context) =&gt;
{
    var cancellation = new CancellationTokenSource();

    // Register the source for potential external triggering
    RegisterCancellationSource(cancellation);

    // Add the reload token; note that an already cancelled token is disregarded
    context.AddReloadToken(cancellation.Token);

    // Configure your pipeline
    builder.AddRetry(new RetryStrategyOptions());

    context.OnPipelineDisposed(() =&gt; cancellation.Dispose());
});
</code></pre>
<!-- endSnippet -->
<p>Both <code>AddReloadToken(...)</code> and <code>OnPipelineDisposed(...)</code> are used to implement the <code>EnableReloads&lt;TOptions&gt;(...)</code> extension method that is used by the <a href="../advanced/dependency-injection.html#dynamic-reloads">Dependency Injection layer</a>.</p>
<h3 id="how-resource-disposal-works">How resource disposal works</h3>
<p>Resource disposal occurs when the registry is disposed of or when the pipeline undergoes changes due to <a href="#dynamic-reloads">dynamic reloads</a>. Upon disposal, all callbacks registered through the <code>OnPipelineDisposed</code> method are invoked. However, actual resource disposal is deferred until the pipeline completes all outgoing executions. It's vital to note that dispose callbacks are associated only with a specific instance of the pipeline.</p>
<h3 id="disposal-of-encapsulated-rate-limiters">Disposal of encapsulated rate limiters</h3>
<p>If you are using custom rate limiters and want to dispose them on pipeline reload or when a registry is disposed, then you should use the <code>OnPipelineDisposed</code> callback.</p>
<p>Consider the following runnable example. It creates a registry with a concurrency strategy and a chained rate limiter strategy (which contains multiple rate limiters):</p>
<!-- snippet: registry-ratelimiter-dispose -->
<pre><code class="lang-cs">public static class Program
{
    public static void Main()
    {
        using var registryAdapter = new PipelineRegistryAdapter();
        registryAdapter.GetOrCreateResiliencePipeline(&quot;Pipeline foo&quot;, 1, 10, 100, 1000);
        registryAdapter.GetOrCreateResiliencePipeline(&quot;Pipeline bar&quot;, 2, 20, 200, 2000);
    }
}

public sealed class PipelineRegistryAdapter : IDisposable
{
    private readonly ResiliencePipelineRegistry&lt;string&gt; _resiliencePipelineRegistry = new();
    private bool _disposed;

    public void Dispose()
    {
        if (!_disposed)
        {
            _resiliencePipelineRegistry.Dispose();
            _disposed = true;
        }
    }

    private static PartitionedRateLimiter&lt;ResilienceContext&gt; CreateConcurrencyLimiter(string partitionKey, int permitLimit) =&gt;
        PartitionedRateLimiter.Create&lt;ResilienceContext, string&gt;(context =&gt;
            RateLimitPartition.GetConcurrencyLimiter(
                partitionKey: partitionKey,
                factory: partitionKey =&gt; new ConcurrencyLimiterOptions { PermitLimit = permitLimit, QueueLimit = 0 }));

    private static PartitionedRateLimiter&lt;ResilienceContext&gt; CreateFixedWindowLimiter(string partitionKey, int permitLimit, TimeSpan window) =&gt;
        PartitionedRateLimiter.Create&lt;ResilienceContext, string&gt;(context =&gt;
            RateLimitPartition.GetFixedWindowLimiter(
                partitionKey: partitionKey,
                factory: partitionKey =&gt; new FixedWindowRateLimiterOptions { PermitLimit = permitLimit, QueueLimit = 0, Window = window }));

    public ResiliencePipeline GetOrCreateResiliencePipeline(string partitionKey, int maximumConcurrentThreads, int sendLimitPerSecond, int sendLimitPerHour, int sendLimitPerDay)
    {
        return _resiliencePipelineRegistry.GetOrAddPipeline(partitionKey, (builder, context) =&gt;
        {
            PartitionedRateLimiter&lt;ResilienceContext&gt;? threadLimiter = null;
            PartitionedRateLimiter&lt;ResilienceContext&gt;? requestLimiter = null;

            // outer strategy: limit threads
            builder.AddRateLimiter(new RateLimiterStrategyOptions
            {
                RateLimiter = args =&gt;
                {
                    threadLimiter = CreateConcurrencyLimiter(partitionKey, maximumConcurrentThreads);
                    return threadLimiter.AcquireAsync(args.Context, permitCount: 1, args.Context.CancellationToken);
                }
            });

            // inner strategy: limit requests (by second, hour, day)
            builder.AddRateLimiter(new RateLimiterStrategyOptions
            {
                RateLimiter = args =&gt;
                {
                    PartitionedRateLimiter&lt;ResilienceContext&gt;[] limiters = [
                        CreateFixedWindowLimiter(partitionKey, sendLimitPerSecond, TimeSpan.FromSeconds(1)),
                        CreateFixedWindowLimiter(partitionKey, sendLimitPerHour,   TimeSpan.FromHours(1)),
                        CreateFixedWindowLimiter(partitionKey, sendLimitPerDay,    TimeSpan.FromDays(1)),
                    ];
                    requestLimiter = PartitionedRateLimiter.CreateChained(limiters);
                    return requestLimiter.AcquireAsync(args.Context, permitCount: 1, args.Context.CancellationToken);
                }
            });

            // unlike other strategies, rate limiters disposed manually
            context.OnPipelineDisposed(() =&gt;
            {
                threadLimiter?.Dispose();
                requestLimiter?.Dispose();
            });
        });
    }
}
</code></pre>
<!-- endSnippet -->
<p>Notice how the rate limiters are disposed manually in the <code>OnPipelineDisposed</code> callback.</p>
<h2 id="complex-registry-keys">Complex registry keys</h2>
<p>Though the pipeline registry supports complex keys, we suggest you use them when defining pipelines with the <a href="../advanced/dependency-injection.html">Dependency Injection</a> (DI) containers. For further information, see the <a href="../advanced/dependency-injection.html#complex-pipeline-keys">section on complex pipeline keys</a>.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/App-vNext/Polly/blob/main/docs/pipelines/resilience-pipeline-registry.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
