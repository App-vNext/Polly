<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Resilience pipeline registry | Polly </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Resilience pipeline registry | Polly ">
      
      <link rel="icon" href="../icon.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/App-vNext/Polly/blob/main/docs/pipelines/resilience-pipeline-registry.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module">
    import options from './../public/main.js'
    import { init } from './../public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../icon.png" alt="Polly">
            Polly
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="resilience-pipeline-registry">Resilience pipeline registry</h1>

<div class="NOTE">
<h5>Note</h5>
<p>This documentation supports the upcoming Polly v8 release.</p>
</div>
<p>The <code>ResiliencePipelineRegistry&lt;TKey&gt;</code> is designed to create and cache resilience pipeline instances. The registry also implements the <code>ResiliencePipelineProvider&lt;TKey&gt;</code>, allowing read-only access to pipelines.</p>
<p>The registry offers these features:</p>
<ul>
<li>Thread-safe retrieval and dynamic creation for both generic and non-generic resilience pipelines.</li>
<li>Dynamic reloading of resilience pipelines when configurations change.</li>
<li>Capability to register both generic and non-generic resilience pipeline builders, enabling dynamic pipeline instance creation.</li>
<li>Automated resource management, which includes disposing of resources linked to resilience pipelines.</li>
</ul>
<div class="NOTE">
<h5>Note</h5>
<p>The generic <code>TKey</code> parameter sets the key type for caching individual resilience pipelines within the registry. Typically, you would use the string-based <code>ResiliencePipelineRegistry&lt;string&gt;</code>.</p>
</div>
<h2 id="usage">Usage</h2>
<p>To register pipeline builders, use the <code>TryAddBuilder(...)</code> method. This method accepts a callback argument that configures an instance of <code>ResiliencePipelineBuilder</code> for the pipeline being defined. The registry supports both generic and non-generic resilience pipelines.</p>
<p>Here's an example demonstrating these features:</p>
<!-- snippet: registry-usage -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

// Register builder for pipeline &quot;A&quot;
registry.TryAddBuilder(&quot;A&quot;, (builder, context) =&gt;
{
    // Define your pipeline
    builder.AddRetry(new RetryStrategyOptions());
});

// Register generic builder for pipeline &quot;A&quot;; you can use the same key
// because generic and non-generic pipelines are stored separately
registry.TryAddBuilder&lt;HttpResponseMessage&gt;(&quot;A&quot;, (builder, context) =&gt;
{
    // Define your pipeline
    builder.AddRetry(new RetryStrategyOptions&lt;HttpResponseMessage&gt;());
});

// Fetch pipeline &quot;A&quot;
ResiliencePipeline pipelineA = registry.GetPipeline(&quot;A&quot;);

// Fetch generic pipeline &quot;A&quot;
ResiliencePipeline&lt;HttpResponseMessage&gt; genericPipelineA = registry.GetPipeline&lt;HttpResponseMessage&gt;(&quot;A&quot;);

// Returns false since pipeline &quot;unknown&quot; isn't registered
registry.TryGetPipeline(&quot;unknown&quot;, out var pipeline);

// Throws KeyNotFoundException because pipeline &quot;unknown&quot; isn't registered
try
{
    registry.GetPipeline(&quot;unknown&quot;);
}
catch (KeyNotFoundException)
{
    // Handle the exception
}
</code></pre>
<!-- endSnippet -->
<p>Additionally, the registry allows you to add pipelines with the <code>GetOrAddPipeline(...)</code> method. In this method, there's no need to register builders. Instead, the caller provides a factory method called when the pipeline isn't cached:</p>
<!-- snippet: registry-usage-no-builder -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

// Dynamically retrieve or create pipeline &quot;A&quot;
ResiliencePipeline pipeline = registry.GetOrAddPipeline(&quot;A&quot;, (builder, context) =&gt;
{
    // Define your pipeline
    builder.AddRetry(new RetryStrategyOptions());
});

// Dynamically retrieve or create generic pipeline &quot;A&quot;
ResiliencePipeline&lt;HttpResponseMessage&gt; genericPipeline = registry.GetOrAddPipeline&lt;HttpResponseMessage&gt;(&quot;A&quot;, (builder, context) =&gt;
{
    // Define your pipeline
    builder.AddRetry(new RetryStrategyOptions&lt;HttpResponseMessage&gt;());
});
</code></pre>
<!-- endSnippet -->
<h2 id="registry-options">Registry options</h2>
<p>The constructor for <code>ResiliencePipelineRegistry&lt;TKey&gt;</code> accepts a parameter of type <code>ResiliencePipelineRegistryOptions&lt;TKey&gt;</code>. This parameter lets you configure the behavior of the registry. Here's a breakdown of the available properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Default Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BuilderFactory</code></td>
<td>Function returning a new <code>ResiliencePipelineBuilder</code> each time.</td>
<td>Allows consumers to customize builder creation.</td>
</tr>
<tr>
<td><code>PipelineComparer</code></td>
<td><code>EqualityComparer&lt;TKey&gt;.Default</code></td>
<td>Comparer the registry uses to fetch resilience pipelines.</td>
</tr>
<tr>
<td><code>BuilderComparer</code></td>
<td><code>EqualityComparer&lt;TKey&gt;.Default</code></td>
<td>Comparer the registry uses to fetch registered pipeline builders.</td>
</tr>
<tr>
<td><code>InstanceNameFormatter</code></td>
<td><code>null</code></td>
<td>Delegate formatting <code>TKey</code> to instance name.</td>
</tr>
<tr>
<td><code>BuilderNameFormatter</code></td>
<td>Function returning the <code>key.ToString()</code> value.</td>
<td>Delegate formatting <code>TKey</code> to builder name.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>[&gt;NOTE]
The <code>BuilderName</code> and <code>InstanceName</code> are used in <a href="../advanced/telemetry.html#metrics">telemetry</a>.</p>
</blockquote>
<p>Usage example:</p>
<!-- snippet: registry-options -->
<pre><code class="lang-cs">var options = new ResiliencePipelineRegistryOptions&lt;string&gt;
{
    BuilderComparer = StringComparer.OrdinalIgnoreCase,
    PipelineComparer = StringComparer.OrdinalIgnoreCase,
    BuilderFactory = () =&gt; new ResiliencePipelineBuilder
    {
        InstanceName = &quot;lets change the defaults&quot;,
        Name = &quot;lets change the defaults&quot;,
    },
    BuilderNameFormatter = key =&gt; $&quot;key:{key}&quot;,
    InstanceNameFormatter = key =&gt; $&quot;instance-key:{key}&quot;,
};

var registry = new ResiliencePipelineRegistry&lt;string&gt;();
</code></pre>
<!-- endSnippet -->
<p>Even though the example might seem unnecessary, given that the defaults for a registry using the <code>string</code> type are suitable, it showcases the various properties of the registry and how to set them up. This is particularly helpful when you use <a href="#complex-registry-keys">complex registry keys</a>.</p>
<h2 id="dynamic-reloads">Dynamic reloads</h2>
<p>Dynamic reloading lets you refresh cached pipelines when the reload token, represented as a <code>CancellationToken</code>, is triggered. To enable dynamic reloads:</p>
<!-- snippet: registry-reloads -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

registry.TryAddBuilder(&quot;A&quot;, (builder, context) =&gt;
{
    // Add the reload token. Tokens that are already canceled are ignored.
    context.AddReloadToken(cancellationToken);

    // Define the pipeline.
    builder.AddRetry(new RetryStrategyOptions());
});

// This instance remains valid even after a reload.
ResiliencePipeline pipeline = registry.GetPipeline(&quot;A&quot;);
</code></pre>
<!-- endSnippet -->
<ul>
<li>If an error occurs during reloading, the cached pipeline remains, and dynamic reloading stops.</li>
<li>You should not reuse the cancellation token when the pipeline is reloaded.</li>
<li>Pipelines enabled for reloads remain valid and current post-reload. The registry manages this transparently.</li>
</ul>
<h2 id="resource-disposal">Resource disposal</h2>
<p>The registry caches and manages all pipelines and resources linked to them. When you dispose of the registry, all pipelines created by it are also disposed of and can't be used anymore. The following example illustrates this:</p>
<!-- snippet: registry-disposed -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

// This instance is valid even after reload.
ResiliencePipeline pipeline = registry
    .GetOrAddPipeline(&quot;A&quot;, (builder, context) =&gt; builder.AddTimeout(TimeSpan.FromSeconds(10)));

// Dispose the registry
registry.Dispose();

try
{
    pipeline.Execute(() =&gt; { });
}
catch (ObjectDisposedException)
{
    // Using a pipeline that was disposed by the registry
}
</code></pre>
<!-- endSnippet -->
<p>The registry also allows for the registration of dispose callbacks. These are called when a pipeline is discarded, either because of the registry's disposal or after the pipeline has reloaded. The example below works well with dynamic reloads, letting you dispose of the <code>CancellationTokenSource</code> when it's not needed anymore.</p>
<!-- snippet: registry-reloads-and-dispose -->
<pre><code class="lang-cs">var registry = new ResiliencePipelineRegistry&lt;string&gt;();

registry.TryAddBuilder(&quot;A&quot;, (builder, context) =&gt;
{
    var cancellation = new CancellationTokenSource();

    // Register the source for potential external triggering
    RegisterCancellationSource(cancellation);

    // Add the reload token; note that an already cancelled token is disregarded
    context.AddReloadToken(cancellation.Token);

    // Configure your pipeline
    builder.AddRetry(new RetryStrategyOptions());

    context.OnPipelineDisposed(() =&gt; cancellation.Dispose());
});
</code></pre>
<!-- endSnippet -->
<p>Both <code>AddReloadToken(...)</code> and <code>OnPipelineDisposed(...)</code> are used to implement the <code>EnableReloads&lt;TOptions&gt;(...)</code> extension method that is used by the <a href="../advanced/dependency-injection.html#dynamic-reloads">Dependency Injection layer</a>.</p>
<h2 id="complex-registry-keys">Complex registry keys</h2>
<p>Though the pipeline registry supports complex keys, we suggest you use them when defining pipelines with the <a href="../advanced/dependency-injection.html">Dependency Injection</a> (DI) containers. For further information, see the <a href="../advanced/dependency-injection.html#complex-pipeline-keys">section on complex pipeline keys</a>.</p>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/App-vNext/Polly/blob/main/docs/pipelines/resilience-pipeline-registry.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>
        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>